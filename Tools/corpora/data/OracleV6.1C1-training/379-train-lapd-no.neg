COMMENT will children be started automatically when they are added DECL STMT SPECIFIER protected TYPE boolean NAME boolean NAME start children INIT true EXPR true will children be started automatically when they are added root ROOT started aux started will nsubjpass started children auxpass started be advmod started automatically advmod added when nsubjpass added they auxpass added are advcl started added protected VBN boolean NN start VB children NNS root ROOT start dobj start children true JJ added started ANTONYM ANTONYM
COMMENT sets function name and sets its parent to this node param name function name code null for anonymous functions FUNCTION SPECIFIER public TYPE void NAME void NAME set function name PARAMETER LIST name name PARAMETER name name TYPE name NAME name NAME name BLOCK EXPR function name name NAME function name NAME name IF if name null name set parent this CONDITION name null EXPR name null NAME name THEN name set parent this BLOCK EXPR name set parent this CALL name set parent this NAME name set parent NAME name NAME set parent ARGUMENT LIST ARGUMENT EXPR this NAME this sets function name and sets its parent to this node root ROOT function nsubj function sets nsubj sets sets dobj function name cc function and conj and function sets nmod poss parent its dobj sets parent case node to det node this nmod to sets node param name function name code null for anonymous functions root ROOT null compound null param compound null name compound null function compound null name compound null code case functions for amod functions anonymous nmod for null functions public NN void NN set NN function NN name NN root ROOT name compound name set compound name function name NN name NN function NN name NN root ROOT name compound name function name NN if IN name NN null JJ name NN set VBD parent NN root ROOT set nsubj set name dobj set parent this DT name parent ANTONYM ANTONYM
FUNCTION SPECIFIER public TYPE name NAME name NAME get function name PARAMETER LIST BLOCK RETURN return function name EXPR function name NAME function name public NN name NN get VB function NN name NN root ROOT get compound name function dobj get name return NN function NN name NN root ROOT name compound name function
DECL STMT SPECIFIER private TYPE list ast node NAME list ast node NAME list ARGUMENT LIST ARGUMENT NAME ast node NAME params private JJ list NN ast IN node NN root ROOT node case node ast params NNS
DECL STMT SPECIFIER private TYPE boolean NAME boolean NAME is generator private JJ boolean NN is VBZ generator NN root ROOT generator cop generator is
COMMENT returns whether this is a function closure FUNCTION SPECIFIER public TYPE boolean NAME boolean NAME is expression closure PARAMETER LIST BLOCK RETURN return is expression closure EXPR is expression closure NAME is expression closure returns whether this is a function closure root ROOT returns mark function whether nsubj function this cop function is det function a ccomp returns function dobj function closure public NN boolean NN is VBZ expression NN closure NN root ROOT closure cop closure is compound closure expression return NN is VBZ expression NN closure NN root ROOT closure cop closure is compound closure expression
COMMENT sets base starting line number for this script or function this is a one time operation and throws an exception if the line number has already been set FUNCTION SPECIFIER public TYPE void NAME void NAME set base lineno PARAMETER LIST int lineno PARAMETER int lineno TYPE int NAME int NAME lineno BLOCK IF if lineno this lineno code bug CONDITION lineno this lineno EXPR lineno this lineno NAME lineno NAME this lineno NAME this NAME lineno THEN code bug BLOCK EXPR code bug CALL code bug NAME code bug ARGUMENT LIST EXPR this lineno lineno NAME this lineno NAME this NAME lineno NAME lineno sets base starting line number for this script or function root ROOT number compound number sets compound number base amod number starting compound number line case script for det script this nmod for number script cc script or nmod for number function conj or script function this is a one time operation and throws an exception if the root ROOT operation nsubj operation this nsubj throws this cop operation is det operation a nummod operation one compound operation time cc operation and conj and operation throws det exception an dobj operation exception case the if nmod if exception the line number has already been set root ROOT set compound number line nsubjpass set number aux set has advmod set already auxpass set been public NN void NN set VBN base NN lineno NN root ROOT set compound lineno base dobj set lineno int NN lineno NN if IN lineno NN this DT lineno NN code NN bug NN root ROOT bug compound bug code this DT lineno NN lineno NN base set ANTONYM ANTONYM function operation ANTONYM ANTONYM number function ANTONYM ANTONYM or operation ANTONYM ANTONYM sets base ANTONYM ANTONYM starting function ANTONYM ANTONYM starting has ANTONYM ANTONYM
COMMENT returns true if the named property is defined as a const on this object param name return true if the named property is defined as a const false otherwise FUNCTION SPECIFIER public TYPE boolean NAME boolean NAME is const PARAMETER LIST string name PARAMETER string name TYPE string NAME string NAME name BLOCK DECL STMT TYPE slot NAME slot NAME slot INIT get slot name slot query EXPR get slot name slot query CALL get slot name slot query NAME get slot ARGUMENT LIST ARGUMENT EXPR name NAME name ARGUMENT EXPR ARGUMENT EXPR slot query NAME slot query IF if slot null return false CONDITION slot null EXPR slot null NAME slot THEN return false BLOCK RETURN return false EXPR false RETURN return slot get attributes permanent readonly permanent readonly EXPR slot get attributes permanent readonly permanent readonly CALL slot get attributes NAME slot get attributes NAME slot NAME get attributes ARGUMENT LIST NAME permanent NAME readonly NAME permanent NAME readonly returns true if the named property is defined as a const on this object root ROOT returns amod returns true mark defined if det property the amod property named nsubjpass defined property auxpass defined is advcl if true defined case const as det const a nmod as defined const case object on det object this nmod on const object param name root ROOT name compound name param return true if the named property is defined as a const false root ROOT return amod return true mark defined if det property the amod property named nsubjpass defined property auxpass defined is advcl if true defined case const as det const a nmod as defined const amod const false otherwise public NN boolean NN is VBZ const IN root ROOT const cop const is string NN name NN slot NN slot NN get VB slot NN root ROOT get dobj get slot name NN slot NN query NN root ROOT query compound query slot if IN slot NN null JJ return NN false JJ return NN slot NN get VB attributes NNS root ROOT get nsubj get slot dobj get attributes permanent JJ readonly RB permanent JJ readonly RB is name ANTONYM ANTONYM named is ANTONYM ANTONYM true false ANTONYM ANTONYM false null SYNONYM SYNONYM
DECL STMT SPECIFIER private TYPE int NAME int NAME syntax error count private JJ int NN syntax NN error NN count NN root ROOT count compound count syntax compound count error
FUNCTION SPECIFIER public TYPE void NAME void NAME inject authentication PARAMETER LIST repository system session session list artifact repository repositories PARAMETER repository system session session TYPE repository system session NAME repository system session NAME session PARAMETER list artifact repository repositories TYPE list artifact repository NAME list artifact repository NAME list ARGUMENT LIST ARGUMENT NAME artifact repository NAME repositories BLOCK IF if repositories null session null for artifact repository repository repositories repository set authentication get authentication session repository CONDITION repositories null session null EXPR repositories null session null NAME repositories NAME session THEN for artifact repository repository repositories repository set authentication get authentication session repository BLOCK FOR for artifact repository repository repositories repository set authentication get authentication session repository CONTROL artifact repository repository repositories INIT artifact repository repository repositories TYPE artifact repository NAME artifact repository NAME repository RANGE repositories EXPR repositories NAME repositories BLOCK EXPR repository set authentication get authentication session repository CALL repository set authentication get authentication session repository NAME repository set authentication NAME repository NAME set authentication ARGUMENT LIST ARGUMENT EXPR get authentication session repository CALL get authentication session repository NAME get authentication ARGUMENT LIST ARGUMENT EXPR session NAME session ARGUMENT EXPR repository NAME repository public NN void NN inject VB authentication NN root ROOT inject dobj inject authentication repository JJ system NN session NN root ROOT session amod session repository compound session system session NN list NN artifact NN repository NN root ROOT repository compound repository artifact repositories NNS if IN repositories NNS null JJ session NN null JJ for IN artifact NN repository NN root ROOT repository compound repository artifact repository NN repositories NNS repository JJ set NN authentication NN root ROOT authentication amod authentication repository compound authentication set get VB authentication NN root ROOT get dobj get authentication session NN repository NN
COMMENT gets the dependencies that could not be resolved return the unresolved dependencies never code null FUNCTION DECL list dependency get unresolved dependencies TYPE list dependency NAME list dependency NAME list ARGUMENT LIST ARGUMENT NAME dependency NAME get unresolved dependencies PARAMETER LIST gets the dependencies that could not be resolved root ROOT gets det dependencies the dobj gets dependencies nsubjpass resolved dependencies ref dependencies that aux resolved could neg resolved not auxpass resolved be acl relcl dependencies resolved return the unresolved dependencies never code null root ROOT return det dependencies the amod dependencies unresolved nsubj code dependencies neg code never ccomp return code dobj code null list NN dependency NN get VB unresolved JJ dependencies NNS root ROOT get amod dependencies unresolved dobj get dependencies gets return ANTONYM ANTONYM resolved unresolved ANTONYM ANTONYM
DECL STMT SPECIFIER private TYPE maven metadata cache NAME maven metadata cache NAME cache private JJ maven NN metadata NN cache NN root ROOT cache compound cache maven compound cache metadata cache NN
COMMENT nodes incident to this depend on me DECL STMT TYPE list metadata graph node NAME list metadata graph node NAME list ARGUMENT LIST ARGUMENT NAME metadata graph node NAME in nodes nodes incident to this depend on me root ROOT incident compound incident nodes mark depend to nsubj depend this acl to incident depend case me on nmod on depend me list NN metadata NN graph NN node NN root ROOT node compound node metadata compound node graph in IN nodes NNS root ROOT nodes case nodes in
FUNCTION SPECIFIER public TYPE int NAME int NAME hash code PARAMETER LIST BLOCK IF if metadata null return super hash code CONDITION metadata null EXPR metadata null NAME metadata THEN return super hash code BLOCK RETURN return super hash code EXPR super hash code CALL super hash code NAME super hash code NAME super NAME hash code ARGUMENT LIST RETURN return metadata to string hash code EXPR metadata to string hash code CALL metadata to string NAME metadata to string NAME metadata NAME to string ARGUMENT LIST CALL hash code NAME hash code ARGUMENT LIST public NN int NN hash VB code NN root ROOT hash dobj hash code if IN metadata NN null JJ return NN super JJ hash NN code NN return NN metadata NN to TO string NN root ROOT metadata case string to nmod to metadata string hash VB code NN root ROOT hash dobj hash code
COMMENT checks the url to see if this repository refers to an external repository param original repository return true if external FUNCTION SPECIFIER static TYPE boolean NAME boolean NAME is external repo PARAMETER LIST artifact repository original repository PARAMETER artifact repository original repository TYPE artifact repository NAME artifact repository NAME original repository BLOCK TRY try url url new url original repository get url return url get host equals localhost url get host equals url get protocol equals file catch malformed url exception e bad url just skip it here it should have been validated already but the wagon lookup will deal with it return false BLOCK DECL STMT TYPE url NAME url NAME url INIT new url original repository get url EXPR new url original repository get url CALL url original repository get url NAME url ARGUMENT LIST ARGUMENT EXPR original repository get url CALL original repository get url NAME original repository get url NAME original repository NAME get url ARGUMENT LIST RETURN return url get host equals localhost url get host equals url get protocol equals file EXPR url get host equals localhost url get host equals url get protocol equals file CALL url get host NAME url get host NAME url NAME get host ARGUMENT LIST CALL equals localhost NAME equals ARGUMENT LIST ARGUMENT EXPR localhost CALL url get host NAME url get host NAME url NAME get host ARGUMENT LIST CALL equals NAME equals ARGUMENT LIST ARGUMENT EXPR CALL url get protocol NAME url get protocol NAME url NAME get protocol ARGUMENT LIST CALL equals file NAME equals ARGUMENT LIST ARGUMENT EXPR file CATCH catch malformed url exception e bad url just skip it here it should have been validated already but the wagon lookup will deal with it return false PARAMETER LIST malformed url exception e PARAMETER malformed url exception e TYPE malformed url exception NAME malformed url exception NAME e BLOCK COMMENT bad url just skip it here it should have been validated already but the wagon lookup will deal with it RETURN return false EXPR false checks the url to see if this repository refers to an external repository root ROOT checks det url the dobj checks url mark see to acl to url see mark refers if det repository this nsubj refers repository advcl if see refers case repository to det repository an amod repository external nmod to refers repository param original repository root ROOT repository compound repository param amod repository original return true if external root ROOT return amod return true mark external if advcl if true external static JJ boolean NN is VBZ external JJ repo NN root ROOT repo cop repo is amod repo external artifact NN repository NN root ROOT repository compound repository artifact original JJ repository NN root ROOT repository amod repository original try VB url NN url NN new JJ url NN original JJ repository JJ get VB url NN root ROOT get amod repository original nsubj get repository dobj get url return NN url NN get VB host NN root ROOT get nsubj get url dobj get host equals VBZ localhost NN url NN get VB host NN root ROOT get nsubj get url dobj get host equals VBZ url NN get VB protocol NN root ROOT get nsubj get url dobj get protocol equals VBZ file NN catch NN malformed JJ url NN exception NN root ROOT exception amod exception malformed compound exception url e SYM bad url just skip it here it should have been validated already but the wagon lookup will deal with it root ROOT skip amod url bad nsubj skip url advmod skip just dobj skip it advmod skip here nsubjpass validated it aux validated should aux validated have auxpass validated been dep skip validated advmod validated already cc validated but det lookup the compound lookup wagon nsubj deal lookup aux deal will dep skip deal conj but validated deal case it with nmod with deal it bad url just skip it here it should have been validated already but the wagon lookup will deal with it root ROOT skip amod url bad nsubj skip url advmod skip just dobj skip it advmod skip here nsubjpass validated it aux validated should aux validated have auxpass validated been dep skip validated advmod validated already cc validated but det lookup the compound lookup wagon nsubj deal lookup aux deal will dep skip deal conj but validated deal case it with nmod with deal it return NN false JJ bad just ANTONYM ANTONYM bad new ANTONYM ANTONYM bad true ANTONYM ANTONYM catch have ANTONYM ANTONYM checks catch ANTONYM ANTONYM checks catch ANTONYM ANTONYM checks equals ANTONYM ANTONYM checks have ANTONYM ANTONYM checks return ANTONYM ANTONYM equals catch ANTONYM ANTONYM have deal ANTONYM ANTONYM just new ANTONYM ANTONYM just true ANTONYM ANTONYM refers equals ANTONYM ANTONYM return have ANTONYM ANTONYM return try ANTONYM ANTONYM see deal ANTONYM ANTONYM see have ANTONYM ANTONYM see try ANTONYM ANTONYM true false ANTONYM ANTONYM bad false SYNONYM SYNONYM
FUNCTION SPECIFIER public TYPE void NAME void NAME set global update policy PARAMETER LIST string update policy PARAMETER string update policy TYPE string NAME string NAME update policy BLOCK EXPR global update policy update policy NAME global update policy NAME update policy public NN void NN set VBN global JJ update VBP policy NN root ROOT set xcomp set global dep set update dobj update policy string NN update VB policy NN root ROOT update dobj update policy global JJ update VBP policy NN root ROOT update nsubj update global dobj update policy update VB policy NN root ROOT update dobj update policy
FUNCTION SPECIFIER public TYPE void NAME void NAME set global checksum policy PARAMETER LIST string checksum policy PARAMETER string checksum policy TYPE string NAME string NAME checksum policy BLOCK EXPR global checksum policy checksum policy NAME global checksum policy NAME checksum policy public NN void NN set VBN global JJ checksum NN policy NN root ROOT set amod policy global compound policy checksum dobj set policy string NN checksum NN policy NN root ROOT policy compound policy checksum global JJ checksum NN policy NN root ROOT policy amod policy global compound policy checksum checksum NN policy NN root ROOT policy compound policy checksum
DECL STMT SPECIFIER private TYPE final set string SPECIFIER final NAME set string NAME set ARGUMENT LIST ARGUMENT NAME string NAME q names INIT new hash set EXPR new hash set CALL hash set NAME hash set NAME hash set ARGUMENT LIST ARGUMENT LIST private JJ final JJ set NN string NN q VB names NNS root ROOT q dobj q names new JJ hash JJ set NN root ROOT set amod set hash
FUNCTION SPECIFIER public TYPE void NAME void NAME clear PARAMETER LIST BLOCK EXPR q names clear CALL q names clear NAME q names clear NAME q names NAME clear ARGUMENT LIST EXPR super clear CALL super clear NAME super clear NAME super NAME clear ARGUMENT LIST public NN void NN clear JJ q VB names NNS clear JJ root ROOT q nsubj clear names xcomp q clear super JJ clear JJ public clear ANTONYM ANTONYM
COMMENT first element of the queue DECL STMT SPECIFIER protected TYPE entry NAME entry NAME first first element of the queue root ROOT element amod element first case queue of det queue the nmod of element queue first element of the queue root ROOT element amod element first case queue of det queue the nmod of element queue protected VBN entry NN first RB
COMMENT maximum size of the queue DECL STMT SPECIFIER private TYPE final int SPECIFIER final NAME int NAME max size maximum size of the queue root ROOT size amod size maximum case queue of det queue the nmod of size queue private JJ final JJ int NN max NN size NN root ROOT size compound size max
FUNCTION SPECIFIER private SPECIFIER final TYPE entry NAME entry NAME get previous PARAMETER LIST BLOCK RETURN return previous EXPR previous NAME previous private JJ final JJ entry NN get VB previous JJ root ROOT get xcomp get previous return NN previous JJ
DECL STMT TYPE final int SPECIFIER final NAME int NAME ord final JJ int NN ord NN
DECL STMT TYPE long NAME long NAME fp end long RB fp NN end NN root ROOT end compound end fp
DECL STMT TYPE byte NAME byte NAME byte INDEX NAME stat bytes INIT new byte EXPR new byte NAME byte NAME byte INDEX EXPR byte NN stat NN bytes NNS root ROOT bytes compound bytes stat new JJ byte NN
DECL STMT TYPE byte NAME byte NAME byte INDEX NAME floor data INIT new byte EXPR new byte NAME byte NAME byte INDEX EXPR byte NN floor NN data NNS root ROOT data compound data floor new JJ byte NN
DECL STMT TYPE byte NAME byte NAME byte INDEX NAME suffix bytes INIT new byte EXPR new byte NAME byte NAME byte INDEX EXPR byte NN suffix NN bytes NNS root ROOT bytes compound bytes suffix new JJ byte NN
DECL STMT TYPE int NAME int NAME prefix int NN prefix NN
COMMENT true if all entries are terms DECL STMT TYPE boolean NAME boolean NAME is leaf block true if all entries are terms root ROOT true mark terms if det entries all nsubj terms entries cop terms are advcl if true terms boolean NN is VBZ leaf NN block NN root ROOT block cop block is compound block leaf
DECL STMT SPECIFIER public SPECIFIER static TYPE final int SPECIFIER final NAME int NAME version current INIT EXPR public NN static JJ final JJ int NN version NN current JJ root ROOT current compound current version
DECL STMT SPECIFIER private TYPE int NAME int NAME bloom size private JJ int NN bloom NN size NN root ROOT size compound size bloom
COMMENT records a value in the set the referenced bytes are hashed and then modulo n d where n is the chosen size of the internal bitset param value the key value to be hashed throws io exception if there is a low level i o error FUNCTION SPECIFIER public TYPE void NAME void NAME add value PARAMETER LIST bytes ref value PARAMETER bytes ref value TYPE bytes ref NAME bytes ref NAME value THROWS throws io exception ARGUMENT EXPR io exception NAME io exception BLOCK DECL STMT TYPE int NAME int NAME hash INIT hash function hash value EXPR hash function hash value CALL hash function hash value NAME hash function hash NAME hash function NAME hash ARGUMENT LIST ARGUMENT EXPR value NAME value IF if hash hash hash CONDITION hash EXPR hash NAME hash THEN hash hash BLOCK EXPR hash hash NAME hash NAME hash COMMENT bitmasking using bloom size is effectively a modulo operation DECL STMT TYPE int NAME int NAME bloom pos INIT hash bloom size EXPR hash bloom size NAME hash NAME bloom size EXPR filter set bloom pos CALL filter set bloom pos NAME filter set NAME filter NAME set ARGUMENT LIST ARGUMENT EXPR bloom pos NAME bloom pos records a value in the set the referenced bytes are hashed and then modulo n d where n is the root ROOT records det value a dobj records value case set in det set the nmod in hashed set det bytes the amod bytes referenced nsubjpass hashed bytes auxpass hashed are dep value hashed cc hashed and advmod d then compound d modulo compound d n dep value d conj and hashed d advmod the where nsubj the n cop the is acl relcl d the records a value in the set the referenced bytes are hashed and then modulo n d where n is the root ROOT records det value a dobj records value case set in det set the nmod in hashed set det bytes the amod bytes referenced nsubjpass hashed bytes auxpass hashed are dep value hashed cc hashed and advmod d then compound d modulo compound d n dep value d conj and hashed d advmod the where nsubj the n cop the is acl relcl d the chosen size of the internal bitset root ROOT size amod size chosen case bitset of det bitset the amod bitset internal nmod of size bitset param value the key value to be hashed root ROOT value compound value param det value the amod value key dep value value mark hashed to auxpass hashed be acl to value hashed throws io exception if there is a low level i o error root ROOT throws compound exception io dobj throws exception mark is if expl is there advcl if throws is det level a amod level low nsubj is level compound error i compound error o dep level error public NN void NN add VB value NN root ROOT add dobj add value bytes NNS ref VBP root ROOT ref nsubj ref bytes value NN throws VBZ io NN exception NN root ROOT exception compound exception io int NN hash NN hash NN function NN hash VBP root ROOT hash compound function hash nsubj hash function value NN if IN hash NN hash NN hash NN bitmasking using bloom size is effectively a modulo operation root ROOT operation csubj operation bitmasking xcomp bitmasking using compound size bloom dobj using size cop operation is advmod operation effectively det operation a amod operation modulo int NN bloom NN pos NNS root ROOT pos compound pos bloom hash NN bloom NN size NN root ROOT size compound size bloom filter NN set NN root ROOT set compound set filter bloom NN pos NNS root ROOT pos compound pos bloom d key ANTONYM ANTONYM i key ANTONYM ANTONYM level set ANTONYM ANTONYM public internal ANTONYM ANTONYM d i SYNONYM SYNONYM
FUNCTION SPECIFIER public TYPE long NAME long NAME ram bytes used PARAMETER LIST BLOCK RETURN return ram usage estimator size of filter get bits EXPR ram usage estimator size of filter get bits CALL ram usage estimator size of filter get bits NAME ram usage estimator size of NAME ram usage estimator NAME size of ARGUMENT LIST ARGUMENT EXPR filter get bits CALL filter get bits NAME filter get bits NAME filter NAME get bits ARGUMENT LIST public NN long RB ram NN bytes NNS used VBN root ROOT used compound bytes ram nsubj used bytes return NN ram NN usage NN estimator NN size NN of IN root ROOT size compound size ram compound size usage compound size estimator acl size of filter NN get VB bits NNS root ROOT get nsubj get filter dobj get bits
FUNCTION SPECIFIER public TYPE boolean NAME boolean NAME is saturated PARAMETER LIST fuzzy set bloom filter field info field info PARAMETER fuzzy set bloom filter TYPE fuzzy set NAME fuzzy set NAME bloom filter PARAMETER field info field info TYPE field info NAME field info NAME field info BLOCK COMMENT don t bother saving bitsets if of bits are set we don t want to COMMENT throw any more memory at this problem RETURN return bloom filter get saturation f EXPR bloom filter get saturation f CALL bloom filter get saturation NAME bloom filter get saturation NAME bloom filter NAME get saturation ARGUMENT LIST public NN boolean NN is VBZ saturated VBN root ROOT saturated auxpass saturated is fuzzy JJ set NN root ROOT set amod set fuzzy bloom NN filter NN root ROOT filter compound filter bloom field NN info NN root ROOT info compound info field field NN info NN root ROOT info compound info field don t bother saving bitsets if of bits are set we don t want to root ROOT don nsubj bother t ccomp don bother xcomp bother saving dobj saving bitsets mark set if mwe if of nsubjpass set bits auxpass set are advcl if of bother set nsubj don we ccomp set don nsubj want t nsubj xsubj to t ccomp don want xcomp want to throw any more memory at this problem root ROOT throw det memory any amod memory more dobj throw memory case problem at det problem this nmod at throw problem return NN bloom NN filter NN get VB saturation NN root ROOT get compound filter bloom nsubj get filter dobj get saturation f SYM bother problem ANTONYM ANTONYM saving return ANTONYM ANTONYM throw return ANTONYM ANTONYM
FUNCTION SPECIFIER public TYPE int NAME int NAME size PARAMETER LIST BLOCK RETURN return fields size EXPR fields size CALL fields size NAME fields size NAME fields NAME size ARGUMENT LIST public NN int NN size NN return NN fields NNS size NN root ROOT size compound size fields
FUNCTION SPECIFIER public TYPE void NAME void NAME check integrity PARAMETER LIST THROWS throws io exception ARGUMENT EXPR io exception NAME io exception BLOCK COMMENT term dictionary EXPR codec util checksum entire file in CALL codec util checksum entire file in NAME codec util checksum entire file NAME codec util NAME checksum entire file ARGUMENT LIST ARGUMENT EXPR in NAME in COMMENT postings EXPR postings reader check integrity CALL postings reader check integrity NAME postings reader check integrity NAME postings reader NAME check integrity ARGUMENT LIST public NN void NN check NN integrity NN root ROOT integrity compound integrity check throws VBZ io NN exception NN root ROOT exception compound exception io term dictionary root ROOT dictionary compound dictionary term codec NN util NN checksum NN entire JJ file NN root ROOT file compound file codec compound file util compound file checksum amod file entire in IN postings postings NNS reader NN check NN integrity NN root ROOT integrity compound integrity postings compound integrity reader compound integrity check
DECL STMT SPECIFIER private TYPE final list field meta data SPECIFIER final NAME list field meta data NAME list ARGUMENT LIST ARGUMENT NAME field meta data NAME fields INIT new array list EXPR new array list CALL array list NAME array list NAME array list ARGUMENT LIST ARGUMENT LIST private JJ final JJ list NN field NN meta NN data NNS root ROOT data compound data field compound data meta fields NNS new JJ array NN list NN root ROOT list compound list array
COMMENT reused in write blocks DECL STMT SPECIFIER private TYPE final list pending block SPECIFIER final NAME list pending block NAME list ARGUMENT LIST ARGUMENT NAME pending block NAME new blocks INIT new array list EXPR new array list CALL array list NAME array list NAME array list ARGUMENT LIST ARGUMENT LIST reused in write blocks root ROOT reused mark write in advcl in reused write dobj write blocks private JJ final JJ list NN pending VBG block NN root ROOT block amod block pending new JJ blocks NNS root ROOT blocks amod blocks new new JJ array NN list NN root ROOT list compound list array
DECL STMT SPECIFIER private TYPE pending term NAME pending term NAME first pending term private JJ pending VBG term NN root ROOT term amod term pending first RB pending VBG term NN root ROOT term advmod term first amod term pending
DECL STMT SPECIFIER private TYPE pending term NAME pending term NAME last pending term private JJ pending VBG term NN root ROOT term amod term pending last JJ pending JJ term NN root ROOT term amod term last amod term pending
FUNCTION SPECIFIER public TYPE void NAME void NAME finish doc PARAMETER LIST THROWS throws io exception ARGUMENT EXPR io exception NAME io exception BLOCK IF if last doc id doc is deleted skip it return CONDITION last doc id EXPR last doc id NAME last doc id THEN doc is deleted skip it return BLOCK COMMENT doc is deleted skip it RETURN return IF if last position throw new illegal argument exception missing add position CONDITION last position EXPR last position NAME last position THEN throw new illegal argument exception missing add position BLOCK THROW throw new illegal argument exception missing add position EXPR new illegal argument exception missing add position CALL illegal argument exception missing add position NAME illegal argument exception ARGUMENT LIST ARGUMENT EXPR missing add position public NN void NN finish NN doc NN root ROOT doc compound doc finish throws VBZ io NN exception NN root ROOT exception compound exception io if IN last JJ doc NN id NN root ROOT id amod id last compound id doc doc is deleted skip it root ROOT deleted nsubjpass deleted doc auxpass deleted is xcomp deleted skip dobj skip it return NN if IN last JJ position NN root ROOT position amod position last throw VB new JJ illegal JJ argument NN exception NN root ROOT exception amod exception illegal compound exception argument missing VBG add VB position NN root ROOT add dobj add position return throw ANTONYM ANTONYM throw missing ANTONYM ANTONYM throws missing ANTONYM ANTONYM throws return ANTONYM ANTONYM
DECL STMT SPECIFIER private TYPE long NAME long NAME last encoded version private JJ long RB last JJ encoded VBN version NN root ROOT version amod version last amod version encoded
FUNCTION SPECIFIER public TYPE void NAME void NAME encode term PARAMETER LIST long longs data output out field info field info block term state state boolean absolute PARAMETER long longs TYPE long NAME long NAME long INDEX NAME longs PARAMETER data output out TYPE data output NAME data output NAME out PARAMETER field info field info TYPE field info NAME field info NAME field info PARAMETER block term state state TYPE block term state NAME block term state NAME state PARAMETER boolean absolute TYPE boolean NAME boolean NAME absolute THROWS throws io exception ARGUMENT EXPR io exception NAME io exception BLOCK DECL STMT TYPE id version term state NAME id version term state NAME state INIT id version term state state EXPR id version term state state NAME id version term state NAME state EXPR out write v int state doc id CALL out write v int state doc id NAME out write v int NAME out NAME write v int ARGUMENT LIST ARGUMENT EXPR state doc id NAME state doc id NAME state NAME doc id IF if absolute out write v long state id version else long delta state id version last encoded version out write z long delta CONDITION absolute EXPR absolute NAME absolute THEN out write v long state id version BLOCK EXPR out write v long state id version CALL out write v long state id version NAME out write v long NAME out NAME write v long ARGUMENT LIST ARGUMENT EXPR state id version NAME state id version NAME state NAME id version ELSE else long delta state id version last encoded version out write z long delta BLOCK DECL STMT TYPE long NAME long NAME delta INIT state id version last encoded version EXPR state id version last encoded version NAME state id version NAME state NAME id version NAME last encoded version EXPR out write z long delta CALL out write z long delta NAME out write z long NAME out NAME write z long ARGUMENT LIST ARGUMENT EXPR delta NAME delta EXPR last encoded version state id version NAME last encoded version NAME state id version NAME state NAME id version public NN void NN encode VBP term NN root ROOT encode dobj encode term long RB longs NNS data NNS output NN root ROOT output compound output data out IN field NN info NN root ROOT info compound info field field NN info NN root ROOT info compound info field block NN term NN state NN root ROOT state compound state block compound state term state NN boolean NN absolute JJ throws VBZ io NN exception NN root ROOT exception compound exception io id NN version NN term NN state NN root ROOT state compound state id compound state version compound state term state NN id NN version NN term NN state NN root ROOT state compound state id compound state version compound state term state NN out IN write VB v LS int NN root ROOT write mark write out dobj write v root v int state NN doc NN id NN root ROOT id compound id state compound id doc if IN absolute JJ out IN write VB v LS long RB root ROOT write mark write out dobj write v advmod v long state NN id VBD version NN root ROOT id nsubj id state dobj id version else RB long RB delta NN state NN id VBD version NN root ROOT id nsubj id state dobj id version last JJ encoded VBN version NN root ROOT version amod version last amod version encoded out IN write VB z SYM long RB root ROOT write mark write out dep long z advmod write long delta NN last JJ encoded VBN version NN root ROOT version amod version last amod version encoded state NN id VBD version NN root ROOT id nsubj id state dobj id version
FUNCTION SPECIFIER public TYPE boolean NAME boolean NAME has freqs PARAMETER LIST BLOCK RETURN return field info get index options compare to index options docs and freqs EXPR field info get index options compare to index options docs and freqs CALL field info get index options NAME field info get index options NAME field info NAME get index options ARGUMENT LIST CALL compare to index options docs and freqs NAME compare to ARGUMENT LIST ARGUMENT EXPR index options docs and freqs NAME index options docs and freqs NAME index options NAME docs and freqs public NN boolean NN has VBZ freqs NNS root ROOT has dobj has freqs return NN field NN info NN get VB index NN options NNS root ROOT get compound info field nsubj get info compound options index dobj get options compare VB to TO root ROOT compare dep compare to index NN options NNS docs NNS root ROOT docs compound docs index compound docs options and CC freqs NNS root ROOT freqs cc freqs and
FUNCTION ANNOTATION override NAME override SPECIFIER public TYPE boolean NAME boolean NAME has offsets PARAMETER LIST BLOCK RETURN return field info get index options compare to index options docs and freqs and positions and offsets EXPR field info get index options compare to index options docs and freqs and positions and offsets CALL field info get index options NAME field info get index options NAME field info NAME get index options ARGUMENT LIST CALL compare to index options docs and freqs and positions and offsets NAME compare to ARGUMENT LIST ARGUMENT EXPR index options docs and freqs and positions and offsets NAME index options docs and freqs and positions and offsets NAME index options NAME docs and freqs and positions and offsets override NN public NN boolean NN has VBZ offsets NNS root ROOT has dobj has offsets return NN field NN info NN get VB index NN options NNS root ROOT get compound info field nsubj get info compound options index dobj get options compare VB to TO root ROOT compare dep compare to index NN options NNS docs NNS root ROOT docs compound docs index compound docs options and CC freqs NNS and CC positions NNS and CC offsets NNS root ROOT and dep and freqs cc freqs and dep and positions conj and freqs positions cc freqs and dep and offsets conj and freqs offsets
FUNCTION ANNOTATION override NAME override SPECIFIER public TYPE boolean NAME boolean NAME has positions PARAMETER LIST BLOCK RETURN return field info get index options compare to index options docs and freqs and positions EXPR field info get index options compare to index options docs and freqs and positions CALL field info get index options NAME field info get index options NAME field info NAME get index options ARGUMENT LIST CALL compare to index options docs and freqs and positions NAME compare to ARGUMENT LIST ARGUMENT EXPR index options docs and freqs and positions NAME index options docs and freqs and positions NAME index options NAME docs and freqs and positions override NN public NN boolean NN has VBZ positions NNS root ROOT has dobj has positions return NN field NN info NN get VB index NN options NNS root ROOT get compound info field nsubj get info compound options index dobj get options compare VB to TO root ROOT compare dep compare to index NN options NNS docs NNS root ROOT docs compound docs index compound docs options and CC freqs NNS and CC positions NNS root ROOT and dep and freqs cc freqs and dep and positions conj and freqs positions
FUNCTION ANNOTATION override NAME override SPECIFIER public TYPE boolean NAME boolean NAME has payloads PARAMETER LIST BLOCK RETURN return field info has payloads EXPR field info has payloads CALL field info has payloads NAME field info has payloads NAME field info NAME has payloads ARGUMENT LIST override NN public NN boolean NN has VBZ payloads NNS root ROOT has dobj has payloads return NN field NN info NN has VBZ payloads NNS root ROOT has compound info field nsubj has info dobj has payloads
FUNCTION SPECIFIER public TYPE long NAME long NAME get sum total term freq PARAMETER LIST BLOCK RETURN return sum total term freq EXPR sum total term freq NAME sum total term freq public NN long RB get VB sum NN total JJ term NN freq NN root ROOT get compound freq sum amod freq total compound freq term dobj get freq return NN sum NN total JJ term NN freq NN root ROOT freq compound freq sum amod freq total compound freq term
FUNCTION SPECIFIER public TYPE long NAME long NAME get sum doc freq PARAMETER LIST BLOCK RETURN return sum doc freq EXPR sum doc freq NAME sum doc freq public NN long RB get VB sum NN doc NN freq NN root ROOT get compound freq sum compound freq doc dobj get freq return NN sum NN doc NN freq NN root ROOT freq compound freq sum compound freq doc
FUNCTION SPECIFIER public TYPE int NAME int NAME get doc count PARAMETER LIST BLOCK RETURN return doc count EXPR doc count NAME doc count public NN int NN get VB doc NN count NN root ROOT get compound count doc dobj get count return NN doc NN count NN root ROOT count compound count doc
FUNCTION SPECIFIER public TYPE long NAME long NAME ram bytes used PARAMETER LIST BLOCK RETURN return index null index ram bytes used EXPR index null index ram bytes used TERNARY index null index ram bytes used CONDITION index null EXPR index null NAME index THEN index ram bytes used EXPR index ram bytes used CALL index ram bytes used NAME index ram bytes used NAME index NAME ram bytes used ARGUMENT LIST ELSE EXPR public NN long RB ram NN bytes NNS used VBN root ROOT used compound bytes ram nsubj used bytes return NN index NN null JJ index NN ram NN bytes NNS used VBN root ROOT used compound bytes index compound bytes ram nsubj used bytes
FUNCTION ANNOTATION override NAME override SPECIFIER public TYPE boolean NAME boolean NAME is new fragment PARAMETER LIST BLOCK DECL STMT TYPE boolean NAME boolean NAME is new frag INIT offset att end offset fragment size current num frags EXPR offset att end offset fragment size current num frags CALL offset att end offset NAME offset att end offset NAME offset att NAME end offset ARGUMENT LIST NAME fragment size NAME current num frags IF if is new frag current num frags CONDITION is new frag EXPR is new frag NAME is new frag THEN current num frags BLOCK EXPR current num frags NAME current num frags RETURN return is new frag EXPR is new frag NAME is new frag override NN public NN boolean NN is VBZ new JJ fragment NN root ROOT fragment cop fragment is amod fragment new boolean NN is VBZ new JJ frag NN root ROOT frag cop frag is amod frag new offset VBN att NN end NN offset VBP root ROOT offset amod end offset compound end att nsubj offset end fragment NN size NN root ROOT size compound size fragment current JJ num NN frags NNS root ROOT frags amod frags current compound frags num if IN is VBZ new JJ frag NN root ROOT frag cop frag is amod frag new current JJ num NN frags NNS root ROOT frags amod frags current compound frags num return NN is VBZ new JJ frag NN root ROOT frag cop frag is amod frag new
DECL STMT TYPE int NAME int NAME frag num int NN frag NN num NN root ROOT num compound num frag
FUNCTION TYPE void NAME void NAME set score PARAMETER LIST float score PARAMETER float score TYPE float NAME float NAME score BLOCK EXPR this score score NAME this score NAME this NAME score NAME score void NN set VBN score NN root ROOT set dobj set score float NN score NN this DT score NN score NN
FUNCTION SPECIFIER public TYPE float NAME float NAME get score PARAMETER LIST BLOCK RETURN return score EXPR score NAME score public NN float NN get VB score NN root ROOT get dobj get score return NN score NN
COMMENT param frag fragment to be merged into this one FUNCTION SPECIFIER public TYPE void NAME void NAME merge PARAMETER LIST text fragment frag PARAMETER text fragment frag TYPE text fragment NAME text fragment NAME frag BLOCK EXPR text end pos frag text end pos NAME text end pos NAME frag text end pos NAME frag NAME text end pos EXPR score math max score frag score NAME score CALL math max score frag score NAME math max NAME math NAME max ARGUMENT LIST ARGUMENT EXPR score NAME score ARGUMENT EXPR frag score NAME frag score NAME frag NAME score param frag fragment to be merged into this one root ROOT fragment compound fragment param compound fragment frag mark merged to auxpass merged be acl to fragment merged case one into det one this nmod into merged one public NN void NN merge VB text NN fragment NN root ROOT fragment compound fragment text frag NN text NN end NN pos NNS root ROOT pos compound pos text compound pos end frag NN text NN end NN pos NNS root ROOT pos compound pos frag compound pos text compound pos end score NN math NN max NN root ROOT max compound max math score NN frag NN score NN root ROOT score compound score frag merged one SYNONYM SYNONYM
COMMENT return the fragment sequence number FUNCTION SPECIFIER public TYPE int NAME int NAME get frag num PARAMETER LIST BLOCK RETURN return frag num EXPR frag num NAME frag num return the fragment sequence number root ROOT return det number the compound number fragment compound number sequence dobj return number public NN int NN get VB frag NN num NN root ROOT get compound num frag dobj get num return NN frag NN num NN root ROOT num compound num frag return number ANTONYM ANTONYM
DECL STMT SPECIFIER private TYPE list position span NAME list position span NAME list ARGUMENT LIST ARGUMENT NAME position span NAME position spans INIT new array list EXPR new array list CALL array list NAME array list NAME array list ARGUMENT LIST ARGUMENT LIST private JJ list NN position NN span NN root ROOT span compound span position position NN spans NNS root ROOT spans compound spans position new JJ array NN list NN root ROOT list compound list array
CONSTRUCTOR public weighted span term float weight string term boolean position sensitive super weight term this position sensitive position sensitive SPECIFIER public NAME weighted span term PARAMETER LIST float weight string term boolean position sensitive PARAMETER float weight TYPE float NAME float NAME weight PARAMETER string term TYPE string NAME string NAME term PARAMETER boolean position sensitive TYPE boolean NAME boolean NAME position sensitive BLOCK EXPR super weight term CALL super weight term NAME super ARGUMENT LIST ARGUMENT EXPR weight NAME weight ARGUMENT EXPR term NAME term EXPR this position sensitive position sensitive NAME this position sensitive NAME this NAME position sensitive NAME position sensitive public NN weighted JJ span NN term NN root ROOT term amod term weighted compound term span float NN weight NN string NN term NN boolean NN position NN sensitive JJ root ROOT sensitive nmod npmod sensitive position super JJ weight NN term NN this DT position NN sensitive JJ position NN sensitive JJ root ROOT sensitive nmod npmod sensitive position
COMMENT checks to see if this term is valid at code position code param position to check against valid term positions return true iff this term is a hit at this position FUNCTION SPECIFIER public TYPE boolean NAME boolean NAME check position PARAMETER LIST int position PARAMETER int position TYPE int NAME int NAME position BLOCK COMMENT there would probably be a slight speed improvement if position spans COMMENT where kept in some sort of priority queue that way this method COMMENT could COMMENT bail early without checking each position span DECL STMT TYPE iterator position span NAME iterator position span NAME iterator ARGUMENT LIST ARGUMENT NAME position span NAME position span it INIT position spans iterator EXPR position spans iterator CALL position spans iterator NAME position spans iterator NAME position spans NAME iterator ARGUMENT LIST WHILE while position span it has next position span pos span position span it next if position pos span start position pos span end return true CONDITION position span it has next EXPR position span it has next CALL position span it has next NAME position span it has next NAME position span it NAME has next ARGUMENT LIST BLOCK DECL STMT TYPE position span NAME position span NAME pos span INIT position span it next EXPR position span it next CALL position span it next NAME position span it next NAME position span it NAME next ARGUMENT LIST IF if position pos span start position pos span end return true CONDITION position pos span start position pos span end EXPR position pos span start position pos span end NAME position NAME pos span start NAME pos span NAME start NAME position NAME pos span end NAME pos span NAME end THEN return true BLOCK RETURN return true EXPR true RETURN return false EXPR false checks to see if this term is valid at code position code root ROOT checks mark see to acl to checks see mark valid if det term this nsubj valid term cop valid is advcl if see valid case code at compound code code compound code position nmod at valid code param position root ROOT position compound position param to check against valid term positions root ROOT check mark check to case positions against amod positions valid compound positions term nmod against check positions return true iff this term is a hit at this position root ROOT hit compound term return amod term true advmod term iff det term this nsubj hit term cop hit is det hit a case position at det position this nmod at hit position public NN boolean NN check NN position NN root ROOT position compound position check int NN position NN there would probably be a slight speed improvement if position spans root ROOT improvement nsubj improvement there aux improvement would advmod improvement probably cop improvement be det improvement a amod improvement slight compound improvement speed case spans if compound spans position nmod if improvement spans where kept in some sort of priority queue that way this method root ROOT kept advmod kept where case sort in det sort some nmod in kept sort case queue of compound queue priority nmod of sort queue det way that dep kept way det method this dep way method could bail early without checking each position span root ROOT bail advmod checking early mark checking without acl without bail checking det position each nsubj span position ccomp checking span iterator NN position NN span NN root ROOT span compound span position position NN span NN it PRP root ROOT span compound span position dep span it position NN spans VBZ iterator NN root ROOT spans nsubj spans position dobj spans iterator while IN position NN span NN it PRP has VBZ next JJ root ROOT span compound span position nsubj has it acl relcl span has advmod has next position NN span NN root ROOT span compound span position pos NNS span VBP root ROOT span nsubj span pos position NN span NN it PRP next IN root ROOT span compound span position dep span it det it next if IN position NN pos NNS span VBP start NN root ROOT span nsubj span pos dobj span start position NN pos NNS span VBP end NN root ROOT span nsubj span pos dobj span end return NN true JJ return NN false JJ check end ANTONYM ANTONYM check hit ANTONYM ANTONYM check kept ANTONYM ANTONYM check return ANTONYM ANTONYM checking end ANTONYM ANTONYM checks end ANTONYM ANTONYM checks hit ANTONYM ANTONYM checks kept ANTONYM ANTONYM checks return ANTONYM ANTONYM hit checking ANTONYM ANTONYM kept checking ANTONYM ANTONYM return checking ANTONYM ANTONYM see hit ANTONYM ANTONYM some each ANTONYM ANTONYM speed check ANTONYM ANTONYM speed checking ANTONYM ANTONYM speed checks ANTONYM ANTONYM start check ANTONYM ANTONYM start checking ANTONYM ANTONYM start checks ANTONYM ANTONYM start end ANTONYM ANTONYM start end ANTONYM ANTONYM true false ANTONYM ANTONYM valid false ANTONYM ANTONYM in next SYNONYM SYNONYM
FUNCTION SPECIFIER public TYPE boolean NAME boolean NAME is position sensitive PARAMETER LIST BLOCK RETURN return position sensitive EXPR position sensitive NAME position sensitive public NN boolean NN is VBZ position NN sensitive JJ root ROOT sensitive cop sensitive is nmod npmod sensitive position return NN position NN sensitive JJ root ROOT sensitive nmod npmod sensitive position
FUNCTION SPECIFIER public TYPE void NAME void NAME set position sensitive PARAMETER LIST boolean position sensitive PARAMETER boolean position sensitive TYPE boolean NAME boolean NAME position sensitive BLOCK EXPR this position sensitive position sensitive NAME this position sensitive NAME this NAME position sensitive NAME position sensitive public NN void NN set VBN position NN sensitive JJ root ROOT set nmod npmod sensitive position xcomp set sensitive boolean NN position NN sensitive JJ root ROOT sensitive nmod npmod sensitive position this DT position NN sensitive JJ position NN sensitive JJ root ROOT sensitive nmod npmod sensitive position
FUNCTION SPECIFIER public TYPE list position span NAME list position span NAME list ARGUMENT LIST ARGUMENT NAME position span NAME get position spans PARAMETER LIST BLOCK RETURN return position spans EXPR position spans NAME position spans public NN list NN position NN span NN root ROOT span compound span position get VB position NN spans NNS root ROOT get compound spans position dobj get spans return NN position NN spans NNS root ROOT spans compound spans position
COMMENT returns the total number of tokens for this field see terms get sum total term freq FUNCTION SPECIFIER public SPECIFIER final TYPE long NAME long NAME sum total term freq PARAMETER LIST BLOCK RETURN return sum total term freq EXPR sum total term freq NAME sum total term freq returns the total number of tokens for this field root ROOT returns det number the amod number total dobj returns number case tokens of nmod of number tokens case field for det field this nmod for number field see terms get sum total term freq root ROOT see nsubj get terms ccomp see get compound freq sum amod freq total compound freq term dobj get freq public NN final JJ long RB sum NN total JJ term NN freq NN root ROOT freq compound freq sum amod freq total compound freq term return NN sum NN total JJ term NN freq NN root ROOT freq compound freq sum amod freq total compound freq term number return ANTONYM ANTONYM returns number ANTONYM ANTONYM total final ANTONYM ANTONYM
COMMENT returns the total number of postings for this field see terms get sum doc freq FUNCTION SPECIFIER public SPECIFIER final TYPE long NAME long NAME sum doc freq PARAMETER LIST BLOCK RETURN return sum doc freq EXPR sum doc freq NAME sum doc freq returns the total number of postings for this field root ROOT returns det number the amod number total dobj returns number case postings of nmod of number postings case field for det field this nmod for number field see terms get sum doc freq root ROOT see nsubj get terms ccomp see get compound freq sum compound freq doc dobj get freq public NN final JJ long RB sum NN doc NN freq NN root ROOT freq compound freq sum compound freq doc return NN sum NN doc NN freq NN root ROOT freq compound freq sum compound freq doc number return ANTONYM ANTONYM returns number ANTONYM ANTONYM total final ANTONYM ANTONYM
DECL STMT SPECIFIER private TYPE final disi priority queue SPECIFIER final NAME disi priority queue NAME sub scorers private JJ final JJ disi NN priority NN queue NN root ROOT queue compound queue disi compound queue priority sub NN scorers NNS root ROOT scorers compound scorers sub
FUNCTION SPECIFIER public TYPE int NAME int NAME compare bottom PARAMETER LIST int doc PARAMETER int doc TYPE int NAME int NAME doc THROWS throws io exception ARGUMENT EXPR io exception NAME io exception BLOCK RETURN return integer compare bottom get value for doc doc EXPR integer compare bottom get value for doc doc CALL integer compare bottom get value for doc doc NAME integer compare NAME integer NAME compare ARGUMENT LIST ARGUMENT EXPR bottom NAME bottom ARGUMENT EXPR get value for doc doc CALL get value for doc doc NAME get value for doc ARGUMENT LIST ARGUMENT EXPR doc NAME doc public NN int NN compare VB bottom NN root ROOT compare dobj compare bottom int NN doc NN throws VBZ io NN exception NN root ROOT exception compound exception io return NN integer NN compare VB root ROOT compare nsubj compare integer bottom NN get VB value NN for IN doc NN root ROOT get dobj get value case doc for nmod for get doc doc NN throws return ANTONYM ANTONYM
FUNCTION SPECIFIER public TYPE void NAME void NAME set bottom PARAMETER LIST final int bottom PARAMETER final int bottom TYPE final int SPECIFIER final NAME int NAME bottom BLOCK EXPR this bottom values bottom NAME this bottom NAME this NAME bottom NAME values bottom NAME values INDEX bottom EXPR bottom NAME bottom public NN void NN set VBN bottom NN root ROOT set dobj set bottom final JJ int NN bottom NN this DT bottom NN values NNS bottom NN
COMMENT returns the pattern term FUNCTION SPECIFIER public TYPE term NAME term NAME get term PARAMETER LIST BLOCK RETURN return term EXPR term NAME term returns the pattern term root ROOT returns det term the compound term pattern dobj returns term public NN term NN get VB term NN root ROOT get dobj get term return NN term NN
FUNCTION SPECIFIER public TYPE mutable value NAME mutable value NAME duplicate PARAMETER LIST BLOCK DECL STMT TYPE mutable value int NAME mutable value int NAME v INIT new mutable value int EXPR new mutable value int CALL mutable value int NAME mutable value int ARGUMENT LIST EXPR v value this value NAME v value NAME v NAME value NAME this value NAME this NAME value EXPR v exists this exists NAME v exists NAME v NAME exists NAME this exists NAME this NAME exists RETURN return v EXPR v NAME v public NN mutable JJ value NN root ROOT value amod value mutable duplicate VB mutable JJ value NN int NN root ROOT int amod int mutable compound int value v LS new JJ mutable JJ value NN int NN root ROOT int amod int mutable compound int value v LS value NN root ROOT value amod value v this DT value NN v LS exists VBZ root ROOT exists nsubj exists v this DT exists VBZ return NN v LS
COMMENT convert to degrees param radians radians to convert to degrees return degrees FUNCTION SPECIFIER public SPECIFIER static TYPE double NAME double NAME to degrees PARAMETER LIST final double radians PARAMETER final double radians TYPE final double SPECIFIER final NAME double NAME radians BLOCK RETURN return radians to degrees EXPR radians to degrees NAME radians NAME to degrees convert to degrees root ROOT convert case degrees to nmod to convert degrees param radians radians to convert to degrees root ROOT radians compound radians param compound radians radians mark convert to acl to radians convert case degrees to nmod to convert degrees return degrees root ROOT degrees compound degrees return public NN static JJ double RB to TO degrees NNS root ROOT degrees case degrees to final JJ double RB radians NNS return NN radians NNS to TO degrees NNS root ROOT degrees case degrees to
COMMENT this method returns the internal heap array as object lucene internal FUNCTION SPECIFIER protected SPECIFIER final TYPE object NAME object NAME object INDEX NAME get heap array PARAMETER LIST BLOCK RETURN return object heap EXPR object heap NAME object NAME object INDEX NAME heap this method returns the internal heap array as object root ROOT returns det method this nsubj returns method det array the amod array internal compound array heap dobj returns array case object as nmod as returns object lucene internal root ROOT internal nmod npmod internal lucene lucene internal root ROOT internal nmod npmod internal lucene protected VBN final JJ object NN get VB heap NN array NN root ROOT get compound array heap dobj get array return NN object NN heap NN
FUNCTION SPECIFIER public TYPE void NAME void NAME set max PARAMETER LIST int limit PARAMETER int limit TYPE int NAME int NAME limit BLOCK EXPR max limit NAME max NAME limit public NN void NN set VBN max NN root ROOT set dobj set max int NN limit NN max NN limit NN
DECL STMT SPECIFIER public SPECIFIER static TYPE final storage level SPECIFIER final NAME storage level NAME none INIT create false false false false EXPR create false false false false CALL create false false false false NAME create ARGUMENT LIST ARGUMENT EXPR false ARGUMENT EXPR false ARGUMENT EXPR false ARGUMENT EXPR false ARGUMENT EXPR public NN static JJ final JJ storage NN level NN root ROOT level compound level storage none NN create VB false JJ false JJ false JJ false JJ
DECL STMT SPECIFIER public SPECIFIER static TYPE final storage level SPECIFIER final NAME storage level NAME memory only INIT create false true false true EXPR create false true false true CALL create false true false true NAME create ARGUMENT LIST ARGUMENT EXPR false ARGUMENT EXPR true ARGUMENT EXPR false ARGUMENT EXPR true ARGUMENT EXPR public NN static JJ final JJ storage NN level NN root ROOT level compound level storage memory NN only RB root ROOT memory advmod memory only create VB false JJ true JJ false JJ true JJ false true ANTONYM ANTONYM
FUNCTION SPECIFIER public SPECIFIER static TYPE storage level NAME storage level NAME create PARAMETER LIST boolean use disk boolean use memory boolean use off heap boolean deserialized int replication PARAMETER boolean use disk TYPE boolean NAME boolean NAME use disk PARAMETER boolean use memory TYPE boolean NAME boolean NAME use memory PARAMETER boolean use off heap TYPE boolean NAME boolean NAME use off heap PARAMETER boolean deserialized TYPE boolean NAME boolean NAME deserialized PARAMETER int replication TYPE int NAME int NAME replication BLOCK RETURN return storage level apply use disk use memory use off heap deserialized replication EXPR storage level apply use disk use memory use off heap deserialized replication CALL storage level apply use disk use memory use off heap deserialized replication NAME storage level apply NAME storage level NAME apply ARGUMENT LIST ARGUMENT EXPR use disk NAME use disk ARGUMENT EXPR use memory NAME use memory ARGUMENT EXPR use off heap NAME use off heap ARGUMENT EXPR deserialized NAME deserialized ARGUMENT EXPR replication NAME replication public NN static JJ storage NN level NN root ROOT level compound level storage create VB boolean NN use NN disk NN root ROOT disk compound disk use boolean NN use NN memory NN root ROOT memory compound memory use boolean NN use VB off RP heap NN root ROOT use compound prt use off dobj use heap boolean NN deserialized VBN int NN replication NN return NN storage NN level NN apply VB root ROOT apply compound level storage nsubj apply level use NN disk NN root ROOT disk compound disk use use NN memory NN root ROOT memory compound memory use use VB off RP heap NN root ROOT use compound prt use off dobj use heap deserialized VBN replication NN return apply ANTONYM ANTONYM
FUNCTION SPECIFIER public TYPE int NAME int NAME compare PARAMETER LIST long b long a PARAMETER long b TYPE long NAME long NAME b PARAMETER long a TYPE long NAME long NAME a BLOCK RETURN return a b a b EXPR a b a b TERNARY a b a b CONDITION a b EXPR a b NAME a NAME b THEN EXPR ELSE a b EXPR a b TERNARY a b CONDITION a b EXPR a b NAME a NAME b THEN EXPR ELSE EXPR public NN int NN compare VB long RB b NN long RB a DT return NN a DT b NN a DT b NN
FUNCTION SPECIFIER public TYPE int NAME int NAME compare PARAMETER LIST long a prefix long b prefix PARAMETER long a prefix TYPE long NAME long NAME a prefix PARAMETER long b prefix TYPE long NAME long NAME b prefix BLOCK RETURN return unsigned longs compare a prefix b prefix EXPR unsigned longs compare a prefix b prefix CALL unsigned longs compare a prefix b prefix NAME unsigned longs compare NAME unsigned longs NAME compare ARGUMENT LIST ARGUMENT EXPR a prefix NAME a prefix ARGUMENT EXPR b prefix NAME b prefix public NN int NN compare VB long RB a DT prefix NN root ROOT prefix det prefix a long RB b NN prefix NN root ROOT prefix compound prefix b return NN unsigned JJ longs NNS compare VBP root ROOT compare amod longs unsigned nsubj compare longs a DT prefix NN root ROOT prefix det prefix a b NN prefix NN root ROOT prefix compound prefix b
DECL STMT SPECIFIER private TYPE final long SPECIFIER final NAME long NAME num elements for spill threshold private JJ final JJ long RB num NN elements NNS for IN spill NN threshold NN root ROOT elements compound elements num case threshold for compound threshold spill nmod for elements threshold
DECL STMT SPECIFIER private TYPE final linked list memory block SPECIFIER final NAME linked list memory block NAME linked list ARGUMENT LIST ARGUMENT NAME memory block NAME allocated pages INIT new linked list EXPR new linked list CALL linked list NAME linked list NAME linked list ARGUMENT LIST ARGUMENT LIST private JJ final JJ linked VBN list NN root ROOT list amod list linked memory NN block NN root ROOT block compound block memory allocated VBN pages NNS root ROOT pages amod pages allocated new JJ linked VBN list NN root ROOT list amod list linked
DECL STMT SPECIFIER private TYPE final linked list unsafe sorter spill writer SPECIFIER final NAME linked list unsafe sorter spill writer NAME linked list ARGUMENT LIST ARGUMENT NAME unsafe sorter spill writer NAME spill writers INIT new linked list EXPR new linked list CALL linked list NAME linked list NAME linked list ARGUMENT LIST ARGUMENT LIST private JJ final JJ linked VBN list NN root ROOT list amod list linked unsafe JJ sorter NN spill NN writer NN root ROOT writer amod writer unsafe compound writer sorter compound writer spill spill NN writers NNS root ROOT writers compound writers spill new JJ linked VBN list NN root ROOT list amod list linked
COMMENT return the total number of bytes that has been spilled into disk so far FUNCTION SPECIFIER public TYPE long NAME long NAME get spill size PARAMETER LIST BLOCK RETURN return total spill bytes EXPR total spill bytes NAME total spill bytes return the total number of bytes that has been spilled into disk so far root ROOT return det number the amod number total dobj return number case bytes of nmod of number bytes nsubjpass spilled bytes ref bytes that aux spilled has auxpass spilled been acl relcl bytes spilled case disk into nmod into spilled disk advmod far so advmod spilled far public NN long RB get VB spill NN size NN root ROOT get compound size spill dobj get size return NN total JJ spill NN bytes NNS root ROOT bytes amod bytes total compound bytes spill return has ANTONYM ANTONYM return number ANTONYM ANTONYM
COMMENT free this sorter s data pages return the number of bytes freed FUNCTION SPECIFIER private TYPE long NAME long NAME free memory PARAMETER LIST BLOCK EXPR update peak memory used CALL update peak memory used NAME update peak memory used ARGUMENT LIST DECL STMT TYPE long NAME long NAME memory freed INIT EXPR FOR for memory block block allocated pages memory freed block size free page block CONTROL memory block block allocated pages INIT memory block block allocated pages TYPE memory block NAME memory block NAME block RANGE allocated pages EXPR allocated pages NAME allocated pages BLOCK EXPR memory freed block size NAME memory freed CALL block size NAME block size NAME block NAME size ARGUMENT LIST EXPR free page block CALL free page block NAME free page ARGUMENT LIST ARGUMENT EXPR block NAME block EXPR allocated pages clear CALL allocated pages clear NAME allocated pages clear NAME allocated pages NAME clear ARGUMENT LIST EXPR current page null NAME current page EXPR page cursor NAME page cursor RETURN return memory freed EXPR memory freed NAME memory freed free this sorter s data pages root ROOT pages amod pages free det sorter this compound pages sorter compound pages s compound pages data return the number of bytes freed root ROOT return det number the dobj return number case bytes of nmod of number bytes acl number freed private JJ long RB free JJ memory NN root ROOT memory amod memory free update VB peak NN memory NN used VBN root ROOT update compound memory peak dobj update memory acl memory used long RB memory NN freed VBN root ROOT freed nsubj freed memory for IN memory NN block NN root ROOT block compound block memory block NN allocated VBN pages NNS root ROOT pages amod pages allocated memory NN freed VBN root ROOT freed nsubj freed memory block NN size NN root ROOT size compound size block free JJ page NN root ROOT page amod page free block NN allocated VBN pages NNS clear JJ root ROOT clear amod pages allocated nsubj clear pages current JJ page NN root ROOT page amod page current null JJ page NN cursor NN root ROOT cursor compound cursor page return NN memory NN freed VBN root ROOT freed nsubj freed memory block return ANTONYM ANTONYM free block ANTONYM ANTONYM free clear ANTONYM ANTONYM freed block ANTONYM ANTONYM freed clear ANTONYM ANTONYM private clear ANTONYM ANTONYM return clear ANTONYM ANTONYM return number ANTONYM ANTONYM freed clear SYNONYM SYNONYM
FUNCTION SPECIFIER public TYPE int NAME int NAME get num records PARAMETER LIST BLOCK RETURN return num records EXPR num records NAME num records public NN int NN get VB num NN records NNS root ROOT get compound records num dobj get records return NN num NN records NNS root ROOT records compound records num
FUNCTION SPECIFIER public TYPE boolean NAME boolean NAME has next PARAMETER LIST BLOCK RETURN return num records EXPR num records NAME num records public NN boolean NN has VBZ next JJ root ROOT has advmod has next return NN num NN records NNS root ROOT records compound records num
FUNCTION SPECIFIER public TYPE int NAME int NAME get record length PARAMETER LIST BLOCK RETURN return current get record length EXPR current get record length CALL current get record length NAME current get record length NAME current NAME get record length ARGUMENT LIST public NN int NN get VB record NN length NN root ROOT get compound length record dobj get length return NN current JJ get VB record NN length NN root ROOT current dep current get compound length record dobj get length
DECL STMT SPECIFIER private TYPE final prefix comparator SPECIFIER final NAME prefix comparator NAME prefix comparator private JJ final JJ prefix NN comparator NN root ROOT comparator compound comparator prefix prefix NN comparator NN root ROOT comparator compound comparator prefix
COMMENT marks the current page as no more space available and as a result either allocate a new page or spill when we see the next record FUNCTION ANNOTATION visible for testing NAME visible for testing SPECIFIER public TYPE void NAME void NAME close current page PARAMETER LIST BLOCK IF if current page null page cursor current page get base offset current page size CONDITION current page null EXPR current page null NAME current page THEN page cursor current page get base offset current page size BLOCK EXPR page cursor current page get base offset current page size NAME page cursor CALL current page get base offset NAME current page get base offset NAME current page NAME get base offset ARGUMENT LIST CALL current page size NAME current page size NAME current page NAME size ARGUMENT LIST marks the current page as no more space available and as a result either allocate a root ROOT marks det page the amod page current dobj marks page case space as neg space no amod space more nmod as marks space amod space available cc marks and case result as det result a conj and marks result cc preconj allocate either acl result allocate dobj allocate a new page or spill when we see the next record root ROOT page amod page new cc page or conj or page spill advmod see when nsubj see we acl relcl page see det record the amod record next dobj see record visible JJ for IN testing NN root ROOT visible case testing for nmod for visible testing public NN void NN close RB current JJ page NN root ROOT page amod page close amod page current if IN current JJ page NN root ROOT page amod page current null JJ page NN cursor NN root ROOT cursor compound cursor page current JJ page NN get VB base JJ offset VBN root ROOT page amod page current acl page get xcomp get base dep base offset current JJ page NN size NN root ROOT size amod size current compound size page marks record ANTONYM ANTONYM marks see ANTONYM ANTONYM
FUNCTION SPECIFIER private TYPE void NAME void NAME update peak memory used PARAMETER LIST BLOCK DECL STMT TYPE long NAME long NAME mem INIT get memory usage EXPR get memory usage CALL get memory usage NAME get memory usage ARGUMENT LIST IF if mem peak memory used bytes peak memory used bytes mem CONDITION mem peak memory used bytes EXPR mem peak memory used bytes NAME mem NAME peak memory used bytes THEN peak memory used bytes mem BLOCK EXPR peak memory used bytes mem NAME peak memory used bytes NAME mem private JJ void NN update VB peak NN memory NN used VBN root ROOT update compound memory peak dobj update memory acl memory used long RB mem NN get VB memory NN usage NN root ROOT get compound usage memory dobj get usage if IN mem NN peak JJ memory NN used VBN bytes NNS root ROOT used amod memory peak nsubj used memory dobj used bytes peak JJ memory NN used VBN bytes NNS root ROOT used amod memory peak nsubj used memory dobj used bytes mem NN
FUNCTION SPECIFIER public TYPE void NAME void NAME write PARAMETER LIST byte b int off int len PARAMETER byte b TYPE byte NAME byte NAME byte INDEX NAME b PARAMETER int off TYPE int NAME int NAME off PARAMETER int len TYPE int NAME int NAME len THROWS throws io exception ARGUMENT EXPR io exception NAME io exception BLOCK DECL STMT TYPE final long SPECIFIER final NAME long NAME start time INIT system nano time EXPR system nano time CALL system nano time NAME system nano time NAME system NAME nano time ARGUMENT LIST EXPR output stream write b off len CALL output stream write b off len NAME output stream write NAME output stream NAME write ARGUMENT LIST ARGUMENT EXPR b NAME b ARGUMENT EXPR off NAME off ARGUMENT EXPR len NAME len EXPR write metrics inc write time system nano time start time CALL write metrics inc write time system nano time start time NAME write metrics inc write time NAME write metrics NAME inc write time ARGUMENT LIST ARGUMENT EXPR system nano time start time CALL system nano time NAME system nano time NAME system NAME nano time ARGUMENT LIST NAME start time public NN void NN write VB byte NN b NN int NN off IN int NN len NN throws VBZ io NN exception NN root ROOT exception compound exception io final JJ long RB start VB time NN root ROOT start dobj start time system NN nano JJ time NN root ROOT time compound time system amod time nano output NN stream NN write VB root ROOT write compound stream output nsubj write stream b NN off IN len NN write VB metrics NNS inc VB write VB time NN root ROOT write dobj write metrics acl metrics inc ccomp inc write dobj write time system NN nano JJ time NN root ROOT time compound time system amod time nano start VB time NN root ROOT start dobj start time
DECL STMT SPECIFIER private TYPE string NAME string NAME filename private JJ string NN filename NN
DECL STMT SPECIFIER private TYPE print stream NAME print stream NAME output stream private JJ print NN stream NN root ROOT stream compound stream print output NN stream NN root ROOT stream compound stream output
CONSTRUCTOR public file stream sink task print stream output stream filename null this output stream output stream SPECIFIER public NAME file stream sink task PARAMETER LIST print stream output stream PARAMETER print stream output stream TYPE print stream NAME print stream NAME output stream BLOCK EXPR filename null NAME filename EXPR this output stream output stream NAME this output stream NAME this NAME output stream NAME output stream public NN file NN stream NN sink NN task NN root ROOT task compound task file compound task stream compound task sink print NN stream NN root ROOT stream compound stream print output NN stream NN root ROOT stream compound stream output filename NN null JJ this DT output NN stream NN output NN stream NN root ROOT stream compound stream output
FUNCTION SPECIFIER public TYPE void NAME void NAME start PARAMETER LIST map string string props PARAMETER map string string props TYPE map string string NAME map string string NAME map ARGUMENT LIST ARGUMENT NAME string ARGUMENT NAME string NAME props BLOCK EXPR filename props get file config NAME filename CALL props get file config NAME props get NAME props NAME get ARGUMENT LIST ARGUMENT EXPR file config NAME file config public NN void NN start NN map NN string NN string NN props NNS filename NN props NNS get VBP root ROOT get nsubj get props file NN config NN root ROOT config compound config file string get ANTONYM ANTONYM
FUNCTION SPECIFIER private TYPE void NAME void NAME set timeout PARAMETER LIST BLOCK COMMENT set a reasonable minimum delay since this mock task may not actually consume any data from kafka it may only COMMENT see put calls triggered by wakeups for offset commits to make sure we aren t tied to the offset commit COMMENT interval we force a wakeup every ms or after the failure delay whichever is smaller this is not overly COMMENT aggressive but ensures any scheduled tasks this connector performs are reasonably close to the target time EXPR context timeout math min failure delay ms CALL context timeout math min failure delay ms NAME context timeout NAME context NAME timeout ARGUMENT LIST ARGUMENT EXPR math min failure delay ms CALL math min failure delay ms NAME math min NAME math NAME min ARGUMENT LIST ARGUMENT EXPR failure delay ms NAME failure delay ms ARGUMENT EXPR private JJ void NN set VBN timeout NN root ROOT set dobj set timeout set a reasonable minimum delay since this mock task may not actually consume any data from kafka it may only root ROOT set det delay a amod delay reasonable compound delay minimum dobj set delay mark consume since det task this amod task mock nsubj consume task aux consume may neg consume not advmod consume actually advcl since set consume det data any dobj consume data case kafka from nmod from only kafka nsubj only it aux only may dep data only set a reasonable minimum delay since this mock task may not actually consume any data from kafka it may only root ROOT set det delay a amod delay reasonable compound delay minimum dobj set delay mark consume since det task this amod task mock nsubj consume task aux consume may neg consume not advmod consume actually advcl since set consume det data any dobj consume data case kafka from nmod from only kafka nsubj only it aux only may dep data only see put calls triggered by wakeups for offset commits to make sure we aren t tied to the offset commit root ROOT commit csubj commit see amod calls put nsubj commits calls nsubj xsubj make calls acl calls triggered case wakeups by nmod by triggered wakeups case offset for nmod for wakeups offset ccomp see commits mark make to xcomp commits make xcomp make sure nsubj aren we ccomp sure aren dobj aren t acl t tied case offset to det offset the nmod to tied offset see put calls triggered by wakeups for offset commits to make sure we aren t tied to the offset commit root ROOT commit csubj commit see amod calls put nsubj commits calls nsubj xsubj make calls acl calls triggered case wakeups by nmod by triggered wakeups case offset for nmod for wakeups offset ccomp see commits mark make to xcomp commits make xcomp make sure nsubj aren we ccomp sure aren dobj aren t acl t tied case offset to det offset the nmod to tied offset interval we force a wakeup every ms or after the failure delay whichever is smaller this is not overly root ROOT interval nsubj force we acl relcl interval force det wakeup a dobj force wakeup det ms every dep wakeup ms cc ms or case delay after det delay the compound delay failure dep wakeup delay conj or ms delay nsubj smaller whichever cop smaller is acl relcl delay smaller nsubj overly this cop overly is neg overly not ccomp smaller overly interval we force a wakeup every ms or after the failure delay whichever is smaller this is not overly root ROOT interval nsubj force we acl relcl interval force det wakeup a dobj force wakeup det ms every dep wakeup ms cc ms or case delay after det delay the compound delay failure dep wakeup delay conj or ms delay nsubj smaller whichever cop smaller is acl relcl delay smaller nsubj overly this cop overly is neg overly not ccomp smaller overly aggressive but ensures any scheduled tasks this connector performs are reasonably close to the target time root ROOT time amod tasks aggressive cc aggressive but conj but aggressive ensures amod tasks ensures det tasks any amod tasks scheduled nsubj time tasks det connector this nsubj performs connector acl relcl tasks performs cop time are advmod time reasonably case time close mwe close to det time the compound time target context NN timeout NN root ROOT timeout compound timeout context math NN min NN root ROOT min compound min math failure NN delay NN ms NNS root ROOT ms compound ms failure compound ms delay calls make ANTONYM ANTONYM commit force ANTONYM ANTONYM commit target ANTONYM ANTONYM commits force ANTONYM ANTONYM commits make ANTONYM ANTONYM commits target ANTONYM ANTONYM consume make ANTONYM ANTONYM consume see ANTONYM ANTONYM delay ensures ANTONYM ANTONYM delay see ANTONYM ANTONYM make are ANTONYM ANTONYM make commit ANTONYM ANTONYM make force ANTONYM ANTONYM make is ANTONYM ANTONYM make performs ANTONYM ANTONYM make tied ANTONYM ANTONYM offset close ANTONYM ANTONYM put calls ANTONYM ANTONYM put target ANTONYM ANTONYM see calls ANTONYM ANTONYM see make ANTONYM ANTONYM set commit ANTONYM ANTONYM set commits ANTONYM ANTONYM set make ANTONYM ANTONYM set performs ANTONYM ANTONYM set see ANTONYM ANTONYM set target ANTONYM ANTONYM tied force ANTONYM ANTONYM triggered offset ANTONYM ANTONYM sure close SYNONYM SYNONYM tied close SYNONYM SYNONYM
FUNCTION SPECIFIER public TYPE void NAME void NAME stop PARAMETER LIST BLOCK EXPR delegate stop CALL delegate stop NAME delegate stop NAME delegate NAME stop ARGUMENT LIST public NN void NN stop VB delegate NN stop NN root ROOT stop compound stop delegate
DECL STMT SPECIFIER public SPECIFIER static TYPE final long SPECIFIER final NAME long NAME default failure delay ms INIT EXPR public NN static JJ final JJ long RB default NN failure NN delay NN ms NNS root ROOT ms compound ms default compound ms failure compound ms delay
DECL STMT SPECIFIER private SPECIFIER static TYPE final logger SPECIFIER final NAME logger NAME log INIT logger factory get logger mock connector class EXPR logger factory get logger mock connector class CALL logger factory get logger mock connector class NAME logger factory get logger NAME logger factory NAME get logger ARGUMENT LIST ARGUMENT EXPR mock connector class NAME mock connector class NAME mock connector NAME class private JJ static JJ final JJ logger NN log NN logger NN factory NN get VB logger NN root ROOT get compound factory logger nsubj get factory dobj get logger mock JJ connector NN class NN
DECL STMT TYPE final string SPECIFIER final NAME string NAME transformation name final JJ string NN transformation NN name NN root ROOT name compound name transformation
CONSTRUCTOR private doc info string transformation name string overview config def config def this transformation name transformation name this overview overview this config def config def SPECIFIER private NAME doc info PARAMETER LIST string transformation name string overview config def config def PARAMETER string transformation name TYPE string NAME string NAME transformation name PARAMETER string overview TYPE string NAME string NAME overview PARAMETER config def config def TYPE config def NAME config def NAME config def BLOCK EXPR this transformation name transformation name NAME this transformation name NAME this NAME transformation name NAME transformation name EXPR this overview overview NAME this overview NAME this NAME overview NAME overview EXPR this config def config def NAME this config def NAME this NAME config def NAME config def private JJ doc NN info NN root ROOT info compound info doc string NN transformation NN name NN root ROOT name compound name transformation string NN overview NN config NN def NN root ROOT def compound def config config NN def NN root ROOT def compound def config this DT transformation NN name NN transformation NN name NN root ROOT name compound name transformation this DT overview NN overview NN this DT config NN def NN config NN def NN root ROOT def compound def config
FUNCTION SPECIFIER private SPECIFIER static TYPE void NAME void NAME print transformation html PARAMETER LIST print stream out doc info doc info PARAMETER print stream out TYPE print stream NAME print stream NAME out PARAMETER doc info doc info TYPE doc info NAME doc info NAME doc info BLOCK EXPR out println div id doc info transformation name CALL out println div id doc info transformation name NAME out println NAME out NAME println ARGUMENT LIST ARGUMENT EXPR div id doc info transformation name NAME doc info transformation name NAME doc info NAME transformation name EXPR out print h CALL out print h NAME out print NAME out NAME print ARGUMENT LIST ARGUMENT EXPR h EXPR out print doc info transformation name CALL out print doc info transformation name NAME out print NAME out NAME print ARGUMENT LIST ARGUMENT EXPR doc info transformation name NAME doc info transformation name NAME doc info NAME transformation name EXPR out println h CALL out println h NAME out println NAME out NAME println ARGUMENT LIST ARGUMENT EXPR h EXPR out println doc info overview CALL out println doc info overview NAME out println NAME out NAME println ARGUMENT LIST ARGUMENT EXPR doc info overview NAME doc info overview NAME doc info NAME overview EXPR out println p CALL out println p NAME out println NAME out NAME println ARGUMENT LIST ARGUMENT EXPR p EXPR out println doc info config def to html table CALL out println doc info config def to html table NAME out println NAME out NAME println ARGUMENT LIST ARGUMENT EXPR doc info config def to html table CALL doc info config def to html table NAME doc info config def to html table NAME doc info NAME config def NAME to html table ARGUMENT LIST EXPR out println div CALL out println div NAME out println NAME out NAME println ARGUMENT LIST ARGUMENT EXPR div private JJ static JJ void NN print NN transformation NN html NN root ROOT html compound html print compound html transformation print NN stream NN root ROOT stream compound stream print out IN doc NN info NN root ROOT info compound info doc doc NN info NN root ROOT info compound info doc out IN println NN root ROOT println case println out div NN id NN doc NN info NN transformation NN name NN root ROOT name compound name doc compound name info compound name transformation out IN print NN root ROOT print case print out h NN out IN print NN root ROOT print case print out doc NN info NN transformation NN name NN root ROOT name compound name doc compound name info compound name transformation out IN println NN root ROOT println case println out h NN out IN println NN root ROOT println case println out doc NN info NN overview NN root ROOT overview compound overview doc compound overview info out IN println NN root ROOT println case println out p NN out IN println NN root ROOT println case println out doc NN info NN config NN def NN to TO html NN table NN root ROOT def compound def doc compound def info compound def config case table to compound table html nmod to def table out IN println NN root ROOT println case println out div NN
FUNCTION SPECIFIER private SPECIFIER static TYPE void NAME void NAME print html PARAMETER LIST print stream out PARAMETER print stream out TYPE print stream NAME print stream NAME out THROWS throws no such field exception illegal access exception instantiation exception ARGUMENT EXPR no such field exception NAME no such field exception ARGUMENT EXPR illegal access exception NAME illegal access exception ARGUMENT EXPR instantiation exception NAME instantiation exception BLOCK FOR for final doc info doc info transformations print transformation html out doc info CONTROL final doc info doc info transformations INIT final doc info doc info transformations TYPE final doc info SPECIFIER final NAME doc info NAME doc info RANGE transformations EXPR transformations NAME transformations BLOCK EXPR print transformation html out doc info CALL print transformation html out doc info NAME print transformation html ARGUMENT LIST ARGUMENT EXPR out NAME out ARGUMENT EXPR doc info NAME doc info private JJ static JJ void NN print NN html NN root ROOT html compound html print print NN stream NN root ROOT stream compound stream print out IN throws VBZ no DT such JJ field NN exception NN root ROOT field neg field no amod field such dep field exception illegal JJ access NN exception NN root ROOT exception amod exception illegal compound exception access instantiation NN exception NN root ROOT exception compound exception instantiation for IN final JJ doc NN info NN root ROOT info compound info doc doc NN info NN root ROOT info compound info doc transformations NNS print NN transformation NN html NN root ROOT html compound html print compound html transformation out IN doc NN info NN root ROOT info compound info doc
FUNCTION SPECIFIER public SPECIFIER static TYPE void NAME void NAME main PARAMETER LIST string args PARAMETER string args TYPE string NAME string MODIFIER NAME args THROWS throws exception ARGUMENT EXPR exception NAME exception BLOCK EXPR print html system out CALL print html system out NAME print html ARGUMENT LIST ARGUMENT EXPR system out NAME system out NAME system NAME out public NN static JJ void NN main JJ string NN args NNS throws VBZ exception NN print NN html NN root ROOT html compound html print system NN out RP root ROOT system compound prt system out
FUNCTION SPECIFIER public TYPE config def NAME config def NAME config PARAMETER LIST BLOCK RETURN return new config def EXPR new config def CALL config def NAME config def ARGUMENT LIST public NN config NN def NN root ROOT def compound def config config NN return NN new JJ config NN def NN root ROOT def compound def config
FUNCTION SPECIFIER public TYPE offset storage reader NAME offset storage reader NAME offset storage reader PARAMETER LIST BLOCK RETURN return reader EXPR reader NAME reader public NN offset VBN storage NN reader NN root ROOT reader amod reader offset compound reader storage offset VBN storage NN reader NN root ROOT reader amod reader offset compound reader storage return NN reader NN
DECL STMT SPECIFIER private TYPE final offset storage reader SPECIFIER final NAME offset storage reader NAME reader private JJ final JJ offset VBN storage NN reader NN root ROOT reader amod reader offset compound reader storage reader NN
DECL STMT SPECIFIER protected TYPE final class loader SPECIFIER final NAME class loader NAME loader protected VBN final JJ class NN loader NN root ROOT loader compound loader class loader NN
DECL STMT SPECIFIER protected TYPE final connector task id SPECIFIER final NAME connector task id NAME id protected VBN final JJ connector NN task NN id NN root ROOT id compound id connector compound id task id NN
DECL STMT SPECIFIER private TYPE volatile target state SPECIFIER volatile NAME target state NAME target state private JJ volatile JJ target NN state NN root ROOT state compound state target target NN state NN root ROOT state compound state target
COMMENT cancel this task this won t actually stop it but it will prevent the state from being updated when it eventually does shutdown FUNCTION SPECIFIER public TYPE void NAME void NAME cancel PARAMETER LIST BLOCK EXPR cancelled true NAME cancelled cancel this task this won t actually stop it but it will prevent the state from being root ROOT cancel det task this dobj cancel task nsubj won this dep cancel won dobj won t advmod stop actually dep won stop dobj stop it cc stop but nsubj prevent it aux prevent will dep won prevent conj but stop prevent det state the dobj prevent state mark being from advcl from prevent being cancel this task this won t actually stop it but it will prevent the state from being root ROOT cancel det task this dobj cancel task nsubj won this dep cancel won dobj won t advmod stop actually dep won stop dobj stop it cc stop but nsubj prevent it aux prevent will dep won prevent conj but stop prevent det state the dobj prevent state mark being from advcl from prevent being updated when it eventually does shutdown root ROOT updated advmod does when nsubj does it advmod does eventually advcl updated does dobj does shutdown public NN void NN cancel VB cancelled VBN true JJ cancel void ANTONYM ANTONYM stop shutdown ANTONYM ANTONYM void cancelled ANTONYM ANTONYM
CONSTRUCTOR public pane info tracker timer internals timer internals this timer internals timer internals SPECIFIER public NAME pane info tracker PARAMETER LIST timer internals timer internals PARAMETER timer internals timer internals TYPE timer internals NAME timer internals NAME timer internals BLOCK EXPR this timer internals timer internals NAME this timer internals NAME this NAME timer internals NAME timer internals public NN pane NN info NN tracker NN root ROOT tracker compound tracker pane compound tracker info timer NN internals NNS root ROOT internals compound internals timer timer NN internals NNS root ROOT internals compound internals timer this DT timer NN internals NNS timer NN internals NNS root ROOT internals compound internals timer
FUNCTION SPECIFIER public TYPE boolean NAME boolean NAME is empty PARAMETER LIST BLOCK RETURN return views is empty EXPR views is empty CALL views is empty NAME views is empty NAME views NAME is empty ARGUMENT LIST public NN boolean NN is VBZ empty JJ root ROOT empty cop empty is return NN views NNS is VBZ empty JJ root ROOT empty nsubj empty views cop empty is
DECL STMT SPECIFIER private TYPE set p collection view NAME set p collection view NAME set ARGUMENT LIST ARGUMENT NAME p collection view NAME p collection view ARGUMENT LIST ARGUMENT NAME NAME views private JJ set NN p NN collection NN view NN root ROOT view compound view p compound view collection views NNS
FUNCTION SPECIFIER public TYPE void NAME void NAME delete timer PARAMETER LIST instant timestamp time domain time domain PARAMETER instant timestamp TYPE instant NAME instant NAME timestamp PARAMETER time domain time domain TYPE time domain NAME time domain NAME time domain BLOCK EXPR timer internals delete timer timer data of namespace timestamp time domain CALL timer internals delete timer timer data of namespace timestamp time domain NAME timer internals delete timer NAME timer internals NAME delete timer ARGUMENT LIST ARGUMENT EXPR timer data of namespace timestamp time domain CALL timer data of namespace timestamp time domain NAME timer data of NAME timer data NAME of ARGUMENT LIST ARGUMENT EXPR namespace NAME namespace ARGUMENT EXPR timestamp NAME timestamp ARGUMENT EXPR time domain NAME time domain public NN void NN delete VB timer NN root ROOT delete dobj delete timer instant NN timestamp NN time NN domain NN root ROOT domain compound domain time time NN domain NN root ROOT domain compound domain time timer NN internals NNS delete VBP timer NN root ROOT delete compound internals timer nsubj delete internals dobj delete timer timer NN data NNS of IN root ROOT data compound data timer acl data of namespace NN timestamp NN time NN domain NN root ROOT domain compound domain time
FUNCTION SPECIFIER public TYPE void NAME void NAME set timer PARAMETER LIST instant timestamp time domain time domain PARAMETER instant timestamp TYPE instant NAME instant NAME timestamp PARAMETER time domain time domain TYPE time domain NAME time domain NAME time domain BLOCK EXPR timer internals set timer timer data of namespace timestamp time domain CALL timer internals set timer timer data of namespace timestamp time domain NAME timer internals set timer NAME timer internals NAME set timer ARGUMENT LIST ARGUMENT EXPR timer data of namespace timestamp time domain CALL timer data of namespace timestamp time domain NAME timer data of NAME timer data NAME of ARGUMENT LIST ARGUMENT EXPR namespace NAME namespace ARGUMENT EXPR timestamp NAME timestamp ARGUMENT EXPR time domain NAME time domain public NN void NN set VBN timer NN root ROOT set dobj set timer instant NN timestamp NN time NN domain NN root ROOT domain compound domain time time NN domain NN root ROOT domain compound domain time timer NN internals NNS set VBN timer NN root ROOT set compound internals timer nsubj set internals dobj set timer timer NN data NNS of IN root ROOT data compound data timer acl data of namespace NN timestamp NN time NN domain NN root ROOT domain compound domain time
DECL STMT SPECIFIER protected TYPE final active window set w SPECIFIER final NAME active window set w NAME active window set ARGUMENT LIST ARGUMENT NAME w NAME active windows protected VBN final JJ active JJ window NN set NN root ROOT set amod set active compound set window w NN active JJ windows NNS root ROOT windows amod windows active
DECL STMT SPECIFIER protected TYPE final state context w SPECIFIER final NAME state context w NAME state context ARGUMENT LIST ARGUMENT NAME w NAME context protected VBN final JJ state NN context NN root ROOT context compound context state w NN context NN
DECL STMT SPECIFIER protected TYPE final state internals SPECIFIER final NAME state internals NAME state internals protected VBN final JJ state NN internals NNS root ROOT internals compound internals state state NN internals NNS root ROOT internals compound internals state
FUNCTION SPECIFIER public TYPE k NAME k NAME key PARAMETER LIST BLOCK RETURN return key EXPR key NAME key public NN k NN key NN return NN key NN k key ANTONYM ANTONYM
COMMENT add an end of window hold or if too late for that a garbage collection hold if required return the link instant at which hold was added or literal null if no hold was added FUNCTION ANNOTATION nullable NAME nullable SPECIFIER private TYPE instant NAME instant NAME add end of window or garbage collection holds PARAMETER LIST reduce fn w context context boolean pane is empty PARAMETER reduce fn w context context TYPE reduce fn w context NAME reduce fn w context NAME reduce fn w NAME reduce fn ARGUMENT LIST ARGUMENT NAME ARGUMENT NAME ARGUMENT NAME ARGUMENT NAME w NAME context NAME context PARAMETER boolean pane is empty TYPE boolean NAME boolean NAME pane is empty BLOCK DECL STMT TYPE instant NAME instant NAME hold INIT add end of window hold context pane is empty EXPR add end of window hold context pane is empty CALL add end of window hold context pane is empty NAME add end of window hold ARGUMENT LIST ARGUMENT EXPR context NAME context ARGUMENT EXPR pane is empty NAME pane is empty IF if hold null hold add garbage collection hold context pane is empty CONDITION hold null EXPR hold null NAME hold THEN hold add garbage collection hold context pane is empty BLOCK EXPR hold add garbage collection hold context pane is empty NAME hold CALL add garbage collection hold context pane is empty NAME add garbage collection hold ARGUMENT LIST ARGUMENT EXPR context NAME context ARGUMENT EXPR pane is empty NAME pane is empty RETURN return hold EXPR hold NAME hold add an end of window hold or if too late for that a garbage collection hold if required root ROOT add det end an dobj add end case hold of compound hold window nmod of end hold cc add or case late if advmod late too conj or add late mark hold for mark hold that det collection a compound collection garbage nsubj hold collection dep late hold mark required if advcl if hold required return the link instant at which hold was added or literal null if no hold was added root ROOT return det instant the compound instant link dobj return instant nmod at added instant case which at ref instant which aux added hold auxpass added was acl relcl instant added cc added or amod null literal acl relcl instant null conj or added null mark added if neg hold no nsubjpass added hold auxpass added was dep added added nullable JJ private JJ instant NN add VB end NN of IN window NN or CC garbage NN collection NN holds VBZ root ROOT holds csubj holds add dobj add end case window of nmod of end window cc window or compound collection garbage nmod of end collection conj or window collection reduce VB fn NN root ROOT reduce dobj reduce fn w NN context NN context NN boolean NN pane NN is VBZ empty JJ root ROOT empty nsubj empty pane cop empty is instant NN hold NN add VB end NN of IN window NN hold NN root ROOT add dobj add end case hold of compound hold window nmod of end hold context NN pane NN is VBZ empty JJ root ROOT empty nsubj empty pane cop empty is if IN hold NN null JJ hold NN add VB garbage NN collection NN hold VBP root ROOT hold csubj hold add compound collection garbage dobj add collection context NN pane NN is VBZ empty JJ root ROOT empty nsubj empty pane cop empty is return NN hold NN hold required ANTONYM ANTONYM hold return ANTONYM ANTONYM
COMMENT prefetch watermark holds in preparation for merging FUNCTION SPECIFIER public TYPE void NAME void NAME prefetch on merge PARAMETER LIST merging state accessor w state PARAMETER merging state accessor w state TYPE merging state accessor w NAME merging state accessor w NAME merging state accessor ARGUMENT LIST ARGUMENT NAME ARGUMENT NAME w NAME state BLOCK EXPR state merging prefetch watermarks state element hold tag CALL state merging prefetch watermarks state element hold tag NAME state merging prefetch watermarks NAME state merging NAME prefetch watermarks ARGUMENT LIST ARGUMENT EXPR state NAME state ARGUMENT EXPR element hold tag NAME element hold tag prefetch watermark holds in preparation for merging root ROOT holds compound watermark prefetch nsubj holds watermark case preparation in nmod in holds preparation mark merging for advcl for holds merging public NN void NN prefetch NN on IN merge VBP root ROOT merge nsubj merge prefetch acl prefetch on merging VBG state NN accessor NN root ROOT merging compound accessor state dobj merging accessor w NN state NN state NN merging VBG prefetch NN watermarks NNS root ROOT state acl state merging compound watermarks prefetch dobj merging watermarks state NN element NN hold VBP tag NN root ROOT hold nsubj hold element dobj hold tag
FUNCTION SPECIFIER public TYPE string NAME string NAME string key PARAMETER LIST BLOCK RETURN return global string EXPR global string NAME global string public NN string NN string NN key NN root ROOT key compound key string return NN global JJ string NN root ROOT string amod string global
FUNCTION SPECIFIER public TYPE boolean NAME boolean NAME equals PARAMETER LIST object obj PARAMETER object obj TYPE object NAME object NAME obj BLOCK RETURN return obj this obj instanceof global namespace EXPR obj this obj instanceof global namespace NAME obj NAME this NAME obj NAME global namespace public NN boolean NN equals VBZ object NN obj NN return NN obj NN this DT obj NN instanceof NN global JJ namespace NN root ROOT namespace amod namespace global
FUNCTION SPECIFIER public TYPE int NAME int NAME hash code PARAMETER LIST BLOCK RETURN return objects hash namespace global EXPR objects hash namespace global CALL objects hash namespace global NAME objects hash NAME objects NAME hash ARGUMENT LIST ARGUMENT EXPR namespace global NAME namespace global NAME namespace NAME global public NN int NN hash VB code NN root ROOT hash dobj hash code return NN objects NNS hash VBP root ROOT hash nsubj hash objects namespace NN global JJ root ROOT global nmod npmod global namespace
FUNCTION SPECIFIER public TYPE string NAME string NAME to string PARAMETER LIST BLOCK RETURN return global EXPR global public NN string NN to TO string VB root ROOT string mark string to return NN global JJ
DECL STMT SPECIFIER private SPECIFIER static TYPE final string SPECIFIER final NAME string NAME window format INIT s EXPR s private JJ static JJ final JJ string NN window NN format NN root ROOT format compound format window s NNS
FUNCTION SPECIFIER public TYPE w NAME w NAME get window PARAMETER LIST BLOCK RETURN return window EXPR window NAME window public NN w NN get VB window NN root ROOT get dobj get window return NN window NN
DECL STMT SPECIFIER private TYPE final duration SPECIFIER final NAME duration NAME allowed lateness private JJ final JJ duration NN allowed VBN lateness NN root ROOT allowed dobj allowed lateness
DECL STMT SPECIFIER private TYPE final boolean SPECIFIER final NAME boolean NAME observes window private JJ final JJ boolean NN observes VBZ window NN root ROOT observes dobj observes window
DECL STMT SPECIFIER private TYPE final side input reader SPECIFIER final NAME side input reader NAME side input reader private JJ final JJ side NN input NN reader NN root ROOT reader compound reader side compound reader input side NN input NN reader NN root ROOT reader compound reader side compound reader input
COMMENT the set of known output tags DECL STMT SPECIFIER private TYPE final set tuple tag SPECIFIER final NAME set tuple tag NAME set ARGUMENT LIST ARGUMENT NAME tuple tag NAME tuple tag ARGUMENT LIST ARGUMENT NAME NAME output tags the set of known output tags root ROOT set det set the case tags of amod tags known compound tags output nmod of set tags the set of known output tags root ROOT set det set the case tags of amod tags known compound tags output nmod of set tags private JJ final JJ set NN tuple NN tag NN root ROOT tag compound tag tuple output NN tags NNS root ROOT tags compound tags output set tags ANTONYM ANTONYM
FUNCTION SPECIFIER public TYPE void NAME void NAME start bundle PARAMETER LIST BLOCK COMMENT this can contain user code wrap it in case it throws an exception TRY try invoker invoke start bundle new do fn start bundle context catch throwable t exception in user code throw wrap user code exception t BLOCK EXPR invoker invoke start bundle new do fn start bundle context CALL invoker invoke start bundle new do fn start bundle context NAME invoker invoke start bundle NAME invoker NAME invoke start bundle ARGUMENT LIST ARGUMENT EXPR new do fn start bundle context CALL do fn start bundle context NAME do fn start bundle context ARGUMENT LIST CATCH catch throwable t exception in user code throw wrap user code exception t PARAMETER LIST throwable t PARAMETER throwable t TYPE throwable NAME throwable NAME t BLOCK COMMENT exception in user code THROW throw wrap user code exception t EXPR wrap user code exception t CALL wrap user code exception t NAME wrap user code exception ARGUMENT LIST ARGUMENT EXPR t NAME t public NN void NN start VB bundle NN root ROOT start dobj start bundle this can contain user code wrap it in case it throws an exception root ROOT contain nsubj contain this aux contain can compound code user nsubj wrap code ccomp contain wrap dobj wrap it mark throws in mwe in case nsubj throws it advcl in case wrap throws det exception an dobj throws exception this can contain user code wrap it in case it throws an exception root ROOT contain nsubj contain this aux contain can compound code user nsubj wrap code ccomp contain wrap dobj wrap it mark throws in mwe in case nsubj throws it advcl in case wrap throws det exception an dobj throws exception try VB invoker NN invoke VBP start NN bundle NN root ROOT invoke nsubj invoke invoker compound bundle start dobj invoke bundle new JJ do VB fn NN start NN bundle NN context NN root ROOT do compound context fn compound context start compound context bundle dobj do context catch NN throwable JJ t NN exception in user code root ROOT exception case code in compound code user nmod in exception code throw VB wrap VB user NN code NN exception NN root ROOT wrap compound exception user compound exception code dobj wrap exception t NN contain catch ANTONYM ANTONYM contain throw ANTONYM ANTONYM contain throws ANTONYM ANTONYM
FUNCTION SPECIFIER public TYPE void NAME void NAME process element PARAMETER LIST windowed value input t compressed elem PARAMETER windowed value input t compressed elem TYPE windowed value input t NAME windowed value input t NAME windowed value ARGUMENT LIST ARGUMENT NAME input t NAME compressed elem BLOCK IF if observes window for windowed value input t elem compressed elem explode windows invoke process element elem else invoke process element compressed elem CONDITION observes window EXPR observes window NAME observes window THEN for windowed value input t elem compressed elem explode windows invoke process element elem BLOCK FOR for windowed value input t elem compressed elem explode windows invoke process element elem CONTROL windowed value input t elem compressed elem explode windows INIT windowed value input t elem compressed elem explode windows TYPE windowed value input t NAME windowed value input t NAME windowed value ARGUMENT LIST ARGUMENT NAME input t NAME elem RANGE compressed elem explode windows EXPR compressed elem explode windows CALL compressed elem explode windows NAME compressed elem explode windows NAME compressed elem NAME explode windows ARGUMENT LIST BLOCK EXPR invoke process element elem CALL invoke process element elem NAME invoke process element ARGUMENT LIST ARGUMENT EXPR elem NAME elem ELSE else invoke process element compressed elem BLOCK EXPR invoke process element compressed elem CALL invoke process element compressed elem NAME invoke process element ARGUMENT LIST ARGUMENT EXPR compressed elem NAME compressed elem public NN void NN process NN element NN root ROOT element compound element process windowed JJ value NN root ROOT value amod value windowed input NN t NN root ROOT t compound t input compressed VBN elem NN root ROOT elem amod elem compressed if IN observes VBZ window NN root ROOT observes dobj observes window for IN windowed JJ value NN root ROOT value amod value windowed input NN t NN root ROOT t compound t input elem NN compressed VBN elem NN explode VBP windows NNS root ROOT explode amod elem compressed nsubj explode elem dobj explode windows invoke VB process NN element NN root ROOT invoke compound element process dobj invoke element elem NN else RB invoke VB process NN element NN root ROOT invoke compound element process dobj invoke element compressed VBN elem NN root ROOT elem amod elem compressed
FUNCTION SPECIFIER public TYPE pipeline options NAME pipeline options NAME get pipeline options PARAMETER LIST BLOCK RETURN return options EXPR options NAME options public NN pipeline NN options NNS root ROOT options compound options pipeline get VB pipeline NN options NNS root ROOT get compound options pipeline dobj get options return NN options NNS
FUNCTION SPECIFIER public TYPE bounded window NAME bounded window NAME window PARAMETER LIST BLOCK THROW throw new unsupported operation exception cannot access window outside of process element and on timer methods EXPR new unsupported operation exception cannot access window outside of process element and on timer methods CALL unsupported operation exception cannot access window outside of process element and on timer methods NAME unsupported operation exception ARGUMENT LIST ARGUMENT EXPR cannot access window outside of process element and on timer methods public NN bounded VBN window NN root ROOT window amod window bounded window NN throw VB new JJ unsupported JJ operation NN exception NN root ROOT exception amod exception unsupported compound exception operation can MD not RB access NN window NN outside IN of IN process NN element NN root ROOT element compound element process and CC on IN timer NN root ROOT timer case timer on methods NNS
FUNCTION SPECIFIER public TYPE void NAME void NAME output PARAMETER LIST output t output PARAMETER output t output TYPE output t NAME output t NAME output BLOCK EXPR output main output tag output CALL output main output tag output NAME output ARGUMENT LIST ARGUMENT EXPR main output tag NAME main output tag ARGUMENT EXPR output NAME output public NN void NN output NN output NN t NN root ROOT t compound t output output NN output NN main JJ output NN tag NN root ROOT tag amod tag main compound tag output output NN
FUNCTION SPECIFIER public TYPE state NAME state NAME state PARAMETER LIST string state id PARAMETER string state id TYPE string NAME string NAME state id BLOCK TRY try state spec spec state spec signature state declarations get state id field get fn return step context state internals state get namespace state tags tag for spec state id state spec spec catch illegal access exception e throw new runtime exception e BLOCK DECL STMT TYPE state spec NAME state spec NAME state spec ARGUMENT LIST ARGUMENT NAME NAME spec INIT state spec signature state declarations get state id field get fn EXPR state spec signature state declarations get state id field get fn TERNARY state spec CONDITION state spec EXPR state spec NAME state spec NAME state spec ARGUMENT LIST ARGUMENT NAME CALL signature state declarations NAME signature state declarations NAME signature NAME state declarations ARGUMENT LIST CALL get state id NAME get ARGUMENT LIST ARGUMENT EXPR state id NAME state id CALL field NAME field ARGUMENT LIST CALL get fn NAME get ARGUMENT LIST ARGUMENT EXPR fn NAME fn RETURN return step context state internals state get namespace state tags tag for spec state id state spec spec EXPR step context state internals state get namespace state tags tag for spec state id state spec spec CALL step context state internals NAME step context state internals NAME step context NAME state internals ARGUMENT LIST CALL state get namespace state tags tag for spec state id state spec spec NAME state ARGUMENT LIST ARGUMENT EXPR get namespace CALL get namespace NAME get namespace ARGUMENT LIST ARGUMENT EXPR state tags tag for spec state id state spec spec CALL state tags tag for spec state id state spec spec NAME state tags tag for spec NAME state tags NAME tag for spec ARGUMENT LIST ARGUMENT EXPR state id NAME state id ARGUMENT EXPR state spec spec NAME state spec NAME spec CATCH catch illegal access exception e throw new runtime exception e PARAMETER LIST illegal access exception e PARAMETER illegal access exception e TYPE illegal access exception NAME illegal access exception NAME e BLOCK THROW throw new runtime exception e EXPR new runtime exception e CALL runtime exception e NAME runtime exception ARGUMENT LIST ARGUMENT EXPR e NAME e public NN state NN state NN string NN state NN id NN root ROOT id compound id state try VB state NN spec NN root ROOT spec compound spec state spec NN state NN spec NN root ROOT spec compound spec state signature NN state NN declarations NNS root ROOT declarations compound declarations signature compound declarations state get VB state NN id NN root ROOT id compound id state field NN get VB fn NN return NN step NN context NN root ROOT context compound context step state NN internals NNS root ROOT internals compound internals state state NN get VB namespace NN root ROOT get dobj get namespace state NN tags NNS tag NN for IN spec NN root ROOT tag compound tag state compound tag tags case spec for nmod for tag spec state NN id NN root ROOT id compound id state state NN spec NN root ROOT spec compound spec state spec NN catch NN illegal JJ access NN exception NN root ROOT exception amod exception illegal compound exception access e SYM throw VB new JJ runtime NN exception NN root ROOT exception compound exception runtime e SYM get return ANTONYM ANTONYM get throw ANTONYM ANTONYM return throw ANTONYM ANTONYM string get ANTONYM ANTONYM try return ANTONYM ANTONYM
COMMENT the state namespace for this context p any call to this method when more than one window is present will crash this represents a bug in the runner or the link do fn signature since values must be in exactly one window when state or timers are relevant FUNCTION SPECIFIER private TYPE state namespace NAME state namespace NAME get namespace PARAMETER LIST BLOCK IF if namespace null namespace state namespaces window window coder window CONDITION namespace null EXPR namespace null NAME namespace THEN namespace state namespaces window window coder window BLOCK EXPR namespace state namespaces window window coder window NAME namespace CALL state namespaces window window coder window NAME state namespaces window NAME state namespaces NAME window ARGUMENT LIST ARGUMENT EXPR window coder NAME window coder ARGUMENT EXPR window NAME window RETURN return namespace EXPR namespace NAME namespace the state namespace for this context root ROOT namespace det namespace the compound namespace state case context for det context this nmod for namespace context p any call to this method when more than one window is present will crash this root ROOT crash dep crash p det call any nsubj crash call case method to det method this nmod to call method advmod present when advmod one more mwe more than nummod window one nsubj present window cop present is acl relcl call present aux crash will dobj crash this represents a bug in the runner or the link do fn signature since values must be in exactly root ROOT represents det bug a dobj represents bug case runner in det runner the nmod in bug runner cc runner or det link the nmod in bug link conj or runner link dep represents do compound signature fn dobj do signature mark exactly since nsubj exactly values aux exactly must cop exactly be case exactly in advcl since do exactly one window when state or timers are relevant root ROOT window nummod window one advmod relevant when nsubj relevant state cc state or conj or state timers nsubj relevant timers cop relevant are acl relcl window relevant private JJ state NN namespace NN root ROOT namespace compound namespace state get VB namespace NN root ROOT get dobj get namespace if IN namespace NN null JJ namespace NN state NN namespaces NNS window NN root ROOT window compound window state compound window namespaces window NN coder NN root ROOT coder compound coder window window NN return NN namespace NN is present ANTONYM ANTONYM present are ANTONYM ANTONYM present be ANTONYM ANTONYM present return ANTONYM ANTONYM state present ANTONYM ANTONYM
DECL STMT SPECIFIER private TYPE duration NAME duration NAME period INIT duration zero EXPR duration zero NAME duration zero NAME duration NAME zero private JJ duration NN period NN duration NN zero CD root ROOT duration nummod duration zero
DECL STMT SPECIFIER private TYPE duration NAME duration NAME offset INIT duration zero EXPR duration zero NAME duration zero NAME duration NAME zero private JJ duration NN offset VBN duration NN zero CD root ROOT duration nummod duration zero
FUNCTION ANNOTATION override NAME override SPECIFIER public TYPE void NAME void NAME set relative PARAMETER LIST BLOCK DECL STMT TYPE instant NAME instant NAME target DECL STMT TYPE instant NAME instant NAME now INIT get current time EXPR get current time CALL get current time NAME get current time ARGUMENT LIST IF if period equals duration zero target now plus offset else long millis since start now plus offset get millis period get millis target millis since start now now plus period minus millis since start CONDITION period equals duration zero EXPR period equals duration zero CALL period equals duration zero NAME period equals NAME period NAME equals ARGUMENT LIST ARGUMENT EXPR duration zero NAME duration zero NAME duration NAME zero THEN target now plus offset BLOCK EXPR target now plus offset NAME target CALL now plus offset NAME now plus NAME now NAME plus ARGUMENT LIST ARGUMENT EXPR offset NAME offset ELSE else long millis since start now plus offset get millis period get millis target millis since start now now plus period minus millis since start BLOCK DECL STMT TYPE long NAME long NAME millis since start INIT now plus offset get millis period get millis EXPR now plus offset get millis period get millis CALL now plus offset NAME now plus NAME now NAME plus ARGUMENT LIST ARGUMENT EXPR offset NAME offset CALL get millis NAME get millis ARGUMENT LIST CALL period get millis NAME period get millis NAME period NAME get millis ARGUMENT LIST EXPR target millis since start now now plus period minus millis since start NAME target TERNARY millis since start now now plus period minus millis since start CONDITION millis since start EXPR millis since start NAME millis since start THEN now EXPR now NAME now ELSE now plus period minus millis since start EXPR now plus period minus millis since start CALL now plus period NAME now plus NAME now NAME plus ARGUMENT LIST ARGUMENT EXPR period NAME period CALL minus millis since start NAME minus ARGUMENT LIST ARGUMENT EXPR millis since start NAME millis since start EXPR target min target and gc time target NAME target CALL min target and gc time target NAME min target and gc time ARGUMENT LIST ARGUMENT EXPR target NAME target EXPR set underlying timer target CALL set underlying timer target NAME set underlying timer ARGUMENT LIST ARGUMENT EXPR target NAME target override NN public NN void NN set NN relative JJ root ROOT set dep set relative instant NN target NN instant NN now RB get VB current JJ time NN root ROOT get amod time current dobj get time if IN period NN equals VBZ root ROOT equals nsubj equals period duration NN zero CD root ROOT duration nummod duration zero target NN now RB plus CC root ROOT plus advmod plus now offset VBN else RB long RB millis NN since IN start NN root ROOT millis case start since nmod since millis start now RB plus CC root ROOT plus advmod plus now offset VBN get VB millis FW root ROOT get dobj get millis period NN get VB millis JJ root ROOT period acl period get xcomp get millis target NN millis NN since IN start NN root ROOT millis case start since nmod since millis start now RB now RB plus CC root ROOT plus advmod plus now period NN minus CC millis NN since IN start NN root ROOT millis case start since nmod since millis start target NN min NN target NN and CC gc NN time NN root ROOT target compound target min cc target and compound time gc conj and target time target NN set VBN underlying VBG timer NN root ROOT set xcomp set underlying dobj underlying timer target NN plus minus ANTONYM ANTONYM
COMMENT sets the timer for the target time without checking anything about whether it is a reasonable thing to do for example absolute processing time timers are not really sensible since the user has no way to compute a good choice of time FUNCTION SPECIFIER private TYPE void NAME void NAME set underlying timer PARAMETER LIST instant target PARAMETER instant target TYPE instant NAME instant NAME target BLOCK EXPR timer internals set timer namespace timer id target spec get time domain CALL timer internals set timer namespace timer id target spec get time domain NAME timer internals set timer NAME timer internals NAME set timer ARGUMENT LIST ARGUMENT EXPR namespace NAME namespace ARGUMENT EXPR timer id NAME timer id ARGUMENT EXPR target NAME target ARGUMENT EXPR spec get time domain CALL spec get time domain NAME spec get time domain NAME spec NAME get time domain ARGUMENT LIST sets the timer for the target time without checking anything about whether it is root ROOT sets det timer the dobj sets timer case time for det time the compound time target nmod for timer time mark checking without advcl without sets checking dobj checking anything mark is about mark is whether nsubj is it acl whether anything is a reasonable thing to do for example absolute processing time timers are not root ROOT thing det thing a amod thing reasonable mark do to acl to thing do case timers for compound timers example amod timers absolute compound timers processing compound timers time nmod for do timers dep thing are neg are not a reasonable thing to do for example absolute processing time timers are not root ROOT thing det thing a amod thing reasonable mark do to acl to thing do case timers for compound timers example amod timers absolute compound timers processing compound timers time nmod for do timers dep thing are neg are not really sensible since the user has no way to compute a good choice of time root ROOT sensible advmod sensible really mark has since det user the nsubj has user advcl since sensible has neg way no dobj has way mark compute to acl to way compute det choice a amod choice good dobj compute choice case time of nmod of choice time private JJ void NN set VBN underlying VBG timer NN root ROOT set xcomp set underlying dobj underlying timer instant NN target NN timer NN internals NNS set VBN timer NN root ROOT set compound internals timer nsubj set internals dobj set timer namespace NN timer NN id NN root ROOT id compound id timer target NN spec NN get VB time NN domain NN root ROOT get nsubj get spec compound domain time dobj get domain checking has ANTONYM ANTONYM do has ANTONYM ANTONYM do processing ANTONYM ANTONYM reasonable good ANTONYM ANTONYM sensible good ANTONYM ANTONYM sets checking ANTONYM ANTONYM sets target ANTONYM ANTONYM void good ANTONYM ANTONYM absolute good SYNONYM SYNONYM
CONSTRUCTOR public peeking reiterator reiterator t iterator this iterator check not null iterator SPECIFIER public NAME peeking reiterator PARAMETER LIST reiterator t iterator PARAMETER reiterator t iterator TYPE reiterator t NAME reiterator t NAME reiterator ARGUMENT LIST ARGUMENT NAME t NAME iterator BLOCK EXPR this iterator check not null iterator NAME this iterator NAME this NAME iterator CALL check not null iterator NAME check not null ARGUMENT LIST ARGUMENT EXPR iterator NAME iterator public NN peeking VBG reiterator NN root ROOT peeking dobj peeking reiterator reiterator NN t NN iterator NN this DT iterator NN check NN not RB null JJ root ROOT check neg null not dep check null iterator NN
FUNCTION SPECIFIER public TYPE t NAME t NAME next PARAMETER LIST BLOCK DECL STMT TYPE t NAME t NAME result INIT peek EXPR peek CALL peek NAME peek ARGUMENT LIST EXPR next element computed false NAME next element computed RETURN return result EXPR result NAME result public NN t NN next IN t NN result NN peek NN next JJ element NN computed VBD root ROOT computed amod element next nsubj computed element false JJ return NN result NN result return ANTONYM ANTONYM
FUNCTION SPECIFIER private TYPE void NAME void NAME compute next PARAMETER LIST BLOCK IF if next element computed return CONDITION next element computed EXPR next element computed NAME next element computed THEN return BLOCK RETURN return IF if iterator has next return CONDITION iterator has next EXPR iterator has next CALL iterator has next NAME iterator has next NAME iterator NAME has next ARGUMENT LIST THEN return BLOCK RETURN return EXPR next element iterator next NAME next element CALL iterator next NAME iterator next NAME iterator NAME next ARGUMENT LIST EXPR next element computed true NAME next element computed private JJ void NN compute VB next IN root ROOT compute advmod compute next if IN next JJ element NN computed VBD root ROOT computed amod element next nsubj computed element return NN if IN iterator NN has VBZ next JJ root ROOT has nsubj has iterator advmod has next return NN next JJ element NN root ROOT element amod element next iterator NN next IN root ROOT iterator dep iterator next next JJ element NN computed VBD root ROOT computed amod element next nsubj computed element true JJ
DECL STMT SPECIFIER private TYPE final metric name SPECIFIER final NAME metric name NAME name private JJ final JJ metric JJ name NN root ROOT name amod name metric name NN
FUNCTION SPECIFIER public TYPE metric name NAME metric name NAME get name PARAMETER LIST BLOCK RETURN return name EXPR name NAME name public NN metric JJ name NN root ROOT name amod name metric get VB name NN root ROOT get dobj get name return NN name NN
FUNCTION SPECIFIER public TYPE dirty state NAME dirty state NAME get dirty PARAMETER LIST BLOCK RETURN return dirty EXPR dirty NAME dirty public NN dirty JJ state NN root ROOT state amod state dirty get VB dirty JJ root ROOT get xcomp get dirty return NN dirty JJ
COMMENT generally runners should construct instances using the methods in link metrics container impl unless they need to define their own version of link metrics container these constructors are only public so runners can instantiate CONSTRUCTOR internal public distribution cell metric name name this name name ANNOTATION internal NAME internal SPECIFIER public NAME distribution cell PARAMETER LIST metric name name PARAMETER metric name name TYPE metric name NAME metric name NAME name BLOCK EXPR this name name NAME this name NAME this NAME name NAME name generally runners should construct instances using the methods in root ROOT construct advmod runners generally nsubj construct runners aux construct should dobj construct instances xcomp construct using det methods the dobj using methods dep using in link metrics container impl unless they need to define their own version of root ROOT impl compound impl link compound impl metrics compound impl container mark need unless nsubj need they nsubj xsubj define they advcl unless impl need mark define to xcomp need define nmod poss version their amod version own dobj define version acl version of link metrics container these constructors are only public so runners can instantiate root ROOT container compound container link compound container metrics det constructors these nsubj public constructors cop public are advmod public only acl relcl container public mark instantiate so nsubj instantiate runners aux instantiate can advcl so public instantiate link metrics container these constructors are only public so runners can instantiate root ROOT container compound container link compound container metrics det constructors these nsubj public constructors cop public are advmod public only acl relcl container public mark instantiate so nsubj instantiate runners aux instantiate can advcl so public instantiate internal JJ public NN distribution NN cell NN root ROOT cell compound cell distribution metric JJ name NN root ROOT name amod name metric name NN this DT name NN name NN are name ANTONYM ANTONYM can using ANTONYM ANTONYM construct name ANTONYM ANTONYM public internal ANTONYM ANTONYM
COMMENT return an iterable over the values in the current link metrics map FUNCTION SPECIFIER public TYPE iterable t NAME iterable t NAME iterable ARGUMENT LIST ARGUMENT NAME t NAME values PARAMETER LIST BLOCK RETURN return iterables unmodifiable iterable metrics values EXPR iterables unmodifiable iterable metrics values CALL iterables unmodifiable iterable metrics values NAME iterables unmodifiable iterable NAME iterables NAME unmodifiable iterable ARGUMENT LIST ARGUMENT EXPR metrics values CALL metrics values NAME metrics values NAME metrics NAME values ARGUMENT LIST return an iterable over the values in the current link metrics map root ROOT map csubj map return det iterable an dobj return iterable case values over det values the nmod over iterable values case metrics in det metrics the amod metrics current compound metrics link nmod in iterable metrics public NN iterable JJ t NN values NNS return NN iterables NNS unmodifiable JJ iterable JJ root ROOT iterables amod iterable unmodifiable dep iterables iterable metrics NNS values NNS root ROOT values compound values metrics
FUNCTION DECL abstract read k v build SPECIFIER abstract TYPE read k v NAME read k v NAME read ARGUMENT LIST ARGUMENT NAME k ARGUMENT NAME v NAME build PARAMETER LIST abstract JJ read VB k NN v LS build VB k v SYNONYM SYNONYM
FUNCTION SPECIFIER public TYPE configuration NAME configuration NAME get PARAMETER LIST BLOCK RETURN return conf EXPR conf NAME conf public NN configuration NN get VB return NN conf NN get return ANTONYM ANTONYM
CONSTRUCTOR public serializable configuration configuration conf if conf null throw new null pointer exception configuration must not be null this conf conf SPECIFIER public NAME serializable configuration PARAMETER LIST configuration conf PARAMETER configuration conf TYPE configuration NAME configuration NAME conf BLOCK IF if conf null throw new null pointer exception configuration must not be null CONDITION conf null EXPR conf null NAME conf THEN throw new null pointer exception configuration must not be null BLOCK THROW throw new null pointer exception configuration must not be null EXPR new null pointer exception configuration must not be null CALL null pointer exception configuration must not be null NAME null pointer exception ARGUMENT LIST ARGUMENT EXPR configuration must not be null EXPR this conf conf NAME this conf NAME this NAME conf NAME conf public NN serializable JJ configuration NN root ROOT configuration amod configuration serializable configuration NN conf NN if IN conf NN null JJ throw VB new JJ null JJ pointer NN exception NN root ROOT exception amod exception null compound exception pointer configuration NN must MD not RB be VB null JJ this DT conf NN conf NN
DECL STMT SPECIFIER private SPECIFIER transient TYPE configuration NAME configuration NAME conf private JJ transient JJ configuration NN conf NN
DECL STMT SPECIFIER private SPECIFIER static TYPE final long SPECIFIER final NAME long NAME serial version uid INIT l EXPR l private JJ static JJ final JJ long RB serial JJ version NN uid NN root ROOT uid amod uid serial compound uid version l NN
DECL STMT SPECIFIER private SPECIFIER static TYPE final string SPECIFIER final NAME string NAME default appname INIT beam gearpump app EXPR beam gearpump app private JJ static JJ final JJ string NN default NN appname NN root ROOT appname compound appname default beam NN gearpump NN app NN root ROOT app compound app beam compound app gearpump
DECL STMT SPECIFIER protected TYPE string NAME string NAME result path protected VBN string NN result NN path NN root ROOT path compound path result
DECL STMT SPECIFIER private TYPE final instant SPECIFIER final NAME instant NAME offset private JJ final JJ instant NN offset VBN
FUNCTION SPECIFIER public TYPE string NAME string NAME to string PARAMETER LIST BLOCK RETURN return period formatter print delay to period EXPR period formatter print delay to period CALL period formatter print delay to period NAME period formatter print NAME period formatter NAME print ARGUMENT LIST ARGUMENT EXPR delay to period CALL delay to period NAME delay to period NAME delay NAME to period ARGUMENT LIST public NN string NN to TO string VB root ROOT string mark string to return NN period NN formatter NN root ROOT formatter compound formatter period print NN delay NN to TO period NN root ROOT delay case period to nmod to delay period
CONSTRUCTOR public delay fn duration delay this delay delay SPECIFIER public NAME delay fn PARAMETER LIST duration delay PARAMETER duration delay TYPE duration NAME duration NAME delay BLOCK EXPR this delay delay NAME this delay NAME this NAME delay NAME delay public NN delay NN fn NN root ROOT fn compound fn delay duration NN delay NN this DT delay NN delay NN
FUNCTION SPECIFIER public TYPE void NAME void NAME clear PARAMETER LIST trigger context c PARAMETER trigger context c TYPE trigger context NAME trigger context NAME c THROWS throws exception ARGUMENT EXPR exception NAME exception BLOCK EXPR c state access delayed until tag clear CALL c state NAME c state NAME c NAME state ARGUMENT LIST CALL access delayed until tag NAME access ARGUMENT LIST ARGUMENT EXPR delayed until tag NAME delayed until tag CALL clear NAME clear ARGUMENT LIST public NN void NN clear JJ trigger NN context NN root ROOT context compound context trigger c NN throws VBZ exception NN c NN state NN root ROOT state compound state c access NN delayed VBN until IN tag NN root ROOT delayed case tag until nmod until delayed tag clear JJ clear throws ANTONYM ANTONYM public clear ANTONYM ANTONYM
COMMENT return the state address window of active code window into which all new state should be written always one of the results of link read state addresses FUNCTION DECL w write state address w window TYPE w NAME w NAME write state address PARAMETER LIST w window PARAMETER w window TYPE w NAME w NAME window return the state address window of active code window into which all new state should be root ROOT return det window the compound window state compound window address dobj return window case window of amod window active compound window code nmod of window window nmod into be window case which into ref window which det state all amod state new nsubj be state aux be should acl relcl window be written always one of the results of link read state addresses root ROOT read csubj read written advmod one always det qmod results one mwe one of det results the dobj written results case link of nmod of results link compound addresses state dobj read addresses written always one of the results of link read state addresses root ROOT read csubj read written advmod one always det qmod results one mwe one of det results the dobj written results case link of nmod of results link compound addresses state dobj read addresses w NN write VB state NN address NN root ROOT write compound address state dobj write address w NN window NN return results ANTONYM ANTONYM
DECL STMT SPECIFIER private TYPE in memory timer internals NAME in memory timer internals NAME timer internals private JJ in IN memory NN timer NN internals NNS root ROOT internals case internals in compound internals memory compound internals timer timer NN internals NNS root ROOT internals compound internals timer
FUNCTION SPECIFIER public TYPE void NAME void NAME close PARAMETER LIST THROWS throws exception ARGUMENT EXPR exception NAME exception BLOCK EXPR tester close CALL tester close NAME tester close NAME tester NAME close ARGUMENT LIST public NN void NN close RB throws VBZ exception NN tester NN close NN root ROOT close compound close tester public close ANTONYM ANTONYM
DECL STMT SPECIFIER private TYPE final metric update t SPECIFIER final NAME metric update t NAME metric update ARGUMENT LIST ARGUMENT NAME t NAME committed private JJ final JJ metric JJ update VBP root ROOT update nsubj update metric t NN committed VBN
FUNCTION SPECIFIER public TYPE string NAME string NAME step PARAMETER LIST BLOCK RETURN return step EXPR step NAME step public NN string NN step NN return NN step NN
CONSTRUCTOR private accumulated metric result metric name name string step t attempted t committed boolean is committed supported this name name this step step this attempted attempted this committed committed this is committed supported is committed supported SPECIFIER private NAME accumulated metric result PARAMETER LIST metric name name string step t attempted t committed boolean is committed supported PARAMETER metric name name TYPE metric name NAME metric name NAME name PARAMETER string step TYPE string NAME string NAME step PARAMETER t attempted TYPE t NAME t NAME attempted PARAMETER t committed TYPE t NAME t NAME committed PARAMETER boolean is committed supported TYPE boolean NAME boolean NAME is committed supported BLOCK EXPR this name name NAME this name NAME this NAME name NAME name EXPR this step step NAME this step NAME this NAME step NAME step EXPR this attempted attempted NAME this attempted NAME this NAME attempted NAME attempted EXPR this committed committed NAME this committed NAME this NAME committed NAME committed EXPR this is committed supported is committed supported NAME this is committed supported NAME this NAME is committed supported NAME is committed supported private JJ accumulated VBN metric JJ result NN root ROOT result amod result accumulated amod result metric metric JJ name NN root ROOT name amod name metric name NN string NN step NN t NN attempted VBN t NN committed VBN boolean NN is VBZ committed VBN supported VBN root ROOT committed auxpass committed is dep committed supported this DT name NN name NN this DT step NN step NN this DT attempted VBN attempted VBN this DT committed VBN committed VBN this DT is VBZ committed VBN supported VBN is VBZ committed VBN supported VBN root ROOT committed auxpass committed is dep committed supported
COMMENT return an iterable over the entries in the current link metrics map FUNCTION SPECIFIER public TYPE iterable map entry k t NAME iterable map entry k t NAME iterable ARGUMENT LIST ARGUMENT NAME map entry k t NAME map NAME entry k t NAME entry ARGUMENT LIST ARGUMENT NAME k ARGUMENT NAME t NAME entries PARAMETER LIST BLOCK RETURN return iterables unmodifiable iterable metrics entry set EXPR iterables unmodifiable iterable metrics entry set CALL iterables unmodifiable iterable metrics entry set NAME iterables unmodifiable iterable NAME iterables NAME unmodifiable iterable ARGUMENT LIST ARGUMENT EXPR metrics entry set CALL metrics entry set NAME metrics entry set NAME metrics NAME entry set ARGUMENT LIST return an iterable over the entries in the current link metrics map root ROOT map csubj map return det iterable an dobj return iterable case entries over det entries the nmod over iterable entries case metrics in det metrics the amod metrics current compound metrics link nmod in entries metrics public NN iterable JJ map NN entry NN root ROOT entry compound entry map k NN t NN entries NNS return NN iterables NNS unmodifiable JJ iterable JJ root ROOT iterables amod iterable unmodifiable dep iterables iterable metrics NNS entry NN set NN root ROOT set compound set metrics compound set entry
COMMENT return an iterable over the values in the current link metrics map FUNCTION SPECIFIER public TYPE iterable t NAME iterable t NAME iterable ARGUMENT LIST ARGUMENT NAME t NAME values PARAMETER LIST BLOCK RETURN return iterables unmodifiable iterable metrics values EXPR iterables unmodifiable iterable metrics values CALL iterables unmodifiable iterable metrics values NAME iterables unmodifiable iterable NAME iterables NAME unmodifiable iterable ARGUMENT LIST ARGUMENT EXPR metrics values CALL metrics values NAME metrics values NAME metrics NAME values ARGUMENT LIST return an iterable over the values in the current link metrics map root ROOT map csubj map return det iterable an dobj return iterable case values over det values the nmod over iterable values case metrics in det metrics the amod metrics current compound metrics link nmod in iterable metrics public NN iterable JJ t NN values NNS return NN iterables NNS unmodifiable JJ iterable JJ root ROOT iterables amod iterable unmodifiable dep iterables iterable metrics NNS values NNS root ROOT values compound values metrics
COMMENT transient fields that are lazy initialized and then memoized DECL STMT SPECIFIER private SPECIFIER transient TYPE extension registry NAME extension registry NAME memoized extension registry transient fields that are lazy initialized and then memoized root ROOT memoized amod fields transient nsubjpass initialized fields nsubj memoized fields ref fields that auxpass initialized are advmod initialized lazy acl relcl fields initialized cc initialized and advmod initialized then private JJ transient JJ extension NN registry NN root ROOT registry compound registry extension memoized JJ extension NN registry NN root ROOT registry amod registry memoized compound registry extension
DECL STMT SPECIFIER static TYPE final type descriptor message SPECIFIER final NAME type descriptor message NAME type descriptor ARGUMENT LIST ARGUMENT NAME message NAME message type INIT new type descriptor message EXPR new type descriptor message CLASS type descriptor message SUPER type descriptor message NAME type descriptor message NAME type descriptor ARGUMENT LIST ARGUMENT NAME message ARGUMENT LIST BLOCK static JJ final JJ type NN descriptor NN root ROOT descriptor compound descriptor type message NN message NN type NN root ROOT type compound type message new JJ type NN descriptor NN root ROOT descriptor compound descriptor type message NN
FUNCTION SPECIFIER public TYPE set class NAME set class NAME set ARGUMENT LIST ARGUMENT NAME class NAME class ARGUMENT LIST ARGUMENT NAME NAME get extension hosts PARAMETER LIST BLOCK RETURN return extension host classes EXPR extension host classes NAME extension host classes public NN set NN class NN get VB extension NN hosts NNS root ROOT get compound hosts extension dobj get hosts return NN extension NN host NN classes NNS root ROOT classes compound classes extension compound classes host
FUNCTION SPECIFIER public TYPE object NAME object NAME to object PARAMETER LIST BLOCK ASSERT assert exists value EXPR exists value NAME exists NAME value RETURN return exists value null EXPR exists value null TERNARY exists value null CONDITION exists EXPR exists NAME exists THEN value EXPR value NAME value ELSE null EXPR null public NN object NN to TO object VB root ROOT object mark object to assert VB exists VBZ value NN return NN exists VBZ value NN null JJ
DECL STMT SPECIFIER public TYPE int NAME int NAME value public NN int NN value NN
FUNCTION SPECIFIER public SPECIFIER final TYPE int NAME int NAME doc id PARAMETER LIST BLOCK RETURN return sub scorers top doc EXPR sub scorers top doc CALL sub scorers top NAME sub scorers top NAME sub scorers NAME top ARGUMENT LIST NAME doc public NN final JJ int NN doc NN id NN root ROOT id compound id doc return NN sub NN scorers NNS top JJ root ROOT top compound scorers sub nsubj top scorers doc NN return top ANTONYM ANTONYM
DECL STMT SPECIFIER private TYPE final disjunction disi approximation SPECIFIER final NAME disjunction disi approximation NAME approximation private JJ final JJ disjunction NN disi NN approximation NN root ROOT approximation compound approximation disjunction compound approximation disi approximation NN
COMMENT escape character DECL STMT SPECIFIER public SPECIFIER static TYPE final char SPECIFIER final NAME char NAME wildcard escape INIT EXPR escape character root ROOT escape dobj escape character public NN static JJ final JJ char NN wildcard NN escape NN root ROOT escape compound escape wildcard
COMMENT starting term ord for this frame used to reset term ord in rewind DECL STMT TYPE long NAME long NAME term ord orig starting term ord for this frame used to reset term ord in rewind root ROOT starting compound ord term dobj starting ord case frame for det frame this nmod for ord frame acl frame used mark reset to xcomp used reset compound ord term dobj reset ord case rewind in nmod in reset rewind long RB term NN ord NN orig NN root ROOT orig compound orig term compound orig ord
COMMENT placeholder for missing offset that means all values are missing DECL STMT SPECIFIER static TYPE final int SPECIFIER final NAME int NAME all missing INIT EXPR placeholder for missing offset that means all values are missing root ROOT placeholder case missing for nmod for placeholder missing acl missing offset nsubj means that ccomp offset means det values all nsubj missing values aux missing are ccomp means missing static JJ final JJ int NN all DT missing VBG root ROOT missing dep missing all
DECL STMT SPECIFIER static TYPE final int SPECIFIER final NAME int NAME sorted single valued INIT EXPR static JJ final JJ int NN sorted VBN single JJ valued VBN root ROOT sorted xcomp sorted single dep single valued
COMMENT build reverse index from every th term DECL STMT SPECIFIER static TYPE final int SPECIFIER final NAME int NAME reverse interval shift INIT EXPR build reverse index from every th term root ROOT build amod index reverse dobj build index case term from det term every det term th nmod from build term static JJ final JJ int NN reverse JJ interval NN shift NN root ROOT shift amod shift reverse compound shift interval
DECL STMT TYPE final int SPECIFIER final NAME int NAME int INDEX NAME stack final JJ int NN stack VB
CONSTRUCTOR public terms enum with slice int index reader slice sub slice this sub slice sub slice this index index assert sub slice length length sub slice length SPECIFIER public NAME terms enum with slice PARAMETER LIST int index reader slice sub slice PARAMETER int index TYPE int NAME int NAME index PARAMETER reader slice sub slice TYPE reader slice NAME reader slice NAME sub slice BLOCK EXPR this sub slice sub slice NAME this sub slice NAME this NAME sub slice NAME sub slice EXPR this index index NAME this index NAME this NAME index NAME index ASSERT assert sub slice length length sub slice length EXPR sub slice length length sub slice length NAME sub slice length NAME sub slice NAME length NAME sub slice length NAME sub slice NAME length public NN terms NNS enum VBP with IN slice NN root ROOT enum nsubj enum terms case slice with nmod with enum slice int NN index NN reader NN slice NN root ROOT slice compound slice reader sub NN slice NN root ROOT slice compound slice sub this DT sub NN slice NN sub NN slice NN root ROOT slice compound slice sub this DT index NN index NN assert VB sub NN slice NN length NN root ROOT length compound length sub compound length slice length NN sub NN slice NN length NN root ROOT length compound length sub compound length slice
COMMENT default maximum number of point in each leaf block DECL STMT SPECIFIER public SPECIFIER static TYPE final int SPECIFIER final NAME int NAME default max points in leaf node INIT EXPR default maximum number of point in each leaf block root ROOT number compound number default compound number maximum case point of nmod of number point case block in det block each compound block leaf nmod in number block public NN static JJ final JJ int NN default NN max NN points NNS in IN leaf NN node NN root ROOT points compound points default compound points max case node in compound node leaf nmod in points node block points ANTONYM ANTONYM point block ANTONYM ANTONYM
DECL STMT SPECIFIER private TYPE final int SPECIFIER final NAME int NAME bytes per doc private JJ final JJ int NN bytes NNS per IN doc NN root ROOT bytes case doc per nmod per bytes doc
DECL STMT SPECIFIER private TYPE term iterator NAME term iterator NAME iterator private JJ term NN iterator NN root ROOT iterator compound iterator term iterator NN
FUNCTION SPECIFIER public TYPE void NAME void NAME visit PARAMETER LIST int doc id PARAMETER int doc id TYPE int NAME int NAME doc id BLOCK THROW throw new illegal state exception shouldn t get here since cell inside query isn t emitted EXPR new illegal state exception shouldn t get here since cell inside query isn t emitted CALL illegal state exception shouldn t get here since cell inside query isn t emitted NAME illegal state exception ARGUMENT LIST ARGUMENT EXPR shouldn t get here since cell inside query isn t emitted public NN void NN visit NN int NN doc NN id NN root ROOT id compound id doc throw VB new JJ illegal JJ state NN exception NN root ROOT exception amod exception illegal compound exception state should MD n NN t NN root ROOT t compound t n get VB here RB since IN cell NN inside IN query NN root ROOT cell case query inside nmod inside cell query is VBZ n NN t NN root ROOT t compound t n emitted VBN throw get ANTONYM ANTONYM
FUNCTION SPECIFIER public SPECIFIER final TYPE boolean NAME boolean NAME equals PARAMETER LIST object other PARAMETER object other TYPE object NAME object NAME other BLOCK RETURN return same class as other equals to get class cast other EXPR same class as other equals to get class cast other CALL same class as other NAME same class as ARGUMENT LIST ARGUMENT EXPR other NAME other CALL equals to get class cast other NAME equals to ARGUMENT LIST ARGUMENT EXPR get class cast other CALL get class NAME get class ARGUMENT LIST CALL cast other NAME cast ARGUMENT LIST ARGUMENT EXPR other NAME other public NN final JJ boolean NN equals VBZ object NN other JJ return NN same JJ class NN as IN root ROOT class amod class same dep class as other JJ equals VBZ to TO root ROOT equals dep equals to get VB class NN root ROOT get dobj get class cast NN other JJ
DECL STMT TYPE byte NAME byte NAME byte INDEX NAME point bytes INIT new byte bytes per dim EXPR new byte bytes per dim NAME byte bytes per dim NAME byte INDEX bytes per dim EXPR bytes per dim NAME bytes per dim byte NN point NN bytes NNS root ROOT bytes compound bytes point new JJ byte NN bytes NNS per IN dim NN root ROOT bytes case dim per nmod per bytes dim
FUNCTION SPECIFIER private TYPE boolean NAME boolean NAME is wildcard PARAMETER LIST char sequence text PARAMETER char sequence text TYPE char sequence NAME char sequence NAME text BLOCK IF if text null text length return false CONDITION text null text length EXPR text null text length NAME text CALL text length NAME text length NAME text NAME length ARGUMENT LIST THEN return false BLOCK RETURN return false EXPR false COMMENT if a un escaped or if found return true COMMENT start at the end since it s more common to put wildcards at the end FOR for int i text length i i if text char at i text char at i unescaped char sequence was escaped text i return true CONTROL int i text length i i INIT int i text length TYPE int NAME int NAME i INIT text length EXPR text length CALL text length NAME text length NAME text NAME length ARGUMENT LIST CONDITION i EXPR i NAME i INCR i EXPR i NAME i BLOCK IF if text char at i text char at i unescaped char sequence was escaped text i return true CONDITION text char at i text char at i unescaped char sequence was escaped text i EXPR text char at i text char at i unescaped char sequence was escaped text i CALL text char at i NAME text char at NAME text NAME char at ARGUMENT LIST ARGUMENT EXPR i NAME i CALL text char at i NAME text char at NAME text NAME char at ARGUMENT LIST ARGUMENT EXPR i NAME i CALL unescaped char sequence was escaped text i NAME unescaped char sequence was escaped NAME unescaped char sequence NAME was escaped ARGUMENT LIST ARGUMENT EXPR text NAME text ARGUMENT EXPR i NAME i THEN return true BLOCK RETURN return true EXPR true RETURN return false EXPR false private JJ boolean NN is VBZ wildcard NN root ROOT wildcard cop wildcard is char NN sequence NN root ROOT sequence compound sequence char text NN if IN text NN null JJ text NN length NN root ROOT length compound length text return NN false JJ if a un escaped or if found return true root ROOT escaped mark escaped if det un a nsubj escaped un nsubj found un cc escaped or mark found if conj or escaped found nmod npmod true return xcomp found true if a un escaped or if found return true root ROOT escaped mark escaped if det un a nsubj escaped un nsubj found un cc escaped or mark found if conj or escaped found nmod npmod true return xcomp found true start at the end since it s more common to put wildcards at the end root ROOT start case end at det end the nmod at start end mark common since nsubj common it nsubj xsubj put it cop common s advmod common more advcl since start common mark put to xcomp common put dobj put wildcards case end at det end the nmod at put end for IN int NN i LS text NN length NN root ROOT length compound length text i LS i LS if IN text NN char NN at IN root ROOT char compound char text dep char at i LS text NN char NN at IN root ROOT char compound char text dep char at i LS unescaped JJ char NN sequence NN was VBD escaped VBN root ROOT escaped amod sequence unescaped compound sequence char nsubjpass escaped sequence auxpass escaped was text NN i LS return NN true JJ return NN false JJ false true ANTONYM ANTONYM found put ANTONYM ANTONYM start end ANTONYM ANTONYM start end ANTONYM ANTONYM null false SYNONYM SYNONYM
FUNCTION SPECIFIER public TYPE double metaphone filter NAME double metaphone filter NAME create PARAMETER LIST token stream input PARAMETER token stream input TYPE token stream NAME token stream NAME input BLOCK RETURN return new double metaphone filter input max code length inject EXPR new double metaphone filter input max code length inject CALL double metaphone filter input max code length inject NAME double metaphone filter ARGUMENT LIST ARGUMENT EXPR input NAME input ARGUMENT EXPR max code length NAME max code length ARGUMENT EXPR inject NAME inject public NN double JJ metaphone NN filter NN root ROOT filter amod filter double compound filter metaphone create VB token JJ stream NN root ROOT stream amod stream token input NN return NN new JJ double JJ metaphone NN filter NN root ROOT filter amod filter double compound filter metaphone input NN max NN code NN length NN root ROOT length compound length max compound length code inject VB
COMMENT creates a new double metaphone filter factory CONSTRUCTOR public double metaphone filter factory map string string args super args inject get boolean args inject true max code length get int args max code length default max code length if args is empty throw new illegal argument exception unknown parameters args SPECIFIER public NAME double metaphone filter factory PARAMETER LIST map string string args PARAMETER map string string args TYPE map string string NAME map string string NAME map ARGUMENT LIST ARGUMENT NAME string ARGUMENT NAME string NAME args BLOCK EXPR super args CALL super args NAME super ARGUMENT LIST ARGUMENT EXPR args NAME args EXPR inject get boolean args inject true NAME inject CALL get boolean args inject true NAME get boolean ARGUMENT LIST ARGUMENT EXPR args NAME args ARGUMENT EXPR inject NAME inject ARGUMENT EXPR true EXPR max code length get int args max code length default max code length NAME max code length CALL get int args max code length default max code length NAME get int ARGUMENT LIST ARGUMENT EXPR args NAME args ARGUMENT EXPR max code length NAME max code length ARGUMENT EXPR default max code length NAME default max code length IF if args is empty throw new illegal argument exception unknown parameters args CONDITION args is empty EXPR args is empty CALL args is empty NAME args is empty NAME args NAME is empty ARGUMENT LIST THEN throw new illegal argument exception unknown parameters args BLOCK THROW throw new illegal argument exception unknown parameters args EXPR new illegal argument exception unknown parameters args CALL illegal argument exception unknown parameters args NAME illegal argument exception ARGUMENT LIST ARGUMENT EXPR unknown parameters args NAME args creates a new double metaphone filter factory root ROOT creates det factory a amod factory new amod factory double compound factory metaphone compound factory filter dobj creates factory public NN double JJ metaphone NN filter NN factory NN root ROOT factory amod factory double compound factory metaphone compound factory filter map NN string NN string NN args NNS super JJ args NNS inject VB get VB boolean JJ root ROOT get xcomp get boolean args NNS inject VB true JJ max NN code NN length NN root ROOT length compound length max compound length code get VB int NN root ROOT get dobj get int args NNS max NN code NN length NN root ROOT length compound length max compound length code default NN max NN code NN length NN root ROOT length compound length default compound length max compound length code if IN args NNS is VBZ empty JJ root ROOT empty nsubj empty args cop empty is throw VB new JJ illegal JJ argument NN exception NN root ROOT exception amod exception illegal compound exception argument unknown JJ parameters NNS args NNS creates throw ANTONYM ANTONYM
FUNCTION SPECIFIER protected TYPE void NAME void NAME initialize iterator PARAMETER LIST THROWS throws io exception ARGUMENT EXPR io exception NAME io exception BLOCK TRY try analyze input catch analysis engine process exception resource initialization exception e throw new io exception e BLOCK EXPR analyze input CALL analyze input NAME analyze input ARGUMENT LIST CATCH catch analysis engine process exception resource initialization exception e throw new io exception e PARAMETER LIST analysis engine process exception resource initialization exception e PARAMETER analysis engine process exception resource initialization exception e TYPE analysis engine process exception NAME analysis engine process exception TYPE resource initialization exception NAME resource initialization exception NAME e BLOCK THROW throw new io exception e EXPR new io exception e CALL io exception e NAME io exception ARGUMENT LIST ARGUMENT EXPR e NAME e EXPR final offset correct offset cas get document text length NAME final offset CALL correct offset cas get document text length NAME correct offset ARGUMENT LIST ARGUMENT EXPR cas get document text length CALL cas get document text NAME cas get document text NAME cas NAME get document text ARGUMENT LIST CALL length NAME length ARGUMENT LIST DECL STMT TYPE type NAME type NAME token type INIT cas get type system get type token type string EXPR cas get type system get type token type string CALL cas get type system NAME cas get type system NAME cas NAME get type system ARGUMENT LIST CALL get type token type string NAME get type ARGUMENT LIST ARGUMENT EXPR token type string NAME token type string EXPR iterator cas get annotation index token type iterator NAME iterator CALL cas get annotation index token type NAME cas get annotation index NAME cas NAME get annotation index ARGUMENT LIST ARGUMENT EXPR token type NAME token type CALL iterator NAME iterator ARGUMENT LIST protected VBN void NN initialize VB iterator NN root ROOT initialize dobj initialize iterator throws VBZ io NN exception NN root ROOT exception compound exception io try VB analyze VB input NN root ROOT analyze dobj analyze input catch NN analysis NN engine NN process NN exception NN root ROOT exception compound exception analysis compound exception engine compound exception process resource NN initialization NN exception NN root ROOT exception compound exception resource compound exception initialization e SYM throw VB new JJ io NN exception NN root ROOT exception compound exception io e SYM final JJ offset VBN root ROOT offset advmod offset final correct JJ offset VBN root ROOT correct dep correct offset cas NNS get VBP document NN text NN root ROOT get nsubj get cas compound text document dobj get text length NN type NN token JJ type NN root ROOT type amod type token cas NNS get VBP type NN system NN root ROOT get nsubj get cas compound system type dobj get system get VB type NN root ROOT get dobj get type token JJ type NN string NN root ROOT string amod string token compound string type iterator NN cas NNS get VBP annotation JJ index NN root ROOT get nsubj get cas amod index annotation dobj get index token JJ type NN root ROOT type amod type token iterator NN
DECL STMT SPECIFIER private TYPE int NAME int NAME final offset INIT EXPR private JJ int NN final JJ offset VBN root ROOT offset advmod offset final
DECL STMT SPECIFIER private TYPE final offset attribute SPECIFIER final NAME offset attribute NAME offset attr private JJ final JJ offset VBN attribute NN root ROOT attribute amod attribute offset offset VBN attr NN root ROOT offset dobj offset attr
DECL STMT SPECIFIER private TYPE final char term attribute SPECIFIER final NAME char term attribute NAME term attr private JJ final JJ char NN term NN attribute NN root ROOT attribute compound attribute char compound attribute term term NN attr NN root ROOT attr compound attr term
COMMENT the list of holes if a point is in the hole it is not in the polygon DECL STMT SPECIFIER protected TYPE final list geo polygon SPECIFIER final NAME list geo polygon NAME list ARGUMENT LIST ARGUMENT NAME geo polygon NAME holes the list of holes if a point is in the hole it is not in the polygon root ROOT list det list the case holes of nmod of list holes mark hole if det point a nsubj hole point cop hole is case hole in det hole the dep list hole nsubj polygon it cop polygon is neg polygon not case polygon in det polygon the ccomp hole polygon the list of holes if a point is in the hole it is not in the polygon root ROOT list det list the case holes of nmod of list holes mark hole if det point a nsubj hole point cop hole is case hole in det hole the dep list hole nsubj polygon it cop polygon is neg polygon not case polygon in det polygon the ccomp hole polygon protected VBN final JJ list NN geo NN polygon NN root ROOT polygon compound polygon geo holes NNS
COMMENT the list of polygon points DECL STMT SPECIFIER protected TYPE final list geo point SPECIFIER final NAME list geo point NAME list ARGUMENT LIST ARGUMENT NAME geo point NAME points the list of polygon points root ROOT list det list the case points of compound points polygon nmod of list points protected VBN final JJ list NN geo NN point NN root ROOT point compound point geo points NNS
COMMENT check if a point is within the provided holes param point point to check return true if the point is within any of the holes FUNCTION SPECIFIER protected TYPE boolean NAME boolean NAME is within holes PARAMETER LIST final geo point point PARAMETER final geo point point TYPE final geo point SPECIFIER final NAME geo point NAME point BLOCK IF if holes null for final geo polygon hole holes if hole is within point return true CONDITION holes null EXPR holes null NAME holes THEN for final geo polygon hole holes if hole is within point return true BLOCK FOR for final geo polygon hole holes if hole is within point return true CONTROL final geo polygon hole holes INIT final geo polygon hole holes TYPE final geo polygon SPECIFIER final NAME geo polygon NAME hole RANGE holes EXPR holes NAME holes BLOCK IF if hole is within point return true CONDITION hole is within point EXPR hole is within point CALL hole is within point NAME hole is within NAME hole NAME is within ARGUMENT LIST ARGUMENT EXPR point NAME point THEN return true BLOCK RETURN return true EXPR true RETURN return false EXPR false check if a point is within the provided holes root ROOT check mark holes if det point a nsubj holes point cop holes is case holes within det holes the amod holes provided advcl within check holes param point point to check root ROOT point compound point param compound point point mark check to acl to point check return true if the point is within any of the holes root ROOT return amod return true mark any if det point the nsubj any point cop any is case any within advcl within true any case holes of det holes the nmod of any holes protected VBN boolean NN is VBZ within IN holes NNS root ROOT holes cop holes is case holes within final JJ geo NN point NN root ROOT point compound point geo point NN if IN holes NNS null JJ for IN final JJ geo NN polygon NN root ROOT polygon compound polygon geo hole NN holes NNS if IN hole NN is VBZ within IN root ROOT within nsubj within hole cop within is point NN return NN true JJ return NN false JJ check point ANTONYM ANTONYM check return ANTONYM ANTONYM provided return ANTONYM ANTONYM true false ANTONYM ANTONYM null false SYNONYM SYNONYM
FUNCTION SPECIFIER protected TYPE boolean NAME boolean NAME local is within PARAMETER LIST final vector v PARAMETER final vector v TYPE final vector SPECIFIER final NAME vector NAME v BLOCK RETURN return local is within v x v y v z EXPR local is within v x v y v z CALL local is within v x v y v z NAME local is within ARGUMENT LIST ARGUMENT EXPR v x NAME v x NAME v NAME x ARGUMENT EXPR v y NAME v y NAME v NAME y ARGUMENT EXPR v z NAME v z NAME v NAME z protected VBN boolean NN local JJ is VBZ within IN root ROOT within nsubj within local cop within is final JJ vector NN v LS return NN local JJ is VBZ within IN root ROOT within nsubj within local cop within is v LS x CC root ROOT x dep x v v LS y SYM root ROOT v root v y v LS z SYM root ROOT v root v z v x SYNONYM SYNONYM
FUNCTION SPECIFIER public TYPE geo point NAME geo point NAME geo point INDEX NAME get edge points PARAMETER LIST BLOCK RETURN return edge points EXPR edge points NAME edge points public NN geo NN point NN root ROOT point compound point geo get VB edge NN points NNS root ROOT get compound points edge dobj get points return NN edge NN points NNS root ROOT points compound points edge
FUNCTION SPECIFIER public TYPE string NAME string NAME to string PARAMETER LIST BLOCK RETURN return geo concave polygon planetmodel planet model points points internal edges is internal edges holes null holes holes EXPR geo concave polygon planetmodel planet model points points internal edges is internal edges holes null holes holes NAME planet model NAME points NAME is internal edges TERNARY holes null holes holes CONDITION holes null EXPR holes null NAME holes THEN EXPR ELSE holes holes EXPR holes holes NAME holes public NN string NN to TO string VB root ROOT string mark string to return NN geo NN concave NN polygon NN root ROOT polygon compound polygon geo compound polygon concave planetmodel NN planet NN model NN root ROOT model compound model planet points NNS points NNS internal JJ edges NNS root ROOT edges amod edges internal is VBZ internal JJ edges NNS root ROOT edges cop edges is amod edges internal holes NNS null JJ holes NNS holes NNS
DECL STMT SPECIFIER private SPECIFIER static TYPE final string SPECIFIER final NAME string NAME brokers key name INIT brokers EXPR brokers private JJ static JJ final JJ string NN brokers NNS key JJ name NN root ROOT name compound name brokers amod name key brokers NNS
CONSTRUCTOR public metadata response int throttle time ms list node brokers string cluster id int controller id list topic metadata topic metadata this throttle time ms throttle time ms this brokers brokers this controller get controller node controller id brokers this topic metadata topic metadata this cluster id cluster id SPECIFIER public NAME metadata response PARAMETER LIST int throttle time ms list node brokers string cluster id int controller id list topic metadata topic metadata PARAMETER int throttle time ms TYPE int NAME int NAME throttle time ms PARAMETER list node brokers TYPE list node NAME list node NAME list ARGUMENT LIST ARGUMENT NAME node NAME brokers PARAMETER string cluster id TYPE string NAME string NAME cluster id PARAMETER int controller id TYPE int NAME int NAME controller id PARAMETER list topic metadata topic metadata TYPE list topic metadata NAME list topic metadata NAME list ARGUMENT LIST ARGUMENT NAME topic metadata NAME topic metadata BLOCK EXPR this throttle time ms throttle time ms NAME this throttle time ms NAME this NAME throttle time ms NAME throttle time ms EXPR this brokers brokers NAME this brokers NAME this NAME brokers NAME brokers EXPR this controller get controller node controller id brokers NAME this controller NAME this NAME controller CALL get controller node controller id brokers NAME get controller node ARGUMENT LIST ARGUMENT EXPR controller id NAME controller id ARGUMENT EXPR brokers NAME brokers EXPR this topic metadata topic metadata NAME this topic metadata NAME this NAME topic metadata NAME topic metadata EXPR this cluster id cluster id NAME this cluster id NAME this NAME cluster id NAME cluster id public NN metadata NN response NN root ROOT response compound response metadata int NN throttle NN time NN ms NNS root ROOT ms compound ms throttle compound ms time list NN node NN brokers NNS string NN cluster NN id NN root ROOT id compound id cluster int NN controller NN id NN root ROOT id compound id controller list NN topic NN metadata NN root ROOT metadata compound metadata topic topic NN metadata NN root ROOT metadata compound metadata topic this DT throttle NN time NN ms NNS throttle NN time NN ms NNS root ROOT ms compound ms throttle compound ms time this DT brokers NNS brokers NNS this DT controller NN get VB controller NN node NN root ROOT get compound node controller dobj get node controller NN id NN root ROOT id compound id controller brokers NNS this DT topic NN metadata NN topic NN metadata NN root ROOT metadata compound metadata topic this DT cluster NN id NN cluster NN id NN root ROOT id compound id cluster
FUNCTION SPECIFIER public TYPE list acl creation NAME list acl creation NAME list ARGUMENT LIST ARGUMENT NAME acl creation NAME acl creations PARAMETER LIST BLOCK RETURN return acl creations EXPR acl creations NAME acl creations public NN list NN acl NN creation NN root ROOT creation compound creation acl acl NN creations NNS root ROOT creations compound creations acl return NN acl NN creations NNS root ROOT creations compound creations acl
DECL STMT SPECIFIER private SPECIFIER static TYPE final long SPECIFIER final NAME long NAME commit interval ms INIT l EXPR l private JJ static JJ final JJ long RB commit VB interval NN ms NNS root ROOT commit compound ms interval dobj commit ms l NN
COMMENT the number of milliseconds until the next timeout DECL STMT SPECIFIER private TYPE int NAME int NAME next timeout ms the number of milliseconds until the next timeout root ROOT number det number the case milliseconds of nmod of number milliseconds case timeout until det timeout the amod timeout next nmod until number timeout private JJ int NN next JJ timeout NN ms NNS root ROOT ms amod ms next compound ms timeout
COMMENT check for calls which have timed out timed out calls will be removed and failed the remaining milliseconds until the next timeout will be updated param calls the collection of calls return the number of calls which were timed out FUNCTION TYPE int NAME int NAME handle timeouts PARAMETER LIST collection call calls string msg PARAMETER collection call calls TYPE collection call NAME collection call NAME collection ARGUMENT LIST ARGUMENT NAME call NAME calls PARAMETER string msg TYPE string NAME string NAME msg BLOCK DECL STMT TYPE int NAME int NAME num timed out INIT EXPR FOR for iterator call iter calls iterator iter has next call call iter next int remaining ms calc timeout ms remaining as int now call deadline ms if remaining ms call fail now new timeout exception msg iter remove num timed out else next timeout ms math min next timeout ms remaining ms CONTROL iterator call iter calls iterator iter has next INIT iterator call iter calls iterator TYPE iterator call NAME iterator call NAME iterator ARGUMENT LIST ARGUMENT NAME call NAME iter INIT calls iterator EXPR calls iterator CALL calls iterator NAME calls iterator NAME calls NAME iterator ARGUMENT LIST CONDITION iter has next EXPR iter has next CALL iter has next NAME iter has next NAME iter NAME has next ARGUMENT LIST INCR BLOCK DECL STMT TYPE call NAME call NAME call INIT iter next EXPR iter next CALL iter next NAME iter next NAME iter NAME next ARGUMENT LIST DECL STMT TYPE int NAME int NAME remaining ms INIT calc timeout ms remaining as int now call deadline ms EXPR calc timeout ms remaining as int now call deadline ms CALL calc timeout ms remaining as int now call deadline ms NAME calc timeout ms remaining as int ARGUMENT LIST ARGUMENT EXPR now NAME now ARGUMENT EXPR call deadline ms NAME call deadline ms NAME call NAME deadline ms IF if remaining ms call fail now new timeout exception msg iter remove num timed out else next timeout ms math min next timeout ms remaining ms CONDITION remaining ms EXPR remaining ms NAME remaining ms THEN call fail now new timeout exception msg iter remove num timed out BLOCK EXPR call fail now new timeout exception msg CALL call fail now new timeout exception msg NAME call fail NAME call NAME fail ARGUMENT LIST ARGUMENT EXPR now NAME now ARGUMENT EXPR new timeout exception msg CALL timeout exception msg NAME timeout exception ARGUMENT LIST ARGUMENT EXPR msg NAME msg EXPR iter remove CALL iter remove NAME iter remove NAME iter NAME remove ARGUMENT LIST EXPR num timed out NAME num timed out ELSE else next timeout ms math min next timeout ms remaining ms BLOCK EXPR next timeout ms math min next timeout ms remaining ms NAME next timeout ms CALL math min next timeout ms remaining ms NAME math min NAME math NAME min ARGUMENT LIST ARGUMENT EXPR next timeout ms NAME next timeout ms ARGUMENT EXPR remaining ms NAME remaining ms RETURN return num timed out EXPR num timed out NAME num timed out check for calls which have timed out root ROOT check case calls for nmod for check calls nsubj timed calls ref calls which aux timed have acl relcl calls timed compound prt timed out timed out calls will be removed and failed root ROOT removed amod calls timed compound prt timed out nsubjpass removed calls nsubjpass failed calls aux removed will auxpass removed be cc removed and conj and removed failed the remaining milliseconds until the next timeout will be updated root ROOT milliseconds det milliseconds the amod milliseconds remaining mark updated until det timeout the amod timeout next nsubjpass updated timeout aux updated will auxpass updated be dep milliseconds updated param calls the collection of calls root ROOT calls nsubj calls param det collection the dobj calls collection case calls of nmod of collection calls return the number of calls which were timed out root ROOT return det number the dobj return number case calls of nmod of number calls nsubjpass timed calls ref calls which auxpass timed were acl relcl calls timed compound prt timed out int NN handle VB timeouts NNS root ROOT handle dobj handle timeouts collection NN call NN calls NNS string NN msg NN int NN num NN timed VBD out RP root ROOT timed nsubj timed num compound prt timed out for IN iterator NN call NN iter NN calls NNS iterator NN root ROOT iterator compound iterator calls iter NN has VBZ next JJ root ROOT has nsubj has iter advmod has next call NN call NN iter NN next IN root ROOT iter dep iter next int NN remaining VBG ms NNS root ROOT ms amod ms remaining calc NN timeout NN ms NNS remaining VBG as IN int NN root ROOT ms compound ms calc compound ms timeout acl ms remaining case int as nmod as remaining int now RB call VB deadline NN ms NNS root ROOT call compound ms deadline dobj call ms if IN remaining VBG ms NNS root ROOT ms amod ms remaining call NN fail VBP root ROOT fail nsubj fail call now RB new JJ timeout NN exception NN root ROOT exception compound exception timeout msg NN iter NN remove VB root ROOT remove nsubj remove iter num NN timed VBD out RP root ROOT timed nsubj timed num compound prt timed out else RB next JJ timeout NN ms NNS root ROOT ms amod ms next compound ms timeout math NN min NN root ROOT min compound min math next JJ timeout NN ms NNS root ROOT ms amod ms next compound ms timeout remaining VBG ms NNS root ROOT ms amod ms remaining return NN num NN timed VBD out RP root ROOT timed nsubj timed num compound prt timed out check fail ANTONYM ANTONYM check failed ANTONYM ANTONYM check have ANTONYM ANTONYM check return ANTONYM ANTONYM fail return ANTONYM ANTONYM failed return ANTONYM ANTONYM have remove ANTONYM ANTONYM have removed ANTONYM ANTONYM have return ANTONYM ANTONYM next removed ANTONYM ANTONYM return number ANTONYM ANTONYM new else SYNONYM SYNONYM out failed SYNONYM SYNONYM
FUNCTION SPECIFIER private TYPE resource NAME resource NAME config resource to resource PARAMETER LIST config resource config resource PARAMETER config resource config resource TYPE config resource NAME config resource NAME config resource BLOCK DECL STMT TYPE resource type NAME resource type NAME resource type SWITCH switch config resource type case topic resource type resource type topic break case broker resource type resource type broker break default throw new illegal argument exception unexpected resource type config resource type CONDITION config resource type EXPR config resource type CALL config resource type NAME config resource type NAME config resource NAME type ARGUMENT LIST BLOCK CASE case topic EXPR topic NAME topic EXPR resource type resource type topic NAME resource type NAME resource type topic NAME resource type NAME topic BREAK break CASE case broker EXPR broker NAME broker EXPR resource type resource type broker NAME resource type NAME resource type broker NAME resource type NAME broker BREAK break DEFAULT default THROW throw new illegal argument exception unexpected resource type config resource type EXPR new illegal argument exception unexpected resource type config resource type CALL illegal argument exception unexpected resource type config resource type NAME illegal argument exception ARGUMENT LIST ARGUMENT EXPR unexpected resource type config resource type CALL config resource type NAME config resource type NAME config resource NAME type ARGUMENT LIST RETURN return new resource resource type config resource name EXPR new resource resource type config resource name CALL resource resource type config resource name NAME resource ARGUMENT LIST ARGUMENT EXPR resource type NAME resource type ARGUMENT EXPR config resource name CALL config resource name NAME config resource name NAME config resource NAME name ARGUMENT LIST private JJ resource NN config NN resource NN to TO resource NN root ROOT resource compound resource config case resource to nmod to resource resource config NN resource NN root ROOT resource compound resource config config NN resource NN root ROOT resource compound resource config resource NN type NN root ROOT type compound type resource resource NN type NN root ROOT type compound type resource switch NN config NN resource NN type NN root ROOT type compound type config compound type resource case NN topic NN resource NN type NN root ROOT type compound type resource resource NN type NN topic NN root ROOT topic compound topic resource compound topic type break NN case NN broker NN resource NN type NN root ROOT type compound type resource resource NN type NN broker NN root ROOT broker compound broker resource compound broker type break NN default NN throw VB new JJ illegal JJ argument NN exception NN root ROOT exception amod exception illegal compound exception argument unexpected JJ resource NN type NN config NN resource NN type NN root ROOT type compound type config compound type resource return NN new JJ resource NN resource NN type NN root ROOT type compound type resource config NN resource NN name NN root ROOT name compound name config compound name resource break name ANTONYM ANTONYM break return ANTONYM ANTONYM break throw ANTONYM ANTONYM case topic ANTONYM ANTONYM switch break ANTONYM ANTONYM throw name ANTONYM ANTONYM throw return ANTONYM ANTONYM topic return ANTONYM ANTONYM
COMMENT create a self signed x certificate from http bfo com blog odds and ends creating a new x certificate html param dn the x distinguished name eg cn test l london c gb param pair the key pair param days how many days from now the certificate is valid for param algorithm the signing algorithm eg sha with rsa return the self signed certificate throws certificate exception thrown if a security error or an io error occurred FUNCTION SPECIFIER public SPECIFIER static TYPE x certificate NAME x certificate NAME generate certificate PARAMETER LIST string dn key pair pair int days string algorithm PARAMETER string dn TYPE string NAME string NAME dn PARAMETER key pair pair TYPE key pair NAME key pair NAME pair PARAMETER int days TYPE int NAME int NAME days PARAMETER string algorithm TYPE string NAME string NAME algorithm THROWS throws certificate exception ARGUMENT EXPR certificate exception NAME certificate exception BLOCK RETURN return new certificate builder days algorithm generate dn pair EXPR new certificate builder days algorithm generate dn pair CALL certificate builder days algorithm NAME certificate builder ARGUMENT LIST ARGUMENT EXPR days NAME days ARGUMENT EXPR algorithm NAME algorithm CALL generate dn pair NAME generate ARGUMENT LIST ARGUMENT EXPR dn NAME dn ARGUMENT EXPR pair NAME pair create a self signed x certificate root ROOT create det self a nsubj signed self ccomp create signed cc signed x ccomp create certificate conj x signed certificate from http bfo com blog odds and ends creating a new x certificate html root ROOT odds case odds from amod odds http compound odds bfo compound odds com compound odds blog cc odds and aux creating ends conj and odds creating det html a amod html new compound html x compound html certificate dobj creating html param dn the x distinguished name eg cn test l london c gb root ROOT dn nsubj dn param det x the dobj dn x amod name distinguished dep x name compound gb eg compound gb cn compound gb test compound gb l compound gb london compound gb c dep name gb param pair the key pair root ROOT pair compound pair param det pair the amod pair key dep pair pair param days how many days from now the certificate is valid for root ROOT days compound days param advmod many how amod days many dobj valid days case now from nmod from valid now det certificate the nsubj valid certificate cop valid is dep days valid dep valid for param algorithm the signing algorithm eg sha with rsa root ROOT algorithm compound algorithm param det algorithm the compound algorithm signing nsubj sha algorithm advmod sha eg acl relcl algorithm sha case rsa with nmod with sha rsa return the self signed certificate root ROOT signed csubj signed return det self the dobj return self dobj signed certificate throws certificate exception thrown if a security error or an io error occurred root ROOT throws compound exception certificate dobj throws exception acl exception thrown mark occurred if det error a compound error security nsubj occurred error cc error or det error an compound error io conj or error error nsubj occurred error advcl if thrown occurred public NN static JJ x CC certificate NN root ROOT certificate compound certificate x generate VB certificate NN root ROOT generate dobj generate certificate string NN dn NN key JJ pair NN root ROOT pair amod pair key pair NN int NN days NNS string NN algorithm NN throws VBZ certificate NN exception NN root ROOT exception compound exception certificate return NN new JJ certificate NN builder NN root ROOT builder compound builder certificate days NNS algorithm NN generate VB dn NN pair NN create name ANTONYM ANTONYM create thrown ANTONYM ANTONYM create throws ANTONYM ANTONYM creating name ANTONYM ANTONYM creating thrown ANTONYM ANTONYM creating throws ANTONYM ANTONYM distinguished signing ANTONYM ANTONYM ends generate ANTONYM ANTONYM name is ANTONYM ANTONYM name thrown ANTONYM ANTONYM name throws ANTONYM ANTONYM return occurred ANTONYM ANTONYM return thrown ANTONYM ANTONYM return throws ANTONYM ANTONYM signed distinguished ANTONYM ANTONYM thrown generate ANTONYM ANTONYM throws generate ANTONYM ANTONYM l c SYNONYM SYNONYM x c SYNONYM SYNONYM x l SYNONYM SYNONYM
DECL STMT SPECIFIER public SPECIFIER static TYPE final type SPECIFIER final NAME type NAME nullable string INIT new type override public boolean is nullable return true EXPR new type override public boolean is nullable return true CLASS type override public boolean is nullable return true SUPER type NAME type ARGUMENT LIST BLOCK FUNCTION ANNOTATION override NAME override SPECIFIER public TYPE boolean NAME boolean NAME is nullable PARAMETER LIST BLOCK RETURN return true EXPR true  public NN static JJ final JJ type NN nullable JJ string NN root ROOT string amod string nullable new JJ type NN override NN public NN boolean NN is VBZ nullable JJ root ROOT nullable cop nullable is return NN true JJ
FUNCTION SPECIFIER public TYPE long NAME long NAME validate PARAMETER LIST object item PARAMETER object item TYPE object NAME object NAME item BLOCK IF if item instanceof long return long item CONDITION item instanceof long EXPR item instanceof long NAME item NAME long THEN return long item BLOCK RETURN return long item EXPR long item NAME long NAME item THROW throw new schema exception item is not a long EXPR new schema exception item is not a long CALL schema exception item is not a long NAME schema exception ARGUMENT LIST ARGUMENT EXPR item is not a long NAME item public NN long RB validate VB object NN item NN if IN item NN instanceof NN long RB return NN long RB item NN throw VB new JJ schema NN exception NN root ROOT exception compound exception schema item NN is VBZ not RB a DT long RB return throw ANTONYM ANTONYM
FUNCTION SPECIFIER public TYPE long NAME long NAME read PARAMETER LIST byte buffer buffer PARAMETER byte buffer buffer TYPE byte buffer NAME byte buffer NAME buffer BLOCK RETURN return byte utils read varlong buffer EXPR byte utils read varlong buffer CALL byte utils read varlong buffer NAME byte utils read varlong NAME byte utils NAME read varlong ARGUMENT LIST ARGUMENT EXPR buffer NAME buffer public NN long RB read VB byte NN buffer NN root ROOT buffer compound buffer byte buffer NN return NN byte NN utils NNS read VBP varlong NN root ROOT read compound utils byte nsubj read utils dobj read varlong buffer NN
FUNCTION SPECIFIER public TYPE integer NAME integer NAME validate PARAMETER LIST object item PARAMETER object item TYPE object NAME object NAME item BLOCK IF if item instanceof integer return integer item CONDITION item instanceof integer EXPR item instanceof integer NAME item NAME integer THEN return integer item BLOCK RETURN return integer item EXPR integer item NAME integer NAME item THROW throw new schema exception item is not an integer EXPR new schema exception item is not an integer CALL schema exception item is not an integer NAME schema exception ARGUMENT LIST ARGUMENT EXPR item is not an integer NAME item public NN integer NN validate VB object NN item NN if IN item NN instanceof NN integer NN return NN integer NN item NN throw VB new JJ schema NN exception NN root ROOT exception compound exception schema item NN is VBZ not RB an DT integer NN return throw ANTONYM ANTONYM
COMMENT check whether there are any batches which haven t been drained FUNCTION SPECIFIER public TYPE boolean NAME boolean NAME has undrained PARAMETER LIST BLOCK FOR for map entry topic partition deque producer batch entry this batches entry set deque producer batch deque entry get value synchronized deque if deque is empty return true CONTROL map entry topic partition deque producer batch entry this batches entry set INIT map entry topic partition deque producer batch entry this batches entry set TYPE map entry topic partition deque producer batch NAME map entry topic partition deque producer batch NAME map NAME entry topic partition deque producer batch NAME entry ARGUMENT LIST ARGUMENT NAME topic partition ARGUMENT NAME deque producer batch NAME deque ARGUMENT LIST ARGUMENT NAME producer batch NAME entry RANGE this batches entry set EXPR this batches entry set CALL this batches entry set NAME this batches entry set NAME this NAME batches NAME entry set ARGUMENT LIST BLOCK DECL STMT TYPE deque producer batch NAME deque producer batch NAME deque ARGUMENT LIST ARGUMENT NAME producer batch NAME deque INIT entry get value EXPR entry get value CALL entry get value NAME entry get value NAME entry NAME get value ARGUMENT LIST SYNCHRONIZED synchronized deque if deque is empty return true INIT deque EXPR deque NAME deque BLOCK IF if deque is empty return true CONDITION deque is empty EXPR deque is empty CALL deque is empty NAME deque is empty NAME deque NAME is empty ARGUMENT LIST THEN return true BLOCK RETURN return true EXPR true RETURN return false EXPR false check whether there are any batches which haven t been drained root ROOT check mark are whether expl are there ccomp check are det batches any nsubj are batches dobj drained batches ref batches which compound t haven nsubjpass drained t auxpass drained been acl relcl batches drained public NN boolean NN has VBZ undrained VBN root ROOT undrained aux undrained has for IN map NN entry NN root ROOT entry compound entry map topic NN partition NN root ROOT partition compound partition topic deque NN producer NN batch NN root ROOT batch compound batch producer entry NN this DT batches NNS entry NN set NN deque NN producer NN batch NN root ROOT batch compound batch producer deque NN entry NN get VB value NN root ROOT get nsubj get entry dobj get value synchronized VBN deque NN if IN deque NN is VBZ empty JJ root ROOT empty nsubj empty deque cop empty is return NN true JJ return NN false JJ are map ANTONYM ANTONYM been map ANTONYM ANTONYM check return ANTONYM ANTONYM true false ANTONYM ANTONYM
COMMENT are there any threads currently waiting on a flush package private for test FUNCTION TYPE boolean NAME boolean NAME flush in progress PARAMETER LIST BLOCK RETURN return flushes in progress get EXPR flushes in progress get CALL flushes in progress get NAME flushes in progress get NAME flushes in progress NAME get ARGUMENT LIST are there any threads currently waiting on a flush root ROOT are expl are there det threads any nsubj are threads advmod waiting currently acl threads waiting case flush on det flush a nmod on waiting flush package private for test root ROOT package amod package private case test for nmod for private test boolean NN flush NN in IN progress NN root ROOT flush case progress in nmod in flush progress return NN flushes NNS in IN progress NN get VBP root ROOT get nsubj get flushes case progress in nmod in flushes progress return get ANTONYM ANTONYM threads get ANTONYM ANTONYM
COMMENT abort any batches which have not been drained FUNCTION TYPE void NAME void NAME abort undrained batches PARAMETER LIST runtime exception reason PARAMETER runtime exception reason TYPE runtime exception NAME runtime exception NAME reason BLOCK FOR for producer batch batch incomplete copy all deque producer batch dq get deque batch topic partition boolean aborted false synchronized dq if batch is closed aborted true batch abort record appends dq remove batch if aborted batch abort reason deallocate batch CONTROL producer batch batch incomplete copy all INIT producer batch batch incomplete copy all TYPE producer batch NAME producer batch NAME batch RANGE incomplete copy all EXPR incomplete copy all CALL incomplete copy all NAME incomplete copy all NAME incomplete NAME copy all ARGUMENT LIST BLOCK DECL STMT TYPE deque producer batch NAME deque producer batch NAME deque ARGUMENT LIST ARGUMENT NAME producer batch NAME dq INIT get deque batch topic partition EXPR get deque batch topic partition CALL get deque batch topic partition NAME get deque ARGUMENT LIST ARGUMENT EXPR batch topic partition NAME batch topic partition NAME batch NAME topic partition DECL STMT TYPE boolean NAME boolean NAME aborted INIT false EXPR false SYNCHRONIZED synchronized dq if batch is closed aborted true batch abort record appends dq remove batch INIT dq EXPR dq NAME dq BLOCK IF if batch is closed aborted true batch abort record appends dq remove batch CONDITION batch is closed EXPR batch is closed CALL batch is closed NAME batch is closed NAME batch NAME is closed ARGUMENT LIST THEN aborted true batch abort record appends dq remove batch BLOCK EXPR aborted true NAME aborted EXPR batch abort record appends CALL batch abort record appends NAME batch abort record appends NAME batch NAME abort record appends ARGUMENT LIST EXPR dq remove batch CALL dq remove batch NAME dq remove NAME dq NAME remove ARGUMENT LIST ARGUMENT EXPR batch NAME batch IF if aborted batch abort reason deallocate batch CONDITION aborted EXPR aborted NAME aborted THEN batch abort reason deallocate batch BLOCK EXPR batch abort reason CALL batch abort reason NAME batch abort NAME batch NAME abort ARGUMENT LIST ARGUMENT EXPR reason NAME reason EXPR deallocate batch CALL deallocate batch NAME deallocate ARGUMENT LIST ARGUMENT EXPR batch NAME batch abort any batches which have not been drained root ROOT abort det batches any dobj abort batches nsubjpass drained batches ref batches which aux drained have neg drained not auxpass drained been acl relcl batches drained void NN abort VB undrained JJ batches NNS root ROOT abort amod batches undrained dobj abort batches runtime NN exception NN root ROOT exception compound exception runtime reason NN for IN producer NN batch NN root ROOT batch compound batch producer batch NN incomplete JJ copy NN all DT root ROOT copy amod copy incomplete dep copy all deque NN producer NN batch NN root ROOT batch compound batch producer dq NN get VB deque NN root ROOT get dobj get deque batch NN topic NN partition NN root ROOT partition compound partition batch compound partition topic boolean NN aborted JJ false JJ synchronized VBN dq NN if IN batch NN is VBZ closed VBN root ROOT closed nsubjpass closed batch auxpass closed is aborted JJ true JJ batch NN abort NN record NN appends VBZ root ROOT appends compound record batch compound record abort nsubj appends record dq NN remove VB root ROOT remove nsubj remove dq batch NN if IN aborted JJ batch NN abort NN root ROOT abort compound abort batch reason NN deallocate NN batch NN false true ANTONYM ANTONYM have remove ANTONYM ANTONYM void false SYNONYM SYNONYM
COMMENT close this accumulator and force all the record buffers to be drained FUNCTION SPECIFIER public TYPE void NAME void NAME close PARAMETER LIST BLOCK EXPR this closed true NAME this closed NAME this NAME closed close this accumulator and force all the record buffers to be drained root ROOT accumulator advmod accumulator close det accumulator this cc accumulator and conj and accumulator force det predet buffers all det buffers the compound buffers record dobj force buffers nsubjpass xsubj drained buffers mark drained to auxpass drained be xcomp force drained public NN void NN close RB this DT closed VBD true JJ close public ANTONYM ANTONYM closed close ANTONYM ANTONYM close true SYNONYM SYNONYM
COMMENT closes the connection to a particular node if there is one all requests on the connection will be cleared client request callbacks will not be invoked for the cleared requests nor will they be returned from poll param node id the id of the node FUNCTION ANNOTATION override NAME override SPECIFIER public TYPE void NAME void NAME close PARAMETER LIST string node id PARAMETER string node id TYPE string NAME string NAME node id BLOCK EXPR selector close node id CALL selector close node id NAME selector close NAME selector NAME close ARGUMENT LIST ARGUMENT EXPR node id NAME node id FOR for in flight request request in flight requests clear all node id if request is internal request request header api key api keys metadata id metadata updater handle disconnection request destination CONTROL in flight request request in flight requests clear all node id INIT in flight request request in flight requests clear all node id TYPE in flight request NAME in flight request NAME request RANGE in flight requests clear all node id EXPR in flight requests clear all node id CALL in flight requests clear all node id NAME in flight requests clear all NAME in flight requests NAME clear all ARGUMENT LIST ARGUMENT EXPR node id NAME node id BLOCK IF if request is internal request request header api key api keys metadata id metadata updater handle disconnection request destination CONDITION request is internal request request header api key api keys metadata id EXPR request is internal request request header api key api keys metadata id NAME request is internal request NAME request NAME is internal request CALL request header api key NAME request header api key NAME request NAME header NAME api key ARGUMENT LIST NAME api keys metadata id NAME api keys NAME metadata NAME id THEN metadata updater handle disconnection request destination BLOCK EXPR metadata updater handle disconnection request destination CALL metadata updater handle disconnection request destination NAME metadata updater handle disconnection NAME metadata updater NAME handle disconnection ARGUMENT LIST ARGUMENT EXPR request destination NAME request destination NAME request NAME destination EXPR connection states remove node id CALL connection states remove node id NAME connection states remove NAME connection states NAME remove ARGUMENT LIST ARGUMENT EXPR node id NAME node id closes the connection to a particular node if there is one root ROOT closes det connection the dobj closes connection case node to det node a amod node particular nmod to connection node mark is if expl is there advcl if closes is nsubj is one all requests on the connection will be cleared client request callbacks will not be invoked root ROOT cleared det requests all nsubjpass cleared requests case connection on det connection the nmod on requests connection aux cleared will auxpass cleared be compound callbacks client compound callbacks request nsubjpass invoked callbacks aux invoked will neg invoked not auxpass invoked be ccomp cleared invoked all requests on the connection will be cleared client request callbacks will not be invoked root ROOT cleared det requests all nsubjpass cleared requests case connection on det connection the nmod on requests connection aux cleared will auxpass cleared be compound callbacks client compound callbacks request nsubjpass invoked callbacks aux invoked will neg invoked not auxpass invoked be ccomp cleared invoked for the cleared requests nor will they be returned from poll root ROOT requests case requests for det requests the amod requests cleared cc requests nor aux returned will nsubjpass returned they auxpass returned be conj nor requests returned case poll from nmod from returned poll param node id the id of the node root ROOT id compound node param nsubj id node det id the dobj id id case node of det node the nmod of id node override NN public NN void NN close RB string NN node NN id NN root ROOT id compound id node selector NN close NN root ROOT close compound close selector node NN id NN root ROOT id compound id node for IN in IN flight NN request NN root ROOT request case request in compound request flight request NN in IN flight NN requests NNS clear JJ all DT root ROOT requests case requests in compound requests flight amod requests clear dep clear all node NN id NN root ROOT id compound id node if IN request NN is VBZ internal JJ request NN root ROOT request nsubj request request cop request is amod request internal request NN header NN api NN key NN root ROOT key compound key request compound key header compound key api api NN keys NNS metadata JJ id NN root ROOT keys compound keys api amod id metadata dep keys id metadata NN updater NN handle VBP disconnection NN root ROOT handle compound updater metadata nsubj handle updater dobj handle disconnection request NN destination NN root ROOT destination compound destination request connection NN states NNS remove VB root ROOT remove compound states connection nsubj remove states node NN id NN root ROOT id compound id node cleared returned ANTONYM ANTONYM close destination ANTONYM ANTONYM closes destination ANTONYM ANTONYM public close ANTONYM ANTONYM particular close SYNONYM SYNONYM
COMMENT check if the node with the given id is ready to send more requests param node the node param now the current time in ms return true if the node is ready FUNCTION ANNOTATION override NAME override SPECIFIER public TYPE boolean NAME boolean NAME is ready PARAMETER LIST node node long now PARAMETER node node TYPE node NAME node NAME node PARAMETER long now TYPE long NAME long NAME now BLOCK COMMENT if we need to update our metadata now declare all requests unready to make metadata requests first COMMENT priority RETURN return metadata updater is update due now can send request node id string EXPR metadata updater is update due now can send request node id string CALL metadata updater is update due now NAME metadata updater is update due NAME metadata updater NAME is update due ARGUMENT LIST ARGUMENT EXPR now NAME now CALL can send request node id string NAME can send request ARGUMENT LIST ARGUMENT EXPR node id string CALL node id string NAME node id string NAME node NAME id string ARGUMENT LIST check if the node with the given id is ready to send more requests root ROOT check mark ready if det node the nsubj ready node nsubj xsubj send node case id with det id the amod id given nmod with node id cop ready is advcl if check ready mark send to xcomp ready send amod requests more dobj send requests param node the node root ROOT node compound node param det node the dep node node param now the current time in ms root ROOT time nsubj time param advmod time now det time the amod time current case ms in nmod in time ms return true if the node is ready root ROOT return amod return true mark ready if det node the nsubj ready node cop ready is advcl if true ready override NN public NN boolean NN is VBZ ready JJ root ROOT ready cop ready is node NN node NN long RB now RB if we need to update our metadata now declare all requests unready to make metadata requests first root ROOT need mark need if nsubj need we nsubj xsubj update we mark update to xcomp need update nmod poss metadata our dobj update metadata advmod declare now dep update declare det requests all dobj declare requests amod requests unready mark make to xcomp unready make compound requests metadata dobj make requests advmod make first priority return NN metadata NN updater NN is VBZ update VB due JJ root ROOT update compound updater metadata nsubj update updater aux update is xcomp update due now RB can MD send VB request NN root ROOT send aux send can dobj send request node NN id NN string NN root ROOT string compound string node compound string id check declare ANTONYM ANTONYM check given ANTONYM ANTONYM check make ANTONYM ANTONYM check return ANTONYM ANTONYM declare make ANTONYM ANTONYM given declare ANTONYM ANTONYM given need ANTONYM ANTONYM given ready ANTONYM ANTONYM given send ANTONYM ANTONYM is make ANTONYM ANTONYM need make ANTONYM ANTONYM ready unready ANTONYM ANTONYM requests need ANTONYM ANTONYM return make ANTONYM ANTONYM
COMMENT queue up the given request for sending requests can only be sent out to ready nodes param request the request param now the current timestamp FUNCTION ANNOTATION override NAME override SPECIFIER public TYPE void NAME void NAME send PARAMETER LIST client request request long now PARAMETER client request request TYPE client request NAME client request NAME request PARAMETER long now TYPE long NAME long NAME now BLOCK EXPR do send request false now CALL do send request false now NAME do send ARGUMENT LIST ARGUMENT EXPR request NAME request ARGUMENT EXPR false ARGUMENT EXPR now NAME now queue up the given request for sending requests can only be sent out to ready nodes root ROOT sent csubjpass sent queue compound prt queue up det request the amod request given dobj queue request mark sending for acl for request sending dobj sending requests aux sent can advmod sent only auxpass sent be compound prt sent out case nodes to amod nodes ready nmod to sent nodes queue up the given request for sending requests can only be sent out to ready nodes root ROOT sent csubjpass sent queue compound prt queue up det request the amod request given dobj queue request mark sending for acl for request sending dobj sending requests aux sent can advmod sent only auxpass sent be compound prt sent out case nodes to amod nodes ready nmod to sent nodes param request the request root ROOT request compound request param det request the dobj request request param now the current timestamp root ROOT timestamp compound timestamp param advmod timestamp now det timestamp the amod timestamp current override NN public NN void NN send VB client NN request NN root ROOT request compound request client request NN long RB now RB do VB send VB root ROOT send aux send do request NN false JJ now RB given false ANTONYM ANTONYM given ready ANTONYM ANTONYM given send ANTONYM ANTONYM given sending ANTONYM ANTONYM given sent ANTONYM ANTONYM up ready SYNONYM SYNONYM void false SYNONYM SYNONYM
COMMENT handle any disconnected connections param responses the list of responses that completed with the disconnection param now the current time FUNCTION SPECIFIER private TYPE void NAME void NAME handle disconnections PARAMETER LIST list client response responses long now PARAMETER list client response responses TYPE list client response NAME list client response NAME list ARGUMENT LIST ARGUMENT NAME client response NAME responses PARAMETER long now TYPE long NAME long NAME now BLOCK FOR for map entry string channel state entry this selector disconnected entry set string node entry get key log debug node disconnected node process disconnection responses node now entry get value CONTROL map entry string channel state entry this selector disconnected entry set INIT map entry string channel state entry this selector disconnected entry set TYPE map entry string channel state NAME map entry string channel state NAME map NAME entry string channel state NAME entry ARGUMENT LIST ARGUMENT NAME string ARGUMENT NAME channel state NAME entry RANGE this selector disconnected entry set EXPR this selector disconnected entry set CALL this selector disconnected NAME this selector disconnected NAME this NAME selector NAME disconnected ARGUMENT LIST CALL entry set NAME entry set ARGUMENT LIST BLOCK DECL STMT TYPE string NAME string NAME node INIT entry get key EXPR entry get key CALL entry get key NAME entry get key NAME entry NAME get key ARGUMENT LIST EXPR log debug node disconnected node CALL log debug node disconnected node NAME log debug NAME log NAME debug ARGUMENT LIST ARGUMENT EXPR node disconnected ARGUMENT EXPR node NAME node EXPR process disconnection responses node now entry get value CALL process disconnection responses node now entry get value NAME process disconnection ARGUMENT LIST ARGUMENT EXPR responses NAME responses ARGUMENT EXPR node NAME node ARGUMENT EXPR now NAME now ARGUMENT EXPR entry get value CALL entry get value NAME entry get value NAME entry NAME get value ARGUMENT LIST COMMENT we got a disconnect so we should probably refresh our metadata and see if that broker is dead IF if this selector disconnected size metadata updater request update CONDITION this selector disconnected size EXPR this selector disconnected size CALL this selector disconnected NAME this selector disconnected NAME this NAME selector NAME disconnected ARGUMENT LIST CALL size NAME size ARGUMENT LIST THEN metadata updater request update BLOCK EXPR metadata updater request update CALL metadata updater request update NAME metadata updater request update NAME metadata updater NAME request update ARGUMENT LIST handle any disconnected connections root ROOT handle det connections any amod connections disconnected dobj handle connections param responses the list of responses that completed with the disconnection root ROOT responses compound responses param det list the dep responses list case responses of nmod of list responses nsubj completed responses ref responses that acl relcl responses completed case disconnection with det disconnection the nmod with completed disconnection param now the current time root ROOT time nsubj time param advmod time now det time the amod time current private JJ void NN handle VB disconnections NNS root ROOT handle dobj handle disconnections list NN client NN response NN root ROOT response compound response client responses NNS long RB now RB for IN map NN entry NN root ROOT entry compound entry map string NN channel NN state NN root ROOT state compound state channel entry NN this DT selector NN disconnected VBD entry NN set NN root ROOT set compound set entry string NN node NN entry NN get VB key JJ root ROOT get nsubj get entry xcomp get key log NN debug NN root ROOT debug compound debug log node NN disconnected VBN node NN process NN disconnection NN root ROOT disconnection compound disconnection process responses NNS node NN now RB entry NN get VB value NN root ROOT get nsubj get entry dobj get value we got a disconnect so we should probably refresh our metadata and see if that broker is dead root ROOT got nsubj got we det disconnect a dobj got disconnect mark refresh so nsubj refresh we nsubj see we aux refresh should advmod refresh probably advcl so disconnect refresh nmod poss metadata our dobj refresh metadata cc refresh and advcl so disconnect see conj and refresh see mark dead if det broker that nsubj dead broker cop dead is advcl if see dead if IN this DT selector NN disconnected VBD size NN metadata NN updater NN request NN update VBP root ROOT update compound request metadata compound request updater nsubj update request connections disconnect ANTONYM ANTONYM connections disconnection ANTONYM ANTONYM current dead ANTONYM ANTONYM got see ANTONYM ANTONYM map is ANTONYM ANTONYM string got ANTONYM ANTONYM completed dead SYNONYM SYNONYM
FUNCTION SPECIFIER public TYPE isolation level NAME isolation level NAME isolation level PARAMETER LIST BLOCK RETURN return isolation level EXPR isolation level NAME isolation level public NN isolation NN level NN root ROOT level compound level isolation isolation NN level NN root ROOT level compound level isolation return NN isolation NN level NN root ROOT level compound level isolation
COMMENT request and partition level name DECL STMT SPECIFIER private SPECIFIER static TYPE final string SPECIFIER final NAME string NAME max bytes key name INIT max bytes EXPR max bytes request and partition level name root ROOT name compound name request cc request and conj and request partition compound name partition compound name level private JJ static JJ final JJ string NN max NN bytes NNS key JJ name NN root ROOT name compound name max compound name bytes amod name key max NN bytes NNS root ROOT bytes compound bytes max
COMMENT partition level field names DECL STMT SPECIFIER private SPECIFIER static TYPE final string SPECIFIER final NAME string NAME partition key name INIT partition EXPR partition partition level field names root ROOT names compound names partition compound names level compound names field private JJ static JJ final JJ string NN partition NN key JJ name NN root ROOT name compound name partition amod name key partition NN
CONSTRUCTOR public partition data long fetch offset long log start offset int max bytes this fetch offset fetch offset this log start offset log start offset this max bytes max bytes SPECIFIER public NAME partition data PARAMETER LIST long fetch offset long log start offset int max bytes PARAMETER long fetch offset TYPE long NAME long NAME fetch offset PARAMETER long log start offset TYPE long NAME long NAME log start offset PARAMETER int max bytes TYPE int NAME int NAME max bytes BLOCK EXPR this fetch offset fetch offset NAME this fetch offset NAME this NAME fetch offset NAME fetch offset EXPR this log start offset log start offset NAME this log start offset NAME this NAME log start offset NAME log start offset EXPR this max bytes max bytes NAME this max bytes NAME this NAME max bytes NAME max bytes public NN partition NN data NNS root ROOT data compound data partition long RB fetch VB offset VBN root ROOT fetch dep fetch offset long RB log NN start NN offset VBP root ROOT offset compound start log nsubj offset start int NN max NN bytes NNS root ROOT bytes compound bytes max this DT fetch VB offset VBN fetch VB offset VBN root ROOT fetch dep fetch offset this DT log NN start NN offset VBP log NN start NN offset VBP root ROOT offset compound start log nsubj offset start this DT max NN bytes NNS max NN bytes NNS root ROOT bytes compound bytes max
DECL STMT SPECIFIER private TYPE final map string list partition info SPECIFIER final NAME map string list partition info NAME map ARGUMENT LIST ARGUMENT NAME string ARGUMENT NAME list partition info NAME list ARGUMENT LIST ARGUMENT NAME partition info NAME available partitions by topic private JJ final JJ map NN string NN list NN partition NN info NN root ROOT info compound info partition available JJ partitions NNS by IN topic NN root ROOT partitions amod partitions available case topic by nmod by partitions topic
DECL STMT SPECIFIER private TYPE final map string list partition info SPECIFIER final NAME map string list partition info NAME map ARGUMENT LIST ARGUMENT NAME string ARGUMENT NAME list partition info NAME list ARGUMENT LIST ARGUMENT NAME partition info NAME partitions by topic private JJ final JJ map NN string NN list NN partition NN info NN root ROOT info compound info partition partitions NNS by IN topic NN root ROOT partitions case topic by nmod by partitions topic
DECL STMT SPECIFIER private TYPE final set string SPECIFIER final NAME set string NAME set ARGUMENT LIST ARGUMENT NAME string NAME internal topics private JJ final JJ set NN string NN internal JJ topics NNS root ROOT topics amod topics internal
COMMENT create an empty cluster instance with no nodes and no topic partitions FUNCTION SPECIFIER public SPECIFIER static TYPE cluster NAME cluster NAME empty PARAMETER LIST BLOCK RETURN return new cluster null new array list node new array list partition info collections string empty set collections string empty set null EXPR new cluster null new array list node new array list partition info collections string empty set collections string empty set null CALL cluster null new array list node new array list partition info collections string empty set collections string empty set null NAME cluster ARGUMENT LIST ARGUMENT EXPR null ARGUMENT EXPR new array list node CALL array list node NAME array list node NAME array list ARGUMENT LIST ARGUMENT NAME node ARGUMENT LIST ARGUMENT EXPR ARGUMENT EXPR new array list partition info CALL array list partition info NAME array list partition info NAME array list ARGUMENT LIST ARGUMENT NAME partition info ARGUMENT LIST ARGUMENT EXPR ARGUMENT EXPR collections string empty set NAME collections NAME collections NAME string CALL empty set NAME empty set ARGUMENT LIST ARGUMENT EXPR collections string empty set NAME collections NAME collections NAME string CALL empty set NAME empty set ARGUMENT LIST ARGUMENT EXPR null create an empty cluster instance with no nodes and no topic partitions root ROOT create det instance an amod instance empty compound instance cluster dobj create instance case nodes with neg nodes no nmod with instance nodes cc nodes and neg partitions no compound partitions topic nmod with instance partitions conj and nodes partitions public NN static JJ cluster NN empty JJ return NN new JJ cluster NN null JJ new JJ array NN list NN root ROOT list compound list array node NN new JJ array NN list NN root ROOT list compound list array partition NN info NN root ROOT info compound info partition collections NNS string NN empty JJ set NN root ROOT set amod set empty collections NNS string NN empty JJ set NN root ROOT set amod set empty null JJ empty null ANTONYM ANTONYM topic return ANTONYM ANTONYM
COMMENT return a copy of this cluster combined with partitions FUNCTION SPECIFIER public TYPE cluster NAME cluster NAME with partitions PARAMETER LIST map topic partition partition info partitions PARAMETER map topic partition partition info partitions TYPE map topic partition partition info NAME map topic partition partition info NAME map ARGUMENT LIST ARGUMENT NAME topic partition ARGUMENT NAME partition info NAME partitions BLOCK DECL STMT TYPE map topic partition partition info NAME map topic partition partition info NAME map ARGUMENT LIST ARGUMENT NAME topic partition ARGUMENT NAME partition info NAME combined partitions INIT new hash map this partitions by topic partition EXPR new hash map this partitions by topic partition CALL hash map this partitions by topic partition NAME hash map NAME hash map ARGUMENT LIST ARGUMENT LIST ARGUMENT EXPR this partitions by topic partition NAME this partitions by topic partition NAME this NAME partitions by topic partition EXPR combined partitions put all partitions CALL combined partitions put all partitions NAME combined partitions put all NAME combined partitions NAME put all ARGUMENT LIST ARGUMENT EXPR partitions NAME partitions RETURN return new cluster cluster resource cluster id this nodes combined partitions values new hash set this unauthorized topics new hash set this internal topics this controller EXPR new cluster cluster resource cluster id this nodes combined partitions values new hash set this unauthorized topics new hash set this internal topics this controller CALL cluster cluster resource cluster id this nodes combined partitions values new hash set this unauthorized topics new hash set this internal topics this controller NAME cluster ARGUMENT LIST ARGUMENT EXPR cluster resource cluster id CALL cluster resource cluster id NAME cluster resource cluster id NAME cluster resource NAME cluster id ARGUMENT LIST ARGUMENT EXPR this nodes NAME this nodes NAME this NAME nodes ARGUMENT EXPR combined partitions values CALL combined partitions values NAME combined partitions values NAME combined partitions NAME values ARGUMENT LIST ARGUMENT EXPR new hash set this unauthorized topics CALL hash set this unauthorized topics NAME hash set NAME hash set ARGUMENT LIST ARGUMENT LIST ARGUMENT EXPR this unauthorized topics NAME this unauthorized topics NAME this NAME unauthorized topics ARGUMENT EXPR new hash set this internal topics CALL hash set this internal topics NAME hash set NAME hash set ARGUMENT LIST ARGUMENT LIST ARGUMENT EXPR this internal topics NAME this internal topics NAME this NAME internal topics ARGUMENT EXPR this controller NAME this controller NAME this NAME controller return a copy of this cluster combined with partitions root ROOT return det copy a dobj return copy case cluster of det cluster this nmod of copy cluster acl copy combined case partitions with nmod with combined partitions public NN cluster NN with IN partitions NNS root ROOT partitions case partitions with map NN topic NN partition NN root ROOT partition compound partition topic partition NN info NN root ROOT info compound info partition partitions NNS map NN topic NN partition NN root ROOT partition compound partition topic partition NN info NN root ROOT info compound info partition combined VBN partitions NNS root ROOT partitions amod partitions combined new JJ hash VB map NN root ROOT hash dobj hash map this DT partitions NNS by IN topic NN partition NN combined VBN partitions NNS put VBD all DT root ROOT put amod partitions combined nsubj put partitions dobj put all partitions NNS return NN new JJ cluster NN cluster NN resource NN cluster NN id NN root ROOT id compound id cluster compound id resource compound id cluster this DT nodes NNS combined JJ partitions NNS values NNS root ROOT values amod values combined compound values partitions new JJ hash JJ set NN root ROOT set amod set hash this DT unauthorized JJ topics NNS new JJ hash JJ set NN root ROOT set amod set hash this DT internal JJ topics NNS this DT controller NN
COMMENT return the known set of nodes FUNCTION SPECIFIER public TYPE list node NAME list node NAME list ARGUMENT LIST ARGUMENT NAME node NAME nodes PARAMETER LIST BLOCK RETURN return this nodes EXPR this nodes NAME this nodes NAME this NAME nodes return the known set of nodes root ROOT return det set the amod set known dobj return set case nodes of nmod of set nodes public NN list NN node NN nodes NNS return NN this DT nodes NNS
FUNCTION SPECIFIER public TYPE set string NAME set string NAME set ARGUMENT LIST ARGUMENT NAME string NAME internal topics PARAMETER LIST BLOCK RETURN return internal topics EXPR internal topics NAME internal topics public NN set NN string NN internal JJ topics NNS root ROOT topics amod topics internal return NN internal JJ topics NNS root ROOT topics amod topics internal
FUNCTION SPECIFIER public TYPE node NAME node NAME controller PARAMETER LIST BLOCK RETURN return controller EXPR controller NAME controller public NN node NN controller NN return NN controller NN
FUNCTION SPECIFIER protected TYPE void NAME void NAME update PARAMETER LIST sample sample metric config config double value long now PARAMETER sample sample TYPE sample NAME sample NAME sample PARAMETER metric config config TYPE metric config NAME metric config NAME config PARAMETER double value TYPE double NAME double NAME value PARAMETER long now TYPE long NAME long NAME now BLOCK EXPR sample value NAME sample value NAME sample NAME value protected VBN void NN update VB sample NN sample NN metric JJ config NN root ROOT config amod config metric config NN double RB value NN long RB now RB sample NN value NN root ROOT value compound value sample
FUNCTION SPECIFIER public TYPE double NAME double NAME combine PARAMETER LIST list sample samples metric config config long now PARAMETER list sample samples TYPE list sample NAME list sample NAME list ARGUMENT LIST ARGUMENT NAME sample NAME samples PARAMETER metric config config TYPE metric config NAME metric config NAME config PARAMETER long now TYPE long NAME long NAME now BLOCK DECL STMT TYPE double NAME double NAME total INIT EXPR FOR for sample sample samples total sample value CONTROL sample sample samples INIT sample sample samples TYPE sample NAME sample NAME sample RANGE samples EXPR samples NAME samples BLOCK EXPR total sample value NAME total NAME sample value NAME sample NAME value RETURN return total EXPR total NAME total public NN double RB combine VB list NN sample NN samples NNS metric JJ config NN root ROOT config amod config metric config NN long RB now RB double RB total NN for IN sample NN sample NN samples NNS total NN sample NN value NN root ROOT value compound value sample return NN total NN list total ANTONYM ANTONYM
CONSTRUCTOR public count super SPECIFIER public NAME count PARAMETER LIST BLOCK EXPR super CALL super NAME super ARGUMENT LIST ARGUMENT EXPR public NN count NN super JJ
CONSTRUCTOR public record metadata topic partition topic partition long base offset long relative offset long timestamp long checksum int serialized key size int serialized value size ignore the relative offset if the base offset is since this indicates the offset is unknown this offset base offset base offset base offset relative offset this timestamp timestamp this checksum checksum this serialized key size serialized key size this serialized value size serialized value size this topic partition topic partition SPECIFIER public NAME record metadata PARAMETER LIST topic partition topic partition long base offset long relative offset long timestamp long checksum int serialized key size int serialized value size PARAMETER topic partition topic partition TYPE topic partition NAME topic partition NAME topic partition PARAMETER long base offset TYPE long NAME long NAME base offset PARAMETER long relative offset TYPE long NAME long NAME relative offset PARAMETER long timestamp TYPE long NAME long NAME timestamp PARAMETER long checksum TYPE long NAME long NAME checksum PARAMETER int serialized key size TYPE int NAME int NAME serialized key size PARAMETER int serialized value size TYPE int NAME int NAME serialized value size BLOCK COMMENT ignore the relative offset if the base offset is COMMENT since this indicates the offset is unknown EXPR this offset base offset base offset base offset relative offset NAME this offset NAME this NAME offset TERNARY base offset base offset base offset relative offset CONDITION base offset EXPR base offset NAME base offset THEN base offset EXPR base offset NAME base offset ELSE base offset relative offset EXPR base offset relative offset NAME base offset NAME relative offset EXPR this timestamp timestamp NAME this timestamp NAME this NAME timestamp NAME timestamp EXPR this checksum checksum NAME this checksum NAME this NAME checksum NAME checksum EXPR this serialized key size serialized key size NAME this serialized key size NAME this NAME serialized key size NAME serialized key size EXPR this serialized value size serialized value size NAME this serialized value size NAME this NAME serialized value size NAME serialized value size EXPR this topic partition topic partition NAME this topic partition NAME this NAME topic partition NAME topic partition public NN record NN metadata NN root ROOT metadata compound metadata record topic NN partition NN root ROOT partition compound partition topic topic NN partition NN root ROOT partition compound partition topic long RB base NN offset VBD root ROOT offset nsubj offset base long RB relative JJ offset VBN root ROOT relative dep relative offset long RB timestamp NN long RB checksum NN int NN serialized VBN key JJ size NN root ROOT serialized amod size key dobj serialized size int NN serialized VBN value NN size NN root ROOT size amod size serialized compound size value ignore the relative offset if the base offset is root ROOT ignore det offset the amod offset relative dobj ignore offset mark is if det base the nsubj is base acl base offset advcl if offset is since this indicates the offset is unknown root ROOT indicates mark indicates since nsubj indicates this det offset the nsubj unknown offset cop unknown is ccomp indicates unknown this DT offset VBN base NN offset VBD root ROOT offset nsubj offset base base NN offset VBD root ROOT offset nsubj offset base base NN offset VBD root ROOT offset nsubj offset base relative JJ offset VBN root ROOT relative dep relative offset this DT timestamp NN timestamp NN this DT checksum NN checksum NN this DT serialized VBD key JJ size NN serialized VBN key JJ size NN root ROOT serialized amod size key dobj serialized size this DT serialized VBN value NN size NN serialized VBN value NN size NN root ROOT size amod size serialized compound size value this DT topic NN partition NN topic NN partition NN root ROOT partition compound partition topic unknown base ANTONYM ANTONYM
COMMENT the partition the record was sent to FUNCTION SPECIFIER public TYPE int NAME int NAME partition PARAMETER LIST BLOCK RETURN return this topic partition partition EXPR this topic partition partition CALL this topic partition partition NAME this topic partition partition NAME this NAME topic partition NAME partition ARGUMENT LIST the partition the record was sent to root ROOT partition det partition the det record the nsubjpass sent record auxpass sent was acl relcl partition sent nmod sent to public NN int NN partition NN return NN this DT topic NN partition NN partition NN
DECL STMT SPECIFIER private TYPE final int SPECIFIER final NAME int NAME serialized key size private JJ final JJ int NN serialized VBN key JJ size NN root ROOT serialized amod size key dobj serialized size
FUNCTION SPECIFIER public TYPE boolean NAME boolean NAME is complete PARAMETER LIST BLOCK RETURN return complete EXPR complete NAME complete public NN boolean NN is VBZ complete JJ root ROOT complete cop complete is return NN complete JJ
DECL STMT SPECIFIER private SPECIFIER static TYPE final string SPECIFIER final NAME string NAME jaas user prefix INIT user EXPR user private JJ static JJ final JJ string NN jaas NN user NN prefix NN root ROOT prefix compound prefix jaas compound prefix user user NN
FUNCTION ANNOTATION override NAME override SPECIFIER public TYPE string NAME string NAME get mechanism name PARAMETER LIST BLOCK RETURN return plain mechanism EXPR plain mechanism NAME plain mechanism override NN public NN string NN get VB mechanism NN name NN root ROOT get compound name mechanism dobj get name return NN plain RB mechanism NN root ROOT mechanism advmod mechanism plain
COMMENT visits this node then the test expression the true expression and the false expression FUNCTION ANNOTATION override NAME override SPECIFIER public TYPE void NAME void NAME visit PARAMETER LIST node visitor v PARAMETER node visitor v TYPE node visitor NAME node visitor NAME v BLOCK IF if v visit this test expression visit v true expression visit v false expression visit v CONDITION v visit this EXPR v visit this CALL v visit this NAME v visit NAME v NAME visit ARGUMENT LIST ARGUMENT EXPR this NAME this THEN test expression visit v true expression visit v false expression visit v BLOCK EXPR test expression visit v CALL test expression visit v NAME test expression visit NAME test expression NAME visit ARGUMENT LIST ARGUMENT EXPR v NAME v EXPR true expression visit v CALL true expression visit v NAME true expression visit NAME true expression NAME visit ARGUMENT LIST ARGUMENT EXPR v NAME v EXPR false expression visit v CALL false expression visit v NAME false expression visit NAME false expression NAME visit ARGUMENT LIST ARGUMENT EXPR v NAME v visits this node then the test expression the true expression root ROOT visits det node this dobj visits node advmod expression then det expression the compound expression test nmod node expression det expression the amod expression true dep expression expression and the false expression root ROOT expression cc expression and det expression the amod expression false override NN public NN void NN visit NN node NN visitor NN root ROOT visitor compound visitor node v LS if IN v LS visit NN root ROOT v root v visit this DT test NN expression NN visit NN root ROOT visit compound visit test compound visit expression v LS true JJ expression NN visit NN root ROOT visit amod visit true compound visit expression v LS false JJ expression NN visit NN root ROOT visit amod expression false nsubj visit expression v LS true false ANTONYM ANTONYM false void SYNONYM SYNONYM
FUNCTION ANNOTATION override NAME override SPECIFIER public TYPE boolean NAME boolean NAME has side effects PARAMETER LIST BLOCK IF if test expression null true expression null false expression null code bug CONDITION test expression null true expression null false expression null EXPR test expression null true expression null false expression null NAME test expression NAME true expression NAME false expression THEN code bug BLOCK EXPR code bug CALL code bug NAME code bug ARGUMENT LIST RETURN return true expression has side effects false expression has side effects EXPR true expression has side effects false expression has side effects CALL true expression has side effects NAME true expression has side effects NAME true expression NAME has side effects ARGUMENT LIST CALL false expression has side effects NAME false expression has side effects NAME false expression NAME has side effects ARGUMENT LIST override NN public NN boolean NN has VBZ side JJ effects NNS root ROOT has amod effects side dobj has effects if IN test NN expression NN root ROOT expression compound expression test null JJ true JJ expression NN root ROOT expression amod expression true null JJ false JJ expression NN root ROOT expression amod expression false null JJ code NN bug NN root ROOT bug compound bug code return NN true JJ expression NN has VBZ side JJ effects NNS root ROOT has amod expression true nsubj has expression amod effects side dobj has effects false JJ expression NN has VBZ side JJ effects NNS root ROOT has amod expression false nsubj has expression amod effects side dobj has effects
COMMENT sets position of token param colon position position of token FUNCTION SPECIFIER public TYPE void NAME void NAME set colon position PARAMETER LIST int colon position PARAMETER int colon position TYPE int NAME int NAME colon position BLOCK EXPR this colon position colon position NAME this colon position NAME this NAME colon position NAME colon position sets position of token root ROOT position compound position sets case token of nmod of position token param colon position position of token root ROOT position compound position param compound position colon compound position position case token of nmod of position token public NN void NN set VBN colon NN position NN root ROOT set compound position colon dobj set position int NN colon NN position NN root ROOT position compound position colon this DT colon NN position NN colon NN position NN root ROOT position compound position colon
COMMENT returns position of token FUNCTION SPECIFIER public TYPE int NAME int NAME get colon position PARAMETER LIST BLOCK RETURN return colon position EXPR colon position NAME colon position returns position of token root ROOT position compound position returns case token of nmod of position token public NN int NN get VB colon NN position NN root ROOT get compound position colon dobj get position return NN colon NN position NN root ROOT position compound position colon
CONSTRUCTOR public conditional expression int pos super pos SPECIFIER public NAME conditional expression PARAMETER LIST int pos PARAMETER int pos TYPE int NAME int NAME pos BLOCK EXPR super pos CALL super pos NAME super ARGUMENT LIST ARGUMENT EXPR pos NAME pos public NN conditional JJ expression NN root ROOT expression amod expression conditional int NN pos NNS super JJ pos NNS
DECL STMT SPECIFIER private TYPE ast node NAME ast node NAME false expression private JJ ast IN node NN root ROOT node case node ast false JJ expression NN root ROOT expression amod expression false
CONSTRUCTOR public live connect drv string args super args set suffix class SPECIFIER public NAME live connect drv PARAMETER LIST string args PARAMETER string args TYPE string NAME string NAME string INDEX NAME args BLOCK EXPR super args CALL super args NAME super ARGUMENT LIST ARGUMENT EXPR args NAME args EXPR set suffix class CALL set suffix class NAME set suffix ARGUMENT LIST ARGUMENT EXPR class public NN live JJ connect VB drv NN root ROOT live dep live connect dobj connect drv string NN args NNS super JJ args NNS set VBN suffix NN root ROOT set dobj set suffix class NN
FUNCTION SPECIFIER public SPECIFIER static TYPE void NAME void NAME main PARAMETER LIST string args PARAMETER string args TYPE string NAME string NAME string INDEX NAME args BLOCK DECL STMT TYPE live connect drv NAME live connect drv NAME d INIT new live connect drv args EXPR new live connect drv args CALL live connect drv args NAME live connect drv ARGUMENT LIST ARGUMENT EXPR args NAME args EXPR d start CALL d start NAME d start NAME d NAME start ARGUMENT LIST public NN static JJ void NN main JJ string NN args NNS live JJ connect VB drv NN root ROOT live dep live connect dobj connect drv d NN new JJ live JJ connect VB drv NN root ROOT live dep live connect dobj connect drv args NNS d NN start NN root ROOT start compound start d
COMMENT read the contents of a file into a string FUNCTION SPECIFIER public SPECIFIER static TYPE string NAME string NAME read file PARAMETER LIST string file path PARAMETER string file path TYPE string NAME string NAME file path BLOCK DECL STMT TYPE file NAME file NAME js file INIT new file file path EXPR new file file path CALL file file path NAME file ARGUMENT LIST ARGUMENT EXPR file path NAME file path DECL STMT TYPE int NAME int NAME length INIT new long js file length int value EXPR new long js file length int value CALL long js file length NAME long ARGUMENT LIST ARGUMENT EXPR js file length CALL js file length NAME js file length NAME js file NAME length ARGUMENT LIST CALL int value NAME int value ARGUMENT LIST DECL STMT TYPE byte NAME byte NAME byte INDEX NAME b INIT new byte length EXPR new byte length NAME byte length NAME byte INDEX length EXPR length NAME length DECL STMT TYPE string buffer NAME string buffer NAME contents INIT new string buffer EXPR new string buffer CALL string buffer NAME string buffer ARGUMENT LIST TRY try file input stream fis new file input stream js file int read fis read b contents append new string b catch exception e p e to string BLOCK DECL STMT TYPE file input stream NAME file input stream NAME fis INIT new file input stream js file EXPR new file input stream js file CALL file input stream js file NAME file input stream ARGUMENT LIST ARGUMENT EXPR js file NAME js file DECL STMT TYPE int NAME int NAME read INIT fis read b EXPR fis read b CALL fis read b NAME fis read NAME fis NAME read ARGUMENT LIST ARGUMENT EXPR b NAME b EXPR contents append new string b CALL contents append new string b NAME contents append NAME contents NAME append ARGUMENT LIST ARGUMENT EXPR new string b CALL string b NAME string ARGUMENT LIST ARGUMENT EXPR b NAME b CATCH catch exception e p e to string PARAMETER LIST exception e PARAMETER exception e TYPE exception NAME exception NAME e BLOCK EXPR p e to string CALL p e to string NAME p ARGUMENT LIST ARGUMENT EXPR e to string CALL e to string NAME e to string NAME e NAME to string ARGUMENT LIST RETURN return contents to string EXPR contents to string CALL contents to string NAME contents to string NAME contents NAME to string ARGUMENT LIST read the contents of a file into a string root ROOT read det contents the dobj read contents case file of det file a nmod of contents file case string into det string a nmod into read string public NN static JJ string NN read VB file NN root ROOT read dobj read file string NN file NN path NN root ROOT path compound path file file NN js NN file NN root ROOT file compound file js new JJ file NN file NN path NN root ROOT path compound path file int NN length NN new JJ long RB js NN file NN length NN root ROOT length compound length js compound length file int NN value NN root ROOT value compound value int byte NN b NN new JJ byte NN length NN string NN buffer NN root ROOT buffer compound buffer string contents NNS new JJ string NN buffer NN root ROOT buffer compound buffer string try VB file NN input NN stream NN root ROOT stream compound stream file compound stream input fis NN new JJ file NN input NN stream NN root ROOT stream compound stream file compound stream input js NN file NN root ROOT file compound file js int NN read VB fis NN read NN root ROOT read compound read fis b NN contents NNS append VBP root ROOT append nsubj append contents new JJ string NN b NN catch NN exception NN e SYM p NN e LS to TO string VB root ROOT string dep string e mark string to return NN contents NNS to TO string VB root ROOT contents mark string to acl to contents string read file ANTONYM ANTONYM try return ANTONYM ANTONYM
COMMENT temporary stop this thread for seconds FUNCTION SPECIFIER public TYPE boolean NAME boolean NAME sleep PARAMETER LIST int ms PARAMETER int ms TYPE int NAME int NAME ms BLOCK TRY try thread sleep catch exception e p sleep failed e return false BLOCK EXPR thread sleep CALL thread sleep NAME thread sleep NAME thread NAME sleep ARGUMENT LIST ARGUMENT EXPR CATCH catch exception e p sleep failed e return false PARAMETER LIST exception e PARAMETER exception e TYPE exception NAME exception NAME e BLOCK EXPR p sleep failed e CALL p sleep failed e NAME p ARGUMENT LIST ARGUMENT EXPR sleep failed e NAME e RETURN return false EXPR false RETURN return true EXPR true temporary stop this thread for seconds root ROOT stop amod stop temporary det thread this dep stop thread case seconds for nmod for thread seconds public NN boolean NN sleep NN int NN ms NNS try VB thread NN sleep NN root ROOT sleep compound sleep thread catch NN exception NN e SYM p NN sleep NN failed VBD e SYM return NN false JJ return NN true JJ failed return ANTONYM ANTONYM false true ANTONYM ANTONYM stop catch ANTONYM ANTONYM stop failed ANTONYM ANTONYM stop return ANTONYM ANTONYM try return ANTONYM ANTONYM
DECL STMT TYPE file NAME file NAME test directory file NN test NN directory NN root ROOT directory compound directory test
COMMENT generates code to wrap java arguments into object non primitive java types are left as is pending conversion in the helper method leaves the array object on the top of the stack FUNCTION SPECIFIER static TYPE void NAME void NAME generate push wrapped args PARAMETER LIST class file writer cfw class arg types int array length PARAMETER class file writer cfw TYPE class file writer NAME class file writer NAME cfw PARAMETER class arg types TYPE class NAME class NAME class NAME class ARGUMENT LIST ARGUMENT NAME INDEX NAME arg types PARAMETER int array length TYPE int NAME int NAME array length BLOCK COMMENT push arguments EXPR cfw add push array length CALL cfw add push array length NAME cfw add push NAME cfw NAME add push ARGUMENT LIST ARGUMENT EXPR array length NAME array length EXPR cfw add byte code anewarray java lang object CALL cfw add byte code anewarray java lang object NAME cfw add NAME cfw NAME add ARGUMENT LIST ARGUMENT EXPR byte code anewarray NAME byte code anewarray NAME byte code NAME anewarray ARGUMENT EXPR java lang object DECL STMT TYPE int NAME int NAME param offset INIT EXPR FOR for int i i arg types length i cfw add byte code dup duplicate array reference cfw add push i param offset generate wrap arg cfw param offset arg types i cfw add byte code aastore CONTROL int i i arg types length i INIT int i TYPE int NAME int NAME i INIT EXPR CONDITION i arg types length EXPR i arg types length NAME i NAME arg types length NAME arg types NAME length INCR i EXPR i NAME i BLOCK EXPR cfw add byte code dup CALL cfw add byte code dup NAME cfw add NAME cfw NAME add ARGUMENT LIST ARGUMENT EXPR byte code dup NAME byte code dup NAME byte code NAME dup COMMENT duplicate array reference EXPR cfw add push i CALL cfw add push i NAME cfw add push NAME cfw NAME add push ARGUMENT LIST ARGUMENT EXPR i NAME i EXPR param offset generate wrap arg cfw param offset arg types i NAME param offset CALL generate wrap arg cfw param offset arg types i NAME generate wrap arg ARGUMENT LIST ARGUMENT EXPR cfw NAME cfw ARGUMENT EXPR param offset NAME param offset ARGUMENT EXPR arg types i NAME arg types i NAME arg types INDEX i EXPR i NAME i EXPR cfw add byte code aastore CALL cfw add byte code aastore NAME cfw add NAME cfw NAME add ARGUMENT LIST ARGUMENT EXPR byte code aastore NAME byte code aastore NAME byte code NAME aastore generates code to wrap java arguments into object root ROOT generates dobj generates code mark wrap to advcl to generates wrap compound arguments java dobj wrap arguments case object into nmod into wrap object non primitive java types are left as is pending conversion root ROOT left amod types non amod types primitive compound types java nsubjpass left types auxpass left are advmod conversion as cop conversion is amod conversion pending ccomp left conversion in the helper method leaves the array object on the top of the stack root ROOT leaves case method in det method the compound method helper nmod in leaves method det object the compound object array dobj leaves object case top on det top the nmod on leaves top case the of nmod of top the dep leaves stack in the helper method leaves the array object on the top of the stack root ROOT leaves case method in det method the compound method helper nmod in leaves method det object the compound object array dobj leaves object case top on det top the nmod on leaves top case the of nmod of top the dep leaves stack static JJ void NN generate VB push NN wrapped VBN args NNS root ROOT generate compound args push amod args wrapped dobj generate args class NN file NN writer NN root ROOT writer compound writer class compound writer file cfw NN class NN arg NN types NNS root ROOT types compound types arg int NN array NN length NN root ROOT length compound length array push arguments root ROOT arguments compound arguments push cfw NN add VB push NN root ROOT add nsubj add cfw dobj add push array NN length NN root ROOT length compound length array cfw NN add VB root ROOT add nsubj add cfw byte NN code NN anewarray NN root ROOT anewarray compound anewarray byte compound anewarray code java NN lang NN object NN root ROOT object compound object java compound object lang int NN param NN offset VBD root ROOT offset nsubj offset param for IN int NN i LS i LS arg NN types NNS length NN root ROOT length compound types arg nsubj length types i LS cfw NN add VB root ROOT add nsubj add cfw byte NN code NN dup NN root ROOT dup compound dup byte compound dup code duplicate VB array NN reference NN cfw NN add VB push NN root ROOT add nsubj add cfw dobj add push i LS param NN offset VBD root ROOT offset nsubj offset param generate VB wrap NN arg IN root ROOT generate dobj generate wrap dep generate arg cfw NN param NN offset VBD root ROOT offset nsubj offset param arg NN types NNS root ROOT types compound types arg i LS cfw NN add VB root ROOT add nsubj add cfw byte NN code NN aastore NN root ROOT aastore compound aastore byte compound aastore code generates leaves ANTONYM ANTONYM generates left ANTONYM ANTONYM leaves add ANTONYM ANTONYM leaves top ANTONYM ANTONYM left add ANTONYM ANTONYM left top ANTONYM ANTONYM types reference ANTONYM ANTONYM
DECL STMT SPECIFIER private SPECIFIER static TYPE final int SPECIFIER final NAME int NAME id java adapter INIT EXPR private JJ static JJ final JJ int NN id NN java NN adapter NN root ROOT adapter compound adapter id compound adapter java
DECL STMT TYPE class NAME class NAME class NAME class ARGUMENT LIST ARGUMENT NAME INDEX NAME interfaces class NN interfaces NNS
FUNCTION NAME java adapter signature PARAMETER LIST class super class class interfaces obj to int map names PARAMETER class super class TYPE class NAME class NAME class ARGUMENT LIST ARGUMENT NAME NAME super class PARAMETER class interfaces TYPE class NAME class NAME class NAME class ARGUMENT LIST ARGUMENT NAME INDEX NAME interfaces PARAMETER obj to int map names TYPE obj to int map NAME obj to int map NAME names BLOCK EXPR this super class super class NAME this super class NAME this NAME super class NAME super class EXPR this interfaces interfaces NAME this interfaces NAME this NAME interfaces NAME interfaces EXPR this names names NAME this names NAME this NAME names NAME names  java NN adapter NN signature NN root ROOT signature compound signature java compound signature adapter class NN super JJ class NN root ROOT class amod class super class NN interfaces NNS obj NN to TO int VB map NN root ROOT obj mark int to acl to obj int dobj int map names NNS this DT super JJ class NN super JJ class NN root ROOT class amod class super this DT interfaces NNS interfaces NNS this DT names NNS names NNS
FUNCTION ANNOTATION override NAME override SPECIFIER public TYPE int NAME int NAME hash code PARAMETER LIST BLOCK RETURN return super class hash code arrays hash code interfaces names size EXPR super class hash code arrays hash code interfaces names size CALL super class hash code NAME super class hash code NAME super class NAME hash code ARGUMENT LIST CALL arrays hash code interfaces NAME arrays hash code NAME arrays NAME hash code ARGUMENT LIST ARGUMENT EXPR interfaces NAME interfaces CALL names size NAME names size NAME names NAME size ARGUMENT LIST override NN public NN int NN hash VB code NN root ROOT hash dobj hash code return NN super JJ class NN hash NN code NN root ROOT code amod code super compound code class compound code hash arrays NNS hash VBP code NN root ROOT hash nsubj hash arrays dobj hash code interfaces NNS names NNS size NN root ROOT size compound size names
COMMENT change the value of the internal flag that determines whether all storage is handed by a dense backing array rather than an associative store param dense only new value for dense only flag throws illegal argument exception if an attempt is made to enable dense only after it was disabled native array code is not written to handle switching back to a dense representation FUNCTION TYPE void NAME void NAME set dense only PARAMETER LIST boolean dense only PARAMETER boolean dense only TYPE boolean NAME boolean NAME dense only BLOCK IF if dense only this dense only throw new illegal argument exception CONDITION dense only this dense only EXPR dense only this dense only NAME dense only NAME this dense only NAME this NAME dense only THEN throw new illegal argument exception BLOCK THROW throw new illegal argument exception EXPR new illegal argument exception CALL illegal argument exception NAME illegal argument exception ARGUMENT LIST EXPR this dense only dense only NAME this dense only NAME this NAME dense only NAME dense only change the value of the internal flag that determines whether all root ROOT change det value the dobj change value case flag of det flag the amod flag internal nmod of value flag nsubj determines flag ref flag that acl relcl flag determines dobj determines whether det whether all storage is handed by a dense backing array rather than an associative root ROOT handed nsubjpass handed storage auxpass handed is case array by det array a amod array dense compound array backing nmod agent handed array cc array rather mwe rather than det associative an nmod agent handed associative conj negcc array associative store param dense only new value for dense only flag root ROOT value compound value param amod value dense advmod value only amod value new case flag for amod flag dense amod flag only nmod for value flag throws illegal argument exception if an attempt is made to enable root ROOT throws amod exception illegal compound exception argument dobj throws exception mark made if det attempt an nsubjpass made attempt nsubj xsubj enable attempt auxpass made is advcl if throws made mark enable to xcomp made enable dense only after it was disabled native array code is not written root ROOT written advmod written dense advmod code only mark code after nsubj code it cop code was amod code disabled amod code native compound code array nsubjpass written code auxpass written is neg written not to handle switching back to a dense representation root ROOT handle mark handle to dobj handle switching advmod handle back case representation to det representation a amod representation dense nmod to back representation void NN set VBN dense JJ only RB root ROOT set xcomp set dense advmod set only boolean NN dense JJ only RB root ROOT dense advmod dense only if IN dense JJ only RB root ROOT dense advmod dense only this DT dense JJ only RB throw VB new JJ illegal JJ argument NN exception NN root ROOT exception amod exception illegal compound exception argument this DT dense JJ only RB dense JJ only RB root ROOT dense advmod dense only change throw ANTONYM ANTONYM change throws ANTONYM ANTONYM determines made ANTONYM ANTONYM enable disabled ANTONYM ANTONYM handed made ANTONYM ANTONYM handed throw ANTONYM ANTONYM handed throws ANTONYM ANTONYM is made ANTONYM ANTONYM made switching ANTONYM ANTONYM made was ANTONYM ANTONYM
FUNCTION SPECIFIER private SPECIFIER static TYPE void NAME void NAME define elem PARAMETER LIST context cx scriptable target long index object value PARAMETER context cx TYPE context NAME context NAME cx PARAMETER scriptable target TYPE scriptable NAME scriptable NAME target PARAMETER long index TYPE long NAME long NAME index PARAMETER object value TYPE object NAME object NAME value BLOCK IF if index integer max value string id long to string index target put id target value else target put int index target value CONDITION index integer max value EXPR index integer max value NAME index NAME integer max value NAME integer NAME max value THEN string id long to string index target put id target value BLOCK DECL STMT TYPE string NAME string NAME id INIT long to string index EXPR long to string index CALL long to string index NAME long to string NAME long NAME to string ARGUMENT LIST ARGUMENT EXPR index NAME index EXPR target put id target value CALL target put id target value NAME target put NAME target NAME put ARGUMENT LIST ARGUMENT EXPR id NAME id ARGUMENT EXPR target NAME target ARGUMENT EXPR value NAME value ELSE else target put int index target value BLOCK EXPR target put int index target value CALL target put int index target value NAME target put NAME target NAME put ARGUMENT LIST ARGUMENT EXPR int index NAME int NAME index ARGUMENT EXPR target NAME target ARGUMENT EXPR value NAME value private JJ static JJ void NN define VB elem NN root ROOT define dobj define elem context NN cx NN scriptable JJ target NN long RB index NN object NN value NN if IN index NN integer NN max NN root ROOT max compound max integer value NN string NN id NN long RB to TO string VB index NN target NN put VBD root ROOT put nsubj put target id NN target NN value NN else RB target NN put VBD root ROOT put nsubj put target int NN index NN target NN value NN target put ANTONYM ANTONYM
FUNCTION SPECIFIER private SPECIFIER static TYPE void NAME void NAME set elem PARAMETER LIST context cx scriptable target long index object value PARAMETER context cx TYPE context NAME context NAME cx PARAMETER scriptable target TYPE scriptable NAME scriptable NAME target PARAMETER long index TYPE long NAME long NAME index PARAMETER object value TYPE object NAME object NAME value BLOCK IF if index integer max value string id long to string index scriptable object put property target id value else scriptable object put property target int index value CONDITION index integer max value EXPR index integer max value NAME index NAME integer max value NAME integer NAME max value THEN string id long to string index scriptable object put property target id value BLOCK DECL STMT TYPE string NAME string NAME id INIT long to string index EXPR long to string index CALL long to string index NAME long to string NAME long NAME to string ARGUMENT LIST ARGUMENT EXPR index NAME index EXPR scriptable object put property target id value CALL scriptable object put property target id value NAME scriptable object put property NAME scriptable object NAME put property ARGUMENT LIST ARGUMENT EXPR target NAME target ARGUMENT EXPR id NAME id ARGUMENT EXPR value NAME value ELSE else scriptable object put property target int index value BLOCK EXPR scriptable object put property target int index value CALL scriptable object put property target int index value NAME scriptable object put property NAME scriptable object NAME put property ARGUMENT LIST ARGUMENT EXPR target NAME target ARGUMENT EXPR int index NAME int NAME index ARGUMENT EXPR value NAME value private JJ static JJ void NN set VBN elem NNS root ROOT set dobj set elem context NN cx NN scriptable JJ target NN long RB index NN object NN value NN if IN index NN integer NN max NN root ROOT max compound max integer value NN string NN id NN long RB to TO string VB index NN scriptable JJ object NN put VBD property NN root ROOT put amod object scriptable nsubj put object dobj put property target NN id NN value NN else RB scriptable JJ object NN put VBD property NN root ROOT put amod object scriptable nsubj put object dobj put property target NN int NN index NN value NN
FUNCTION SPECIFIER public TYPE object NAME object NAME remove PARAMETER LIST int index PARAMETER int index TYPE int NAME int NAME index BLOCK THROW throw new unsupported operation exception EXPR new unsupported operation exception CALL unsupported operation exception NAME unsupported operation exception ARGUMENT LIST public NN object NN remove VB int NN index NN throw VB new JJ unsupported JJ operation NN exception NN root ROOT exception amod exception unsupported compound exception operation
COMMENT internal representation of the java script array s length property DECL STMT SPECIFIER private TYPE long NAME long NAME length internal representation of the java script array s length property root ROOT s amod representation internal nsubj s representation case array of det array the compound array java compound array script nmod of representation array compound property length dobj s property private JJ long RB length NN internal private SYNONYM SYNONYM
COMMENT the default capacity for code dense code DECL STMT SPECIFIER private SPECIFIER static TYPE final int SPECIFIER final NAME int NAME default initial capacity INIT EXPR the default capacity for code dense code root ROOT capacity det capacity the compound capacity default case code for compound code code amod code dense nmod for capacity code private JJ static JJ final JJ int NN default NN initial JJ capacity NN root ROOT capacity compound capacity default amod capacity initial initial final ANTONYM ANTONYM
DECL STMT SPECIFIER private SPECIFIER static TYPE final int SPECIFIER final NAME int NAME max pre grow size INIT int integer max value grow factor EXPR int integer max value grow factor CALL int integer max value grow factor NAME int ARGUMENT LIST ARGUMENT EXPR integer max value grow factor NAME integer max value NAME integer NAME max value NAME grow factor private JJ static JJ final JJ int NN max NN pre JJ grow VB size NN root ROOT max amod max pre dep pre grow dobj grow size int NN integer NN max NN root ROOT max compound max integer value NN grow VB factor NN root ROOT grow dobj grow factor
FUNCTION SPECIFIER public TYPE int NAME int NAME index of PARAMETER LIST object o PARAMETER object o TYPE object NAME object NAME o BLOCK DECL STMT TYPE long NAME long NAME long len INIT length EXPR length NAME length IF if long len integer max value throw new illegal state exception CONDITION long len integer max value EXPR long len integer max value NAME long len NAME integer max value NAME integer NAME max value THEN throw new illegal state exception BLOCK THROW throw new illegal state exception EXPR new illegal state exception CALL illegal state exception NAME illegal state exception ARGUMENT LIST DECL STMT TYPE int NAME int NAME len INIT int long len EXPR int long len NAME int NAME long len IF if o null for int i i len i if get i null return i else for int i i len i if o equals get i return i CONDITION o null EXPR o null NAME o THEN for int i i len i if get i null return i BLOCK FOR for int i i len i if get i null return i CONTROL int i i len i INIT int i TYPE int NAME int NAME i INIT EXPR CONDITION i len EXPR i len NAME i NAME len INCR i EXPR i NAME i BLOCK IF if get i null return i CONDITION get i null EXPR get i null CALL get i NAME get ARGUMENT LIST ARGUMENT EXPR i NAME i THEN return i BLOCK RETURN return i EXPR i NAME i ELSE else for int i i len i if o equals get i return i BLOCK FOR for int i i len i if o equals get i return i CONTROL int i i len i INIT int i TYPE int NAME int NAME i INIT EXPR CONDITION i len EXPR i len NAME i NAME len INCR i EXPR i NAME i BLOCK IF if o equals get i return i CONDITION o equals get i EXPR o equals get i CALL o equals get i NAME o equals NAME o NAME equals ARGUMENT LIST ARGUMENT EXPR get i CALL get i NAME get ARGUMENT LIST ARGUMENT EXPR i NAME i THEN return i BLOCK RETURN return i EXPR i NAME i RETURN return EXPR public NN int NN index NN of IN root ROOT index acl index of object NN o NN long RB long RB len NN root ROOT len advmod len long length NN if IN long RB len NN root ROOT len advmod len long integer NN max NN root ROOT max compound max integer value NN throw VB new JJ illegal JJ state NN exception NN root ROOT exception amod exception illegal compound exception state int NN len NN int NN long RB len NN root ROOT len advmod len long if IN o NN null JJ for IN int NN i LS i LS len NN i LS if IN get VB i LS null JJ return NN i LS else RB for IN int NN i LS i LS len NN i LS if IN o NN equals VBZ root ROOT equals nsubj equals o get VB i LS return NN i LS return NN get return ANTONYM ANTONYM throw get ANTONYM ANTONYM throw return ANTONYM ANTONYM new else SYNONYM SYNONYM
COMMENT sets regexp flags can be code null or FUNCTION SPECIFIER public TYPE void NAME void NAME set flags PARAMETER LIST string flags PARAMETER string flags TYPE string NAME string NAME flags BLOCK EXPR this flags flags NAME this flags NAME this NAME flags NAME flags sets regexp flags can be code null or root ROOT null compound flags sets amod flags regexp nsubj null flags aux null can cop null be nmod npmod null code cc null or sets regexp flags can be code null or root ROOT null compound flags sets amod flags regexp nsubj null flags aux null can cop null be nmod npmod null code cc null or public NN void NN set VBN flags NNS root ROOT set dobj set flags string NN flags NNS this DT flags NNS flags NNS
FUNCTION ANNOTATION override NAME override SPECIFIER public TYPE string NAME string NAME to source PARAMETER LIST int depth PARAMETER int depth TYPE int NAME int NAME depth BLOCK RETURN return make indent depth value flags null flags EXPR make indent depth value flags null flags CALL make indent depth NAME make indent ARGUMENT LIST ARGUMENT EXPR depth NAME depth NAME value TERNARY flags null flags CONDITION flags null EXPR flags null NAME flags THEN EXPR ELSE flags EXPR flags NAME flags override NN public NN string NN to TO source NN root ROOT source case source to int NN depth NN return NN make VB indent JJ root ROOT make xcomp make indent depth NN value NN flags NNS null JJ flags NNS
FUNCTION SPECIFIER private TYPE string NAME string NAME js to source PARAMETER LIST BLOCK DECL STMT TYPE string builder NAME string builder NAME sb INIT new string builder EXPR new string builder CALL string builder NAME string builder ARGUMENT LIST EXPR sb append CALL sb append NAME sb append NAME sb NAME append ARGUMENT LIST ARGUMENT EXPR EXPR to source impl ns get prefix ns get uri sb CALL to source impl ns get prefix ns get uri sb NAME to source impl ARGUMENT LIST ARGUMENT EXPR ns get prefix CALL ns get prefix NAME ns get prefix NAME ns NAME get prefix ARGUMENT LIST ARGUMENT EXPR ns get uri CALL ns get uri NAME ns get uri NAME ns NAME get uri ARGUMENT LIST ARGUMENT EXPR sb NAME sb EXPR sb append CALL sb append NAME sb append NAME sb NAME append ARGUMENT LIST ARGUMENT EXPR RETURN return sb to string EXPR sb to string CALL sb to string NAME sb to string NAME sb NAME to string ARGUMENT LIST private JJ string NN js NNS to TO source NN root ROOT js case source to nmod to js source string NN builder NN root ROOT builder compound builder string sb NN new JJ string NN builder NN root ROOT builder compound builder string sb NN append IN root ROOT sb dep sb append to TO source NN impl NN root ROOT source mark source to dobj source impl ns NNS get VBP prefix NN root ROOT get nsubj get ns dobj get prefix ns NNS get VBP uri NN root ROOT get nsubj get ns dobj get uri sb NN sb NN append IN root ROOT sb dep sb append return NN sb NN to TO string NN root ROOT sb case string to nmod to sb string
FUNCTION SPECIFIER private TYPE namespace NAME namespace NAME construct namespace PARAMETER LIST BLOCK RETURN return new namespace EXPR new namespace CALL new namespace NAME new namespace ARGUMENT LIST ARGUMENT EXPR ARGUMENT EXPR private JJ namespace NN construct NN namespace NN root ROOT namespace compound namespace construct return NN new JJ namespace NN root ROOT namespace amod namespace new
FUNCTION TYPE namespace NAME namespace NAME cast to namespace PARAMETER LIST object namespace obj PARAMETER object namespace obj TYPE object NAME object NAME namespace obj BLOCK IF if namespace obj instanceof namespace return namespace namespace obj CONDITION namespace obj instanceof namespace EXPR namespace obj instanceof namespace NAME namespace obj NAME namespace THEN return namespace namespace obj BLOCK RETURN return namespace namespace obj EXPR namespace namespace obj NAME namespace NAME namespace obj RETURN return construct namespace namespace obj EXPR construct namespace namespace obj CALL construct namespace namespace obj NAME construct namespace ARGUMENT LIST ARGUMENT EXPR namespace obj NAME namespace obj namespace NN cast VBN to TO namespace VB root ROOT cast mark namespace to xcomp cast namespace object NN namespace NN obj NN root ROOT obj compound obj namespace if IN namespace NN obj NN root ROOT obj compound obj namespace instanceof NN namespace NN return NN namespace NN namespace NN obj NN root ROOT obj compound obj namespace return NN construct NN namespace NN root ROOT namespace compound namespace construct namespace NN obj NN root ROOT obj compound obj namespace
FUNCTION ANNOTATION override NAME override SPECIFIER public TYPE string NAME string NAME get class name PARAMETER LIST BLOCK RETURN return namespace EXPR namespace override NN public NN string NN get VB class NN name NN root ROOT get compound name class dobj get name return NN namespace NN
FUNCTION SPECIFIER public TYPE string NAME string NAME to locale string PARAMETER LIST BLOCK RETURN return to string EXPR to string CALL to string NAME to string ARGUMENT LIST public NN string NN to TO locale NN string NN root ROOT string case string to compound string locale return NN to TO string VB root ROOT string mark string to
COMMENT second formatted in most recent invocation DECL STMT SPECIFIER private TYPE long NAME long NAME previous seconds INIT long min value EXPR long min value NAME long min value NAME long NAME min value second formatted in most recent invocation root ROOT formatted advmod formatted second case invocation in advmod recent most amod invocation recent nmod in formatted invocation private JJ long RB previous JJ seconds NNS root ROOT seconds amod seconds previous long RB min NN value NN second min ANTONYM ANTONYM
CONSTRUCTOR private cache cache parent cache new string cache size formatter new simple date format format locale us formatter set time zone time zone get default this parent parent SPECIFIER private NAME cache PARAMETER LIST cache parent PARAMETER cache parent TYPE cache NAME cache NAME parent BLOCK EXPR cache new string cache size NAME cache NAME string cache size NAME string INDEX cache size EXPR cache size NAME cache size EXPR formatter new simple date format format locale us NAME formatter CALL simple date format format locale us NAME simple date format ARGUMENT LIST ARGUMENT EXPR format NAME format ARGUMENT EXPR locale us NAME locale us NAME locale NAME us EXPR formatter set time zone time zone get default CALL formatter set time zone time zone get default NAME formatter set time zone NAME formatter NAME set time zone ARGUMENT LIST ARGUMENT EXPR time zone get default CALL time zone get default NAME time zone get default NAME time zone NAME get default ARGUMENT LIST EXPR this parent parent NAME this parent NAME this NAME parent NAME parent private JJ cache NN cache NN parent NN cache NN new JJ string NN cache NN size NN root ROOT size compound size cache formatter NN new JJ simple JJ date NN format NN root ROOT format amod format simple compound format date format NN locale NN us PRP root ROOT us compound us locale formatter NN set VBD time NN zone NN root ROOT set nsubj set formatter compound zone time dobj set zone time NN zone NN get VB default NN root ROOT get compound zone time nsubj get zone dobj get default this DT parent NN parent NN
DECL STMT SPECIFIER private TYPE simple date format NAME simple date format NAME formatter private JJ simple JJ date NN format NN root ROOT format amod format simple compound format date formatter NN
COMMENT last second contained in cache DECL STMT SPECIFIER private TYPE long NAME long NAME last INIT long min value EXPR long min value NAME long min value NAME long NAME min value last second contained in cache root ROOT second amod second last acl second contained case cache in nmod in contained cache private JJ long RB last JJ long RB min NN value NN last second ANTONYM ANTONYM second min ANTONYM ANTONYM
COMMENT index of first in the cyclic cache DECL STMT SPECIFIER private TYPE int NAME int NAME offset INIT EXPR index of first in the cyclic cache root ROOT index case first of nmod of index first case cache in det cache the amod cache cyclic nmod in first cache private JJ int NN offset VBN
COMMENT helper object to be able to call simple date format format DECL STMT SPECIFIER private TYPE final date SPECIFIER final NAME date NAME current date INIT new date EXPR new date CALL date NAME date ARGUMENT LIST helper object to be able to call simple date format format root ROOT object compound object helper mark able to cop able be acl to object able mark call to xcomp able call amod format simple compound format date compound format format dobj call format helper object to be able to call simple date format format root ROOT object compound object helper mark able to cop able be acl to object able mark call to xcomp able call amod format simple compound format date compound format format dobj call format private JJ final JJ date NN current JJ date NN root ROOT date amod date current new JJ date NN
COMMENT binds a new name to the object bound to an old name and unbinds the old name param old name the name of the existing binding may not be empty param new name the name of the new binding may not be empty exception name already bound exception if new name is already bound exception naming exception if a naming exception is encountered FUNCTION ANNOTATION override NAME override SPECIFIER public TYPE void NAME void NAME rename PARAMETER LIST string old name string new name PARAMETER string old name TYPE string NAME string NAME old name PARAMETER string new name TYPE string NAME string NAME new name THROWS throws naming exception ARGUMENT EXPR naming exception NAME naming exception BLOCK EXPR rename new composite name old name new composite name new name CALL rename new composite name old name new composite name new name NAME rename ARGUMENT LIST ARGUMENT EXPR new composite name old name CALL composite name old name NAME composite name ARGUMENT LIST ARGUMENT EXPR old name NAME old name ARGUMENT EXPR new composite name new name CALL composite name new name NAME composite name ARGUMENT LIST ARGUMENT EXPR new name NAME new name binds a new name to the object bound to an old name and unbinds the root ROOT bound csubj bound binds csubj unbinds binds det name a amod name new dobj binds name case object to det object the nmod to binds object case name to det name an amod name old nmod to bound name cc bound and conj and bound unbinds dobj unbinds the old name root ROOT name amod name old param old name the name of the existing binding may not be empty root ROOT empty compound name param amod name old dobj empty name det name the nsubj empty name case binding of det binding the amod binding existing nmod of name binding aux empty may neg empty not cop empty be param new name the name of the new binding may not be empty root ROOT param amod name new dobj param name det name the nsubj empty name case binding of det binding the amod binding new nmod of name binding aux empty may neg empty not cop empty be acl relcl name empty exception name already bound exception if new name is already bound root ROOT bound compound name exception nsubj bound name advmod bound already dobj bound exception mark bound if amod name new nsubjpass bound name auxpass bound is advmod bound already advcl if bound bound exception naming exception if a naming exception is encountered root ROOT exception compound exception exception compound exception naming mark encountered if det exception a amod exception naming nsubjpass encountered exception auxpass encountered is dep exception encountered override NN public NN void NN rename VB string NN old JJ name NN root ROOT name amod name old string NN new JJ name NN root ROOT name amod name new throws VBZ naming VBG exception NN root ROOT naming dobj naming exception rename VB new JJ composite JJ name NN root ROOT name amod name composite old JJ name NN root ROOT name amod name old new JJ composite JJ name NN root ROOT name amod name composite new JJ name NN root ROOT name amod name new be naming ANTONYM ANTONYM binding throws ANTONYM ANTONYM binds throws ANTONYM ANTONYM binds unbinds ANTONYM ANTONYM is naming ANTONYM ANTONYM name be ANTONYM ANTONYM name is ANTONYM ANTONYM name throws ANTONYM ANTONYM naming throws ANTONYM ANTONYM new old ANTONYM ANTONYM unbinds binding ANTONYM ANTONYM
COMMENT enumerates the names bound in the named context along with the class names of objects bound to them param name the name of the context to list return an enumeration of the names and class names of the bindings in this context each element of the enumeration is of type name class pair exception naming exception if a naming exception is encountered FUNCTION ANNOTATION override NAME override SPECIFIER public TYPE naming enumeration name class pair NAME naming enumeration name class pair NAME naming enumeration ARGUMENT LIST ARGUMENT NAME name class pair NAME list PARAMETER LIST string name PARAMETER string name TYPE string NAME string NAME name THROWS throws naming exception ARGUMENT EXPR naming exception NAME naming exception BLOCK RETURN return list new composite name name EXPR list new composite name name CALL list new composite name name NAME list ARGUMENT LIST ARGUMENT EXPR new composite name name CALL composite name name NAME composite name ARGUMENT LIST ARGUMENT EXPR name NAME name enumerates the names bound in the named context along with the class root ROOT enumerates det names the dobj enumerates names acl names bound case context in det context the amod context named nmod in bound context case class along mwe along with det class the nmod along with names class names of objects bound to them root ROOT names case objects of nmod of names objects acl objects bound case them to nmod to bound them param name the name of the context to list root ROOT name compound name param det name the dep name name case context of det context the nmod of name context case list to nmod to name list return an enumeration of the names and class names of the bindings in root ROOT return det enumeration an dobj return enumeration case names of det names the nmod of enumeration names cc names and compound names class nmod of enumeration names conj and names names case bindings of det bindings the nmod of names bindings dep return in this context each element of the enumeration is of type name class pair root ROOT pair det context this nmod tmod pair context det element each nsubj pair element case enumeration of det enumeration the nmod of element enumeration cop pair is case pair of compound pair type compound pair name compound pair class this context each element of the enumeration is of type name class pair root ROOT pair det context this nmod tmod pair context det element each nsubj pair element case enumeration of det enumeration the nmod of element enumeration cop pair is case pair of compound pair type compound pair name compound pair class exception naming exception if a naming exception is encountered root ROOT exception compound exception exception compound exception naming mark encountered if det exception a amod exception naming nsubjpass encountered exception auxpass encountered is dep exception encountered override NN public NN naming VBG enumeration NN root ROOT naming dobj naming enumeration name NN class NN pair NN root ROOT pair compound pair name compound pair class list NN string NN name NN throws VBZ naming VBG exception NN root ROOT naming dobj naming exception return NN list NN new JJ composite JJ name NN root ROOT name amod name composite name NN enumerates list ANTONYM ANTONYM is naming ANTONYM ANTONYM name is ANTONYM ANTONYM name throws ANTONYM ANTONYM named is ANTONYM ANTONYM named throws ANTONYM ANTONYM names is ANTONYM ANTONYM names throws ANTONYM ANTONYM naming throws ANTONYM ANTONYM return throws ANTONYM ANTONYM
COMMENT retrieves the named object following links except for the terminal atomic component of the name if the object bound to name is not a link returns the object itself param name the name of the object to look up return the object bound to name not following the terminal link if any exception naming exception if a naming exception is encountered FUNCTION ANNOTATION override NAME override SPECIFIER public TYPE object NAME object NAME lookup link PARAMETER LIST name name PARAMETER name name TYPE name NAME name NAME name THROWS throws naming exception ARGUMENT EXPR naming exception NAME naming exception BLOCK RETURN return lookup name false EXPR lookup name false CALL lookup name false NAME lookup ARGUMENT LIST ARGUMENT EXPR name NAME name ARGUMENT EXPR false retrieves the named object following links except for the terminal root ROOT retrieves det object the amod object named dobj retrieves object case links following nmod following retrieves links case terminal except mwe except for det terminal the nmod except for links terminal atomic component of the name if the object bound to name is not a root ROOT a amod component atomic nsubj a component case name of det name the nmod of component name mark bound if det object the nsubj bound object csubj a bound case name to nmod to bound name cop a is neg a not atomic component of the name if the object bound to name is not a root ROOT a amod component atomic nsubj a component case name of det name the nmod of component name mark bound if det object the nsubj bound object csubj a bound case name to nmod to bound name cop a is neg a not link returns the object itself root ROOT returns nsubj returns link det object the dobj returns object nmod npmod returns itself param name the name of the object to look up root ROOT name compound name param det name the dep name name case object of det object the nmod of name object mark look to acl to name look compound prt look up return the object bound to name not following the terminal link root ROOT return det object the nsubj bound object nsubj xsubj name object ccomp return bound mark name to xcomp bound name neg following not xcomp name following det link the amod link terminal dobj following link if any root ROOT any mark any if exception naming exception if a naming exception is encountered root ROOT exception compound exception exception compound exception naming mark encountered if det exception a amod exception naming nsubjpass encountered exception auxpass encountered is dep exception encountered override NN public NN object NN lookup NN link NN root ROOT link compound link lookup name NN name NN throws VBZ naming VBG exception NN root ROOT naming dobj naming exception return NN lookup NN name NN false JJ is naming ANTONYM ANTONYM look encountered ANTONYM ANTONYM name is ANTONYM ANTONYM name throws ANTONYM ANTONYM named is ANTONYM ANTONYM named throws ANTONYM ANTONYM naming throws ANTONYM ANTONYM retrieves encountered ANTONYM ANTONYM retrieves return ANTONYM ANTONYM retrieves returns ANTONYM ANTONYM return throws ANTONYM ANTONYM returns throws ANTONYM ANTONYM
COMMENT return code true code if writing is allowed on this context FUNCTION SPECIFIER protected TYPE boolean NAME boolean NAME is writable PARAMETER LIST BLOCK RETURN return context access controller is writable name EXPR context access controller is writable name CALL context access controller is writable name NAME context access controller is writable NAME context access controller NAME is writable ARGUMENT LIST ARGUMENT EXPR name NAME name return code true code if writing is allowed on this context root ROOT code compound code return compound code code amod code true mark allowed if nsubjpass allowed writing auxpass allowed is dep code allowed case context on det context this nmod on allowed context protected VBN boolean NN is VBZ writable JJ root ROOT writable cop writable is return NN context NN access NN controller NN is VBZ writable JJ root ROOT writable compound controller context compound controller access nsubj writable controller cop writable is name NN is name ANTONYM ANTONYM
COMMENT release the lock for the given mutex param mutex the mutex from which to release the lock return the operation status FUNCTION DECL public static native int unlock long mutex SPECIFIER public SPECIFIER static SPECIFIER native TYPE int NAME int NAME unlock PARAMETER LIST long mutex PARAMETER long mutex TYPE long NAME long NAME mutex release the lock for the given mutex root ROOT release det lock the dobj release lock case mutex for det mutex the amod mutex given nmod for release mutex param mutex the mutex from which to release the lock root ROOT mutex compound mutex param det mutex the dep mutex mutex nmod from release mutex case which from ref mutex which mark release to acl relcl mutex release det lock the dobj release lock return the operation status root ROOT return det status the compound status operation dobj return status public NN static JJ native JJ int NN unlock NN long RB mutex NN lock unlock ANTONYM ANTONYM release given ANTONYM ANTONYM
COMMENT destroy the mutex and free the memory associated with the lock param mutex the mutex to destroy return the operation status FUNCTION DECL public static native int destroy long mutex SPECIFIER public SPECIFIER static SPECIFIER native TYPE int NAME int NAME destroy PARAMETER LIST long mutex PARAMETER long mutex TYPE long NAME long NAME mutex destroy the mutex and free the memory associated with the lock root ROOT destroy det mutex the dobj destroy mutex cc mutex and amod memory free det memory the dobj destroy memory conj and mutex memory acl mutex associated case lock with det lock the nmod with associated lock param mutex the mutex to destroy root ROOT mutex compound mutex param det mutex the dep mutex mutex mark destroy to acl to mutex destroy return the operation status root ROOT return det status the compound status operation dobj return status public NN static JJ native JJ int NN destroy VB long RB mutex NN lock free ANTONYM ANTONYM
COMMENT display the name of the default mutex apr lock default return the default name FUNCTION DECL public static native string defname SPECIFIER public SPECIFIER static SPECIFIER native TYPE string NAME string NAME defname PARAMETER LIST display the name of the default mutex apr lock default root ROOT display det name the dobj display name case default of det default the compound default default compound default mutex compound default apr compound default lock nmod of name default return the default name root ROOT return det name the compound name default dobj return name public NN static JJ native JJ string NN defname NN
DECL STMT SPECIFIER public SPECIFIER static TYPE final int SPECIFIER final NAME int NAME apr lock flock INIT EXPR public NN static JJ final JJ int NN apr NN lock NN flock NN root ROOT flock compound flock apr compound flock lock flock NN
COMMENT flock DECL STMT SPECIFIER public SPECIFIER static TYPE final int SPECIFIER final NAME int NAME apr lock default INIT EXPR public NN static JJ final JJ int NN apr NN lock NN default NN root ROOT default compound default apr compound default lock use NN the DT default NN process NN lock NN
COMMENT use the default process lock COMMENT acquire the lock for the given mutex if the mutex is already locked the current thread will be put to sleep until the lock becomes available param mutex the mutex on which to acquire the lock return the operation status FUNCTION DECL public static native int lock long mutex SPECIFIER public SPECIFIER static SPECIFIER native TYPE int NAME int NAME lock PARAMETER LIST long mutex PARAMETER long mutex TYPE long NAME long NAME mutex acquire the lock for the given mutex if the mutex is already locked root ROOT acquire det lock the dobj acquire lock case mutex for det mutex the amod mutex given nmod for lock mutex mark locked if det mutex the nsubjpass locked mutex auxpass locked is advmod locked already advcl if acquire locked acquire the lock for the given mutex if the mutex is already locked root ROOT acquire det lock the dobj acquire lock case mutex for det mutex the amod mutex given nmod for lock mutex mark locked if det mutex the nsubjpass locked mutex auxpass locked is advmod locked already advcl if acquire locked the current thread will be put to sleep until the lock becomes available root ROOT put det thread the amod thread current nsubjpass put thread nsubj xsubj sleep thread aux put will auxpass put be mark sleep to xcomp put sleep mark becomes until det lock the nsubj becomes lock advcl until sleep becomes xcomp becomes available param mutex the mutex on which to acquire the lock root ROOT mutex compound mutex param det mutex the dep mutex mutex nmod on acquire mutex case which on ref mutex which mark acquire to acl relcl mutex acquire det lock the dobj acquire lock return the operation status root ROOT return det status the compound status operation dobj return status public NN static JJ native JJ int NN lock NN long RB mutex NN acquire becomes ANTONYM ANTONYM given acquire ANTONYM ANTONYM given put ANTONYM ANTONYM given will ANTONYM ANTONYM
COMMENT determine if pool a is an ancestor of pool b param a the pool to search param b the pool to search for return true if a is an ancestor of b null is considered an ancestor of all pools FUNCTION DECL public static native boolean is ancestor long a long b SPECIFIER public SPECIFIER static SPECIFIER native TYPE boolean NAME boolean NAME is ancestor PARAMETER LIST long a long b PARAMETER long a TYPE long NAME long NAME a PARAMETER long b TYPE long NAME long NAME b determine if pool a is an ancestor of pool b root ROOT determine mark ancestor if compound a pool nsubj ancestor a cop ancestor is det ancestor an advcl if determine ancestor case b of compound b pool nmod of ancestor b param a the pool to search root ROOT param det pool a det pool the dobj param pool mark search to acl to pool search param b the pool to search for root ROOT b compound b param det pool the dep b pool mark search to acl to pool search nmod search for return true if a is an ancestor of b null is considered an ancestor root ROOT considered nsubjpass considered return amod return true mark ancestor if nsubj ancestor a cop ancestor is det ancestor an advcl if true ancestor case null of compound null b nmod of ancestor null auxpass considered is det ancestor an xcomp considered ancestor of all pools root ROOT pools case pools of det pools all public NN static JJ native JJ boolean NN is VBZ ancestor NN root ROOT ancestor cop ancestor is long RB a DT long RB b NN determine considered ANTONYM ANTONYM
COMMENT clear all memory in the pool and run all the cleanups this also destroys all subpools param pool the pool to clear this does not actually free the memory it just allows the pool to re use this memory for the next allocation FUNCTION DECL public static native void clear long pool SPECIFIER public SPECIFIER static SPECIFIER native TYPE void NAME void NAME clear PARAMETER LIST long pool PARAMETER long pool TYPE long NAME long NAME pool clear all memory in the pool and run all the cleanups this also destroys all root ROOT clear det memory all dobj clear memory case pool in det pool the nmod in memory pool cc clear and conj and clear run det predet cleanups all det cleanups the dobj run cleanups nsubj destroys this advmod destroys also acl relcl cleanups destroys dep clear all clear all memory in the pool and run all the cleanups this also destroys all root ROOT clear det memory all dobj clear memory case pool in det pool the nmod in memory pool cc clear and conj and clear run det predet cleanups all det cleanups the dobj run cleanups nsubj destroys this advmod destroys also acl relcl cleanups destroys dep clear all subpools param pool the pool to clear root ROOT pool compound pool param det pool the dep pool pool case clear to nmod to pool clear this does not actually free the memory it just allows the pool root ROOT free nsubj free this aux free does neg free not advmod free actually det memory the dobj free memory nsubj allows it advmod allows just acl relcl memory allows det pool the dobj allows pool to re use this memory for the next allocation root ROOT re mark re to dobj re use det memory this dobj use memory case allocation for det allocation the amod allocation next nmod for use allocation public NN static JJ native JJ void NN clear JJ long RB pool NN clear does ANTONYM ANTONYM clear free ANTONYM ANTONYM clear just ANTONYM ANTONYM clear run ANTONYM ANTONYM does use ANTONYM ANTONYM free allows ANTONYM ANTONYM free use ANTONYM ANTONYM public clear ANTONYM ANTONYM run does ANTONYM ANTONYM clear native SYNONYM SYNONYM in next SYNONYM SYNONYM
COMMENT create a new pool param parent the parent pool if this is the new pool is a root pool if it is non zero the new pool will inherit all of its parent pool s attributes except the apr pool t will be a sub pool return the pool we have just created FUNCTION DECL public static native long create long parent SPECIFIER public SPECIFIER static SPECIFIER native TYPE long NAME long NAME create PARAMETER LIST long parent PARAMETER long parent TYPE long NAME long NAME parent create a new pool root ROOT create det pool a amod pool new dobj create pool param parent the parent pool if this is the new pool is a root root ROOT root compound parent param nsubj root parent det pool the compound pool parent dep parent pool mark pool if nsubj pool this cop pool is det pool the amod pool new csubj root pool cop root is det root a param parent the parent pool if this is the new pool is a root root ROOT root compound parent param nsubj root parent det pool the compound pool parent dep parent pool mark pool if nsubj pool this cop pool is det pool the amod pool new csubj root pool cop root is det root a pool if it is non zero the new pool will inherit all root ROOT inherit nsubj inherit pool mark non if nsubj non it cop non is advcl if pool non nummod pool zero det pool the amod pool new dobj non pool aux inherit will dobj inherit all pool if it is non zero the new pool will inherit all root ROOT inherit nsubj inherit pool mark non if nsubj non it cop non is advcl if pool non nummod pool zero det pool the amod pool new dobj non pool aux inherit will dobj inherit all of its parent pool s attributes except the apr pool t will root ROOT s case s of nmod poss s its compound s parent compound s pool acl s attributes case t except det t the compound t apr compound t pool nmod except attributes t dep s will be a sub pool root ROOT pool cop pool be det pool a compound pool sub return the pool we have just created root ROOT created dep created return det pool the dobj return pool nsubj created we aux created have advmod created just public NN static JJ native JJ long RB create VB long RB parent NN create have ANTONYM ANTONYM have created ANTONYM ANTONYM just new ANTONYM ANTONYM return have ANTONYM ANTONYM zero all ANTONYM ANTONYM
COMMENT set the associated adapter param adapter the new adapter FUNCTION SPECIFIER public TYPE void NAME void NAME set adapter PARAMETER LIST adapter adapter PARAMETER adapter adapter TYPE adapter NAME adapter NAME adapter BLOCK EXPR this adapter adapter NAME this adapter NAME this NAME adapter NAME adapter set the associated adapter root ROOT set det adapter the amod adapter associated dobj set adapter param adapter the new adapter root ROOT adapter compound adapter param det adapter the amod adapter new dep adapter adapter public NN void NN set VBN adapter NN root ROOT set dobj set adapter adapter NN adapter NN this DT adapter NN adapter NN
CONSTRUCTOR public abstract processor abstract endpoint endpoint this endpoint new request new response SPECIFIER public NAME abstract processor PARAMETER LIST abstract endpoint endpoint PARAMETER abstract endpoint endpoint TYPE abstract endpoint NAME abstract endpoint NAME abstract endpoint ARGUMENT LIST ARGUMENT NAME NAME endpoint BLOCK EXPR this endpoint new request new response CALL this endpoint new request new response NAME this ARGUMENT LIST ARGUMENT EXPR endpoint NAME endpoint ARGUMENT EXPR new request CALL request NAME request ARGUMENT LIST ARGUMENT EXPR new response CALL response NAME response ARGUMENT LIST public NN abstract JJ processor NN root ROOT processor amod processor abstract abstract JJ endpoint NN root ROOT endpoint amod endpoint abstract endpoint NN this DT endpoint NN new JJ request NN new JJ response NN
COMMENT error state for the request response currently being processed DECL STMT SPECIFIER private TYPE error state NAME error state NAME error state INIT error state none EXPR error state none NAME error state none NAME error state NAME none error state for the request response currently being processed root ROOT processed compound state error nsubjpass processed state case response for det response the compound response request nmod for state response advmod processed currently auxpass processed being private JJ error NN state NN root ROOT state compound state error error NN state NN root ROOT state compound state error error NN state NN none NN root ROOT none compound none error compound none state
FUNCTION ANNOTATION override NAME override SPECIFIER public TYPE boolean NAME boolean NAME is async PARAMETER LIST BLOCK RETURN return async state machine is async EXPR async state machine is async CALL async state machine is async NAME async state machine is async NAME async state machine NAME is async ARGUMENT LIST override NN public NN boolean NN is VBZ async NN root ROOT async cop async is return NN async JJ state NN machine NN is VBZ async NN root ROOT async amod machine async compound machine state nsubj async machine cop async is
COMMENT return the executor used by the underlying endpoint FUNCTION SPECIFIER protected TYPE executor NAME executor NAME get executor PARAMETER LIST BLOCK RETURN return endpoint get executor EXPR endpoint get executor CALL endpoint get executor NAME endpoint get executor NAME endpoint NAME get executor ARGUMENT LIST return the executor used by the underlying endpoint root ROOT return det executor the dobj return executor acl executor used case endpoint by det endpoint the amod endpoint underlying nmod by used endpoint protected VBN executor NN get VB executor NN root ROOT get dobj get executor return NN endpoint NN get VB executor NN root ROOT get nsubj get endpoint dobj get executor
CONSTRUCTOR private abstract processor abstract endpoint endpoint request coyote request response coyote response this endpoint endpoint async state machine new async state machine this request coyote request response coyote response response set hook this request set response response request set hook this SPECIFIER private NAME abstract processor PARAMETER LIST abstract endpoint endpoint request coyote request response coyote response PARAMETER abstract endpoint endpoint TYPE abstract endpoint NAME abstract endpoint NAME abstract endpoint ARGUMENT LIST ARGUMENT NAME NAME endpoint PARAMETER request coyote request TYPE request NAME request NAME coyote request PARAMETER response coyote response TYPE response NAME response NAME coyote response BLOCK EXPR this endpoint endpoint NAME this endpoint NAME this NAME endpoint NAME endpoint EXPR async state machine new async state machine this NAME async state machine CALL async state machine this NAME async state machine ARGUMENT LIST ARGUMENT EXPR this NAME this EXPR request coyote request NAME request NAME coyote request EXPR response coyote response NAME response NAME coyote response EXPR response set hook this CALL response set hook this NAME response set hook NAME response NAME set hook ARGUMENT LIST ARGUMENT EXPR this NAME this EXPR request set response response CALL request set response response NAME request set response NAME request NAME set response ARGUMENT LIST ARGUMENT EXPR response NAME response EXPR request set hook this CALL request set hook this NAME request set hook NAME request NAME set hook ARGUMENT LIST ARGUMENT EXPR this NAME this private JJ abstract JJ processor NN root ROOT processor amod processor abstract abstract JJ endpoint NN root ROOT endpoint amod endpoint abstract endpoint NN request NN coyote NN request NN root ROOT request compound request coyote response NN coyote NN response NN root ROOT response compound response coyote this DT endpoint NN endpoint NN async JJ state NN machine NN root ROOT machine amod machine async compound machine state new JJ async JJ state NN machine NN root ROOT machine amod machine async compound machine state this DT request NN coyote NN request NN root ROOT request compound request coyote response NN coyote NN response NN root ROOT response compound response coyote response NN set VBD hook NN root ROOT set nsubj set response dobj set hook this DT request NN set NN response NN root ROOT response compound response request compound response set response NN request NN set VBD hook NN root ROOT set nsubj set request dobj set hook this DT
FUNCTION SPECIFIER public TYPE void NAME void NAME action PARAMETER LIST action code action code object param PARAMETER action code action code TYPE action code NAME action code NAME action code PARAMETER object param TYPE object NAME object NAME param BLOCK IF if hook null if param null hook action action code this else hook action action code param CONDITION hook null EXPR hook null NAME hook THEN if param null hook action action code this else hook action action code param BLOCK IF if param null hook action action code this else hook action action code param CONDITION param null EXPR param null NAME param THEN hook action action code this BLOCK EXPR hook action action code this CALL hook action action code this NAME hook action NAME hook NAME action ARGUMENT LIST ARGUMENT EXPR action code NAME action code ARGUMENT EXPR this NAME this ELSE else hook action action code param BLOCK EXPR hook action action code param CALL hook action action code param NAME hook action NAME hook NAME action ARGUMENT LIST ARGUMENT EXPR action code NAME action code ARGUMENT EXPR param NAME param public NN void NN action NN action NN code NN root ROOT code compound code action action NN code NN root ROOT code compound code action object NN param NN if IN hook NN null JJ if IN param NN null JJ hook NN action NN root ROOT action compound action hook action NN code NN root ROOT code compound code action this DT else RB hook NN action NN root ROOT action compound action hook action NN code NN root ROOT code compound code action param NN
FUNCTION SPECIFIER public TYPE response NAME response NAME get response PARAMETER LIST BLOCK RETURN return response EXPR response NAME response public NN response NN get VB response NN root ROOT get dobj get response return NN response NN
FUNCTION SPECIFIER public TYPE message bytes NAME message bytes NAME content type PARAMETER LIST BLOCK IF if content type mb null content type mb headers get value content type CONDITION content type mb null EXPR content type mb null NAME content type mb THEN content type mb headers get value content type BLOCK EXPR content type mb headers get value content type NAME content type mb CALL headers get value content type NAME headers get value NAME headers NAME get value ARGUMENT LIST ARGUMENT EXPR content type RETURN return content type mb EXPR content type mb NAME content type mb public NN message NN bytes NNS root ROOT bytes compound bytes message content JJ type NN root ROOT type amod type content if IN content JJ type NN mb NN root ROOT mb amod mb content compound mb type null JJ content JJ type NN mb NN root ROOT mb amod mb content compound mb type headers NNS get VBP value NN root ROOT get nsubj get headers dobj get value content JJ type NN root ROOT type amod type content return NN content JJ type NN mb NN root ROOT mb amod mb content compound mb type
FUNCTION SPECIFIER public TYPE message bytes NAME message bytes NAME remote addr PARAMETER LIST BLOCK RETURN return remote addr mb EXPR remote addr mb NAME remote addr mb public NN message NN bytes NNS root ROOT bytes compound bytes message remote JJ addr NN root ROOT addr amod addr remote return NN remote JJ addr NN mb NN root ROOT mb amod mb remote compound mb addr
FUNCTION SPECIFIER public TYPE void NAME void NAME set read listener PARAMETER LIST read listener listener PARAMETER read listener listener TYPE read listener NAME read listener NAME listener BLOCK IF if listener null throw new null pointer exception sm get string request null read listener CONDITION listener null EXPR listener null NAME listener THEN throw new null pointer exception sm get string request null read listener BLOCK THROW throw new null pointer exception sm get string request null read listener EXPR new null pointer exception sm get string request null read listener CALL null pointer exception sm get string request null read listener NAME null pointer exception ARGUMENT LIST ARGUMENT EXPR sm get string request null read listener CALL sm get string request null read listener NAME sm get string NAME sm NAME get string ARGUMENT LIST ARGUMENT EXPR request null read listener IF if get read listener null throw new illegal state exception sm get string request read listener set CONDITION get read listener null EXPR get read listener null CALL get read listener NAME get read listener ARGUMENT LIST THEN throw new illegal state exception sm get string request read listener set BLOCK THROW throw new illegal state exception sm get string request read listener set EXPR new illegal state exception sm get string request read listener set CALL illegal state exception sm get string request read listener set NAME illegal state exception ARGUMENT LIST ARGUMENT EXPR sm get string request read listener set CALL sm get string request read listener set NAME sm get string NAME sm NAME get string ARGUMENT LIST ARGUMENT EXPR request read listener set COMMENT note this class is not used for http upgrade so only need to test COMMENT for async DECL STMT TYPE atomic boolean NAME atomic boolean NAME result INIT new atomic boolean false EXPR new atomic boolean false CALL atomic boolean false NAME atomic boolean ARGUMENT LIST ARGUMENT EXPR false EXPR action action code async is async result CALL action action code async is async result NAME action ARGUMENT LIST ARGUMENT EXPR action code async is async NAME action code async is async NAME action code NAME async is async ARGUMENT EXPR result NAME result IF if result get throw new illegal state exception sm get string request not async CONDITION result get EXPR result get CALL result get NAME result get NAME result NAME get ARGUMENT LIST THEN throw new illegal state exception sm get string request not async BLOCK THROW throw new illegal state exception sm get string request not async EXPR new illegal state exception sm get string request not async CALL illegal state exception sm get string request not async NAME illegal state exception ARGUMENT LIST ARGUMENT EXPR sm get string request not async CALL sm get string request not async NAME sm get string NAME sm NAME get string ARGUMENT LIST ARGUMENT EXPR request not async EXPR this listener listener NAME this listener NAME this NAME listener NAME listener public NN void NN set VBN read NN listener NN root ROOT set compound listener read dobj set listener read VB listener NN root ROOT read dobj read listener listener NN if IN listener NN null JJ throw VB new JJ null JJ pointer NN exception NN root ROOT exception amod exception null compound exception pointer sm NN get VB string NN root ROOT get nsubj get sm dobj get string request NN null JJ read NN listener NN root ROOT listener compound listener request amod listener null compound listener read if IN get VB read VB listener NN root ROOT read aux read get dobj read listener null JJ throw VB new JJ illegal JJ state NN exception NN root ROOT exception amod exception illegal compound exception state sm NN get VB string NN root ROOT get nsubj get sm dobj get string request NN read VBD listener NN set NN root ROOT read nsubj read request compound set listener dobj read set note this class is not used for http upgrade so only need to test root ROOT note det class this nsubjpass used class auxpass used is neg used not acl relcl note used case upgrade for amod upgrade http nmod for used upgrade advmod need so advmod need only dep used need mark test to xcomp need test for async root ROOT async case async for atomic JJ boolean NN root ROOT boolean amod boolean atomic result NN new JJ atomic JJ boolean NN root ROOT boolean amod boolean atomic false JJ action NN action NN code NN async NN root ROOT async compound async action compound async code is VBZ async NN root ROOT async cop async is result NN if IN result NN get VB root ROOT get nsubj get result throw VB new JJ illegal JJ state NN exception NN root ROOT exception amod exception illegal compound exception state sm NN get VB string NN root ROOT get nsubj get sm dobj get string request NN not RB async IN root ROOT request neg async not dep request async this DT listener NN listener NN get result ANTONYM ANTONYM need get ANTONYM ANTONYM new used ANTONYM ANTONYM request need ANTONYM ANTONYM throw get ANTONYM ANTONYM null false SYNONYM SYNONYM void false SYNONYM SYNONYM
COMMENT is there an expectation DECL STMT SPECIFIER private TYPE boolean NAME boolean NAME expectation INIT false EXPR false is there an expectation root ROOT is expl is there det expectation an nsubj is expectation private JJ boolean NN expectation NN false JJ
COMMENT http specific fields remove them DECL STMT SPECIFIER private TYPE long NAME long NAME content length INIT EXPR http specific fields remove them root ROOT remove compound fields http amod fields specific nsubj remove fields dobj remove them http specific fields remove them root ROOT remove compound fields http amod fields specific nsubj remove fields dobj remove them private JJ long RB content JJ length NN root ROOT length amod length content
COMMENT url decoder DECL STMT SPECIFIER private TYPE final u decoder SPECIFIER final NAME u decoder NAME url decoder INIT new u decoder EXPR new u decoder CALL u decoder NAME u decoder ARGUMENT LIST url decoder root ROOT decoder compound decoder url private JJ final JJ u NN decoder NN root ROOT decoder compound decoder u url NN decoder NN root ROOT decoder compound decoder url new JJ u NN decoder NN root ROOT decoder compound decoder u
COMMENT path parameters DECL STMT SPECIFIER private TYPE final map string string SPECIFIER final NAME map string string NAME map ARGUMENT LIST ARGUMENT NAME string ARGUMENT NAME string NAME path parameters INIT new hash map EXPR new hash map CALL hash map NAME hash map NAME hash map ARGUMENT LIST ARGUMENT LIST path parameters root ROOT parameters compound parameters path private JJ final JJ map NN string NN string NN path NN parameters NNS root ROOT parameters compound parameters path new JJ hash VB map NN root ROOT hash dobj hash map
