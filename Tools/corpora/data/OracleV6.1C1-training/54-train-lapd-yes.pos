FUNCTION SPECIFIER public TYPE string NAME string NAME is el ignored PARAMETER LIST BLOCK RETURN return el ignored EXPR el ignored NAME el ignored public NN string NN is VBZ el NN ignored VBN root ROOT ignored auxpass ignored is nsubjpass ignored el return NN el NN ignored VBD root ROOT ignored nsubj ignored el
FUNCTION SPECIFIER public TYPE string NAME string NAME is scripting invalid PARAMETER LIST BLOCK RETURN return scripting invalid EXPR scripting invalid NAME scripting invalid public NN string NN is VBZ scripting VBG invalid JJ root ROOT scripting aux scripting is xcomp scripting invalid return NN scripting VBG invalid JJ root ROOT scripting xcomp scripting invalid
FUNCTION SPECIFIER public TYPE string NAME string NAME is xml PARAMETER LIST BLOCK RETURN return is xml EXPR is xml NAME is xml public NN string NN is VBZ xml NN root ROOT xml cop xml is return NN is VBZ xml NN root ROOT xml cop xml is
FUNCTION SPECIFIER public SPECIFIER static TYPE object NAME object NAME set object index PARAMETER LIST object obj double dbl index object value context cx PARAMETER object obj TYPE object NAME object NAME obj PARAMETER double dbl index TYPE double NAME double NAME dbl index PARAMETER object value TYPE object NAME object NAME value PARAMETER context cx TYPE context NAME context NAME cx BLOCK RETURN return set object index obj dbl index value cx get top call scope cx EXPR set object index obj dbl index value cx get top call scope cx CALL set object index obj dbl index value cx get top call scope cx NAME set object index ARGUMENT LIST ARGUMENT EXPR obj NAME obj ARGUMENT EXPR dbl index NAME dbl index ARGUMENT EXPR value NAME value ARGUMENT EXPR cx NAME cx ARGUMENT EXPR get top call scope cx CALL get top call scope cx NAME get top call scope ARGUMENT LIST ARGUMENT EXPR cx NAME cx public NN static JJ object NN set VBN object NN index NN root ROOT set compound index object dobj set index object NN obj NN double RB dbl NN index NN root ROOT index compound index dbl object NN value NN context NN cx NN return NN set VBN object NN index NN root ROOT set compound index object dobj set index obj NN dbl NN index NN root ROOT index compound index dbl value NN cx NN get VB top JJ call NN scope NN root ROOT get amod scope top compound scope call dobj get scope cx NN
FUNCTION SPECIFIER public TYPE byte NAME byte NAME byte INDEX NAME get map context name PARAMETER LIST BLOCK RETURN return map context name EXPR map context name NAME map context name public NN byte NN get VB map VB context NN name NN root ROOT map aux map get compound name context dobj map name return NN map NN context NN name NN root ROOT name compound name map compound name context
FUNCTION SPECIFIER public TYPE boolean NAME boolean NAME boolean INDEX NAME get param and var const PARAMETER LIST BLOCK IF if variable names null code bug CONDITION variable names null EXPR variable names null NAME variable names THEN code bug BLOCK EXPR code bug CALL code bug NAME code bug ARGUMENT LIST RETURN return is consts EXPR is consts NAME is consts public NN boolean NN get VB param NN and CC var NN const NN root ROOT get compound const param cc param and conj and param var compound const var dobj get const if IN variable JJ names NNS root ROOT names amod names variable null JJ code NN bug NN root ROOT bug compound bug code return NN is VBZ consts NNS root ROOT consts cop consts is
FUNCTION SPECIFIER protected TYPE void NAME void NAME check PARAMETER LIST BLOCK IF if host get auto deploy check for resources modification to trigger redeployment deployed application apps deployed values to array new deployed application for int i i apps length i if is serviced apps i name check resources apps i false check for old versions of applications that can now be undeployed if host get undeploy old versions check undeploy hotdeploy applications deploy apps CONDITION host get auto deploy EXPR host get auto deploy CALL host get auto deploy NAME host get auto deploy NAME host NAME get auto deploy ARGUMENT LIST THEN check for resources modification to trigger redeployment deployed application apps deployed values to array new deployed application for int i i apps length i if is serviced apps i name check resources apps i false check for old versions of applications that can now be undeployed if host get undeploy old versions check undeploy hotdeploy applications deploy apps BLOCK COMMENT check for resources modification to trigger redeployment DECL STMT TYPE deployed application NAME deployed application NAME deployed application INDEX NAME apps INIT deployed values to array new deployed application EXPR deployed values to array new deployed application CALL deployed values NAME deployed values NAME deployed NAME values ARGUMENT LIST CALL to array new deployed application NAME to array ARGUMENT LIST ARGUMENT EXPR new deployed application NAME deployed application NAME deployed application INDEX EXPR FOR for int i i apps length i if is serviced apps i name check resources apps i false CONTROL int i i apps length i INIT int i TYPE int NAME int NAME i INIT EXPR CONDITION i apps length EXPR i apps length NAME i NAME apps length NAME apps NAME length INCR i EXPR i NAME i BLOCK IF if is serviced apps i name check resources apps i false CONDITION is serviced apps i name EXPR is serviced apps i name CALL is serviced apps i name NAME is serviced ARGUMENT LIST ARGUMENT EXPR apps i name NAME apps i NAME apps INDEX i EXPR i NAME i NAME name THEN check resources apps i false BLOCK EXPR check resources apps i false CALL check resources apps i false NAME check resources ARGUMENT LIST ARGUMENT EXPR apps i NAME apps i NAME apps INDEX i EXPR i NAME i ARGUMENT EXPR false COMMENT check for old versions of applications that can now be undeployed IF if host get undeploy old versions check undeploy CONDITION host get undeploy old versions EXPR host get undeploy old versions CALL host get undeploy old versions NAME host get undeploy old versions NAME host NAME get undeploy old versions ARGUMENT LIST THEN check undeploy BLOCK EXPR check undeploy CALL check undeploy NAME check undeploy ARGUMENT LIST COMMENT hotdeploy applications EXPR deploy apps CALL deploy apps NAME deploy apps ARGUMENT LIST protected VBN void NN check NN if IN host NN get VB auto NN deploy NN root ROOT get nsubj get host compound deploy auto dobj get deploy check for resources modification to trigger redeployment root ROOT check case modification for compound modification resources nmod for check modification mark trigger to acl to check trigger dobj trigger redeployment deployed VBN application NN root ROOT application amod application deployed apps NNS deployed VBN values NNS root ROOT values amod values deployed to TO array NN root ROOT array case array to new JJ deployed VBN application NN root ROOT application amod application deployed for IN int NN i LS i LS apps NNS length NN root ROOT length compound length apps i LS if IN is VBZ serviced VBN root ROOT serviced auxpass serviced is apps NNS i LS name NN check NN resources NNS root ROOT resources compound resources check apps NNS i LS false JJ check for old versions of applications that can now be undeployed root ROOT check case versions for amod versions old nmod for check versions case applications of nmod of versions applications nsubj undeployed applications ref applications that aux undeployed can advmod undeployed now cop undeployed be acl relcl applications undeployed if IN host NN get VB undeploy JJ old JJ versions NNS root ROOT get nsubj get host amod versions undeploy amod versions old dobj get versions check NN undeploy NN root ROOT undeploy compound undeploy check hotdeploy applications root ROOT applications compound applications hotdeploy deploy VB apps NNS root ROOT deploy dobj deploy apps name be ANTONYM ANTONYM new old ANTONYM ANTONYM void false SYNONYM SYNONYM
FUNCTION SPECIFIER protected TYPE void NAME void NAME check expired PARAMETER LIST BLOCK SYNCHRONIZED synchronized expired mutex member expired membership expire time to expiration for int i i expired length i final member member expired i if log is debug enabled log debug mcast expire member expired i try runnable t new runnable override public void run string name thread current thread get name try thread current thread set name membership member expired service member disappeared member finally thread current thread set name name executor execute t catch exception x log error sm get string mcast service impl member disappeared failed x INIT expired mutex EXPR expired mutex NAME expired mutex BLOCK DECL STMT TYPE member NAME member NAME member INDEX NAME expired INIT membership expire time to expiration EXPR membership expire time to expiration CALL membership expire time to expiration NAME membership expire NAME membership NAME expire ARGUMENT LIST ARGUMENT EXPR time to expiration NAME time to expiration FOR for int i i expired length i final member member expired i if log is debug enabled log debug mcast expire member expired i try runnable t new runnable override public void run string name thread current thread get name try thread current thread set name membership member expired service member disappeared member finally thread current thread set name name executor execute t catch exception x log error sm get string mcast service impl member disappeared failed x CONTROL int i i expired length i INIT int i TYPE int NAME int NAME i INIT EXPR CONDITION i expired length EXPR i expired length NAME i NAME expired length NAME expired NAME length INCR i EXPR i NAME i BLOCK DECL STMT TYPE final member SPECIFIER final NAME member NAME member INIT expired i EXPR expired i NAME expired i NAME expired INDEX i EXPR i NAME i IF if log is debug enabled log debug mcast expire member expired i CONDITION log is debug enabled EXPR log is debug enabled CALL log is debug enabled NAME log is debug enabled NAME log NAME is debug enabled ARGUMENT LIST THEN log debug mcast expire member expired i BLOCK EXPR log debug mcast expire member expired i CALL log debug mcast expire member expired i NAME log debug NAME log NAME debug ARGUMENT LIST ARGUMENT EXPR mcast expire member expired i NAME expired i NAME expired INDEX i EXPR i NAME i TRY try runnable t new runnable override public void run string name thread current thread get name try thread current thread set name membership member expired service member disappeared member finally thread current thread set name name executor execute t catch exception x log error sm get string mcast service impl member disappeared failed x BLOCK DECL STMT TYPE runnable NAME runnable NAME t INIT new runnable override public void run string name thread current thread get name try thread current thread set name membership member expired service member disappeared member finally thread current thread set name name EXPR new runnable override public void run string name thread current thread get name try thread current thread set name membership member expired service member disappeared member finally thread current thread set name name CLASS runnable override public void run string name thread current thread get name try thread current thread set name membership member expired service member disappeared member finally thread current thread set name name SUPER runnable NAME runnable ARGUMENT LIST BLOCK FUNCTION ANNOTATION override NAME override SPECIFIER public TYPE void NAME void NAME run PARAMETER LIST BLOCK DECL STMT TYPE string NAME string NAME name INIT thread current thread get name EXPR thread current thread get name CALL thread current thread NAME thread current thread NAME thread NAME current thread ARGUMENT LIST CALL get name NAME get name ARGUMENT LIST TRY try thread current thread set name membership member expired service member disappeared member finally thread current thread set name name BLOCK EXPR thread current thread set name membership member expired CALL thread current thread NAME thread current thread NAME thread NAME current thread ARGUMENT LIST CALL set name membership member expired NAME set name ARGUMENT LIST ARGUMENT EXPR membership member expired EXPR service member disappeared member CALL service member disappeared member NAME service member disappeared NAME service NAME member disappeared ARGUMENT LIST ARGUMENT EXPR member NAME member FINALLY finally thread current thread set name name BLOCK EXPR thread current thread set name name CALL thread current thread NAME thread current thread NAME thread NAME current thread ARGUMENT LIST CALL set name name NAME set name ARGUMENT LIST ARGUMENT EXPR name NAME name EXPR executor execute t CALL executor execute t NAME executor execute NAME executor NAME execute ARGUMENT LIST ARGUMENT EXPR t NAME t CATCH catch exception x log error sm get string mcast service impl member disappeared failed x PARAMETER LIST exception x PARAMETER exception x TYPE exception NAME exception NAME x BLOCK EXPR log error sm get string mcast service impl member disappeared failed x CALL log error sm get string mcast service impl member disappeared failed x NAME log error NAME log NAME error ARGUMENT LIST ARGUMENT EXPR sm get string mcast service impl member disappeared failed CALL sm get string mcast service impl member disappeared failed NAME sm get string NAME sm NAME get string ARGUMENT LIST ARGUMENT EXPR mcast service impl member disappeared failed ARGUMENT EXPR x NAME x protected VBN void NN check NN expired VBD root ROOT expired nsubj expired check synchronized VBN expired VBD mutex NN root ROOT expired dobj expired mutex member NN expired VBD membership NN expire VBP root ROOT expire nsubj expire membership time NN to TO expiration NN root ROOT time case expiration to nmod to time expiration for IN int NN i LS i LS expired VBD length NN root ROOT expired dobj expired length i LS final JJ member NN member NN expired VBD i LS if IN log NN is VBZ debug NN enabled VBD root ROOT debug nsubj debug log cop debug is dep debug enabled log NN debug NN root ROOT debug compound debug log mcast NN expire VB member NN expired VBD i LS try VB runnable JJ t NN new JJ runnable JJ override NN public NN void NN run NN string NN name NN thread NN current JJ thread NN root ROOT thread compound thread thread amod thread current get VB name NN root ROOT get dobj get name try VB thread NN current JJ thread NN root ROOT thread compound thread thread amod thread current set VBN name NN root ROOT set dobj set name membership NN member NN expired VBD root ROOT expired compound member membership nsubj expired member service NN member NN disappeared VBD root ROOT disappeared compound member service nsubj disappeared member member NN finally RB thread NN current JJ thread NN root ROOT thread compound thread thread amod thread current set VBN name NN root ROOT set dobj set name name NN executor NN execute VB root ROOT execute nsubj execute executor t NN catch NN exception NN x NN log NN error NN root ROOT error compound error log sm NN get VB string NN root ROOT get nsubj get sm dobj get string mcast JJ service NN impl NN member NN disappeared VBD failed VBN root ROOT disappeared amod member mcast compound member service compound member impl nsubj disappeared member dep disappeared failed x NN expire failed ANTONYM ANTONYM expire run ANTONYM ANTONYM expired failed ANTONYM ANTONYM expired run ANTONYM ANTONYM run failed ANTONYM ANTONYM run string ANTONYM ANTONYM run thread ANTONYM ANTONYM i x SYNONYM SYNONYM
FUNCTION SPECIFIER private TYPE void NAME void NAME check popup PARAMETER LIST mouse event e PARAMETER mouse event e TYPE mouse event NAME mouse event NAME e BLOCK IF if e is popup trigger popup show this e get x e get y CONDITION e is popup trigger EXPR e is popup trigger CALL e is popup trigger NAME e is popup trigger NAME e NAME is popup trigger ARGUMENT LIST THEN popup show this e get x e get y BLOCK EXPR popup show this e get x e get y CALL popup show this e get x e get y NAME popup show NAME popup NAME show ARGUMENT LIST ARGUMENT EXPR this NAME this ARGUMENT EXPR e get x CALL e get x NAME e get x NAME e NAME get x ARGUMENT LIST ARGUMENT EXPR e get y CALL e get y NAME e get y NAME e NAME get y ARGUMENT LIST private JJ void NN check NN popup NN root ROOT popup compound popup check mouse NN event NN root ROOT event compound event mouse e SYM if IN e LS is VBZ popup NN trigger NN root ROOT trigger nsubj trigger e cop trigger is compound trigger popup popup NN show NN root ROOT show compound show popup this DT e LS get VB x CC root ROOT e root e get dobj get x e LS get VB y SYM root ROOT e root e get dobj get y
FUNCTION SPECIFIER protected TYPE void NAME void NAME has property PARAMETER LIST properties properties string name PARAMETER properties properties TYPE properties NAME properties NAME properties PARAMETER string name TYPE string NAME string NAME name BLOCK IF if properties get property name null throw new illegal argument exception sm get string mcast service missing property name CONDITION properties get property name null EXPR properties get property name null CALL properties get property name NAME properties get property NAME properties NAME get property ARGUMENT LIST ARGUMENT EXPR name NAME name THEN throw new illegal argument exception sm get string mcast service missing property name BLOCK THROW throw new illegal argument exception sm get string mcast service missing property name EXPR new illegal argument exception sm get string mcast service missing property name CALL illegal argument exception sm get string mcast service missing property name NAME illegal argument exception ARGUMENT LIST ARGUMENT EXPR sm get string mcast service missing property name CALL sm get string mcast service missing property name NAME sm get string NAME sm NAME get string ARGUMENT LIST ARGUMENT EXPR mcast service missing property ARGUMENT EXPR name NAME name protected VBN void NN has VBZ property NN root ROOT has dobj has property properties NNS properties NNS string NN name NN if IN properties NNS get VBP property NN root ROOT get nsubj get properties dobj get property name NN null JJ throw VB new JJ illegal JJ argument NN exception NN root ROOT exception amod exception illegal compound exception argument sm NN get VB string NN root ROOT get nsubj get sm dobj get string mcast JJ service NN missing VBG property NN root ROOT property amod service mcast compound property service amod property missing name NN name throw ANTONYM ANTONYM throw missing ANTONYM ANTONYM
FUNCTION SPECIFIER public TYPE void NAME void NAME has should be false for a new array PARAMETER LIST BLOCK EXPR assert that new native array has array is false CALL assert that new native array has array is false NAME assert that ARGUMENT LIST ARGUMENT EXPR new native array has array CALL native array NAME native array ARGUMENT LIST ARGUMENT EXPR CALL has array NAME has ARGUMENT LIST ARGUMENT EXPR ARGUMENT EXPR array NAME array ARGUMENT EXPR is false CALL is false NAME is ARGUMENT LIST ARGUMENT EXPR false public NN void NN has VBZ should MD be VB false JJ for IN a DT new JJ array NN root ROOT false aux false has aux false should cop false be case array for det array a amod array new nmod for false array assert VB that DT root ROOT assert dobj assert that new JJ native JJ array NN root ROOT array amod array native has VBZ array NN is VBZ false JJ void false SYNONYM SYNONYM
FUNCTION SPECIFIER private TYPE void NAME void NAME to exponential format PARAMETER LIST int first digit int dec point PARAMETER int first digit TYPE int NAME int NAME first digit PARAMETER int dec point TYPE int NAME int NAME dec point BLOCK IF if end first digit insert decimal point if more than one digit was produced int dot first digit system arraycopy chars dot chars dot end dot chars dot end CONDITION end first digit EXPR end first digit NAME end NAME first digit THEN insert decimal point if more than one digit was produced int dot first digit system arraycopy chars dot chars dot end dot chars dot end BLOCK COMMENT insert decimal point if more than one digit was produced DECL STMT TYPE int NAME int NAME dot INIT first digit EXPR first digit NAME first digit EXPR system arraycopy chars dot chars dot end dot CALL system arraycopy chars dot chars dot end dot NAME system arraycopy NAME system NAME arraycopy ARGUMENT LIST ARGUMENT EXPR chars NAME chars ARGUMENT EXPR dot NAME dot ARGUMENT EXPR chars NAME chars ARGUMENT EXPR dot NAME dot ARGUMENT EXPR end dot NAME end NAME dot EXPR chars dot NAME chars dot NAME chars INDEX dot EXPR dot NAME dot EXPR end NAME end EXPR chars end e NAME chars end NAME chars INDEX end EXPR end NAME end DECL STMT TYPE char NAME char NAME sign INIT EXPR DECL STMT TYPE int NAME int NAME exp INIT dec point EXPR dec point NAME dec point IF if exp sign exp exp CONDITION exp EXPR exp NAME exp THEN sign exp exp BLOCK EXPR sign NAME sign EXPR exp exp NAME exp NAME exp EXPR chars end sign NAME chars end NAME chars INDEX end EXPR end NAME end NAME sign DECL STMT TYPE int NAME int NAME char pos INIT exp end exp end end EXPR exp end exp end end TERNARY exp end exp end end CONDITION exp EXPR exp NAME exp THEN end EXPR end NAME end ELSE exp end end EXPR exp end end TERNARY exp end end CONDITION exp EXPR exp NAME exp THEN end EXPR end NAME end ELSE end EXPR end NAME end EXPR end char pos NAME end NAME char pos COMMENT code below is needed because integer get chars is not public FOR for int r exp chars char pos digits r exp exp if exp break CONTROL INIT CONDITION INCR BLOCK DECL STMT TYPE int NAME int NAME r INIT exp EXPR exp NAME exp EXPR chars char pos digits r NAME chars char pos NAME chars INDEX char pos EXPR char pos NAME char pos NAME digits r NAME digits INDEX r EXPR r NAME r EXPR exp exp NAME exp NAME exp IF if exp break CONDITION exp EXPR exp NAME exp THEN break BLOCK BREAK break private JJ void NN to TO exponential JJ format NN root ROOT format case format to amod format exponential int NN first RB digit NN root ROOT digit advmod digit first int NN dec NN point NN root ROOT point compound point dec if IN end NN first RB digit NN root ROOT digit advmod digit first insert decimal point if more than one digit was produced root ROOT point compound point insert amod point decimal mark produced if advmod one more mwe more than nummod digit one nsubjpass produced digit auxpass produced was dep point produced int NN dot NN first RB digit NN root ROOT digit advmod digit first system NN arraycopy NN root ROOT arraycopy compound arraycopy system chars NNS dot NN chars NNS dot NN end NN dot NN chars NNS dot NN end NN chars NNS end NN e SYM char NN sign NN int NN exp NN dec NN point NN root ROOT point compound point dec if IN exp NN sign NN exp NN exp NN chars NNS end NN sign NN int NN char NN pos NNS root ROOT pos compound pos char exp NN end NN exp NN end NN end NN end NN char NN pos NNS root ROOT pos compound pos char code below is needed because integer get chars is not public root ROOT needed nsubjpass needed code advmod code below auxpass needed is mark get because nsubj get integer csubj public get dobj get chars cop public is neg public not ccomp needed public for IN int NN r NN exp NN chars NNS char NN pos NNS root ROOT pos compound pos char digits NNS r NN exp NN exp NN if IN exp NN break NN end break ANTONYM ANTONYM end produced ANTONYM ANTONYM point sign ANTONYM ANTONYM private public ANTONYM ANTONYM produced break ANTONYM ANTONYM
FUNCTION SPECIFIER final TYPE int NAME int NAME get attributes PARAMETER LIST int id PARAMETER int id TYPE int NAME int NAME id BLOCK EXPR ensure id id CALL ensure id id NAME ensure id ARGUMENT LIST ARGUMENT EXPR id NAME id RETURN return attribute array id EXPR attribute array id NAME attribute array id NAME attribute array INDEX id EXPR id NAME id final JJ int NN get VB attributes NNS root ROOT get dobj get attributes int NN id NN ensure VB id NN root ROOT ensure dobj ensure id id NN return NN attribute NN array NN root ROOT array compound array attribute id NN
FUNCTION SPECIFIER public TYPE int NAME int NAME get attributes PARAMETER LIST string name PARAMETER string name TYPE string NAME string NAME name BLOCK RETURN return find attribute slot name slot query get attributes EXPR find attribute slot name slot query get attributes CALL find attribute slot name slot query NAME find attribute slot ARGUMENT LIST ARGUMENT EXPR name NAME name ARGUMENT EXPR ARGUMENT EXPR slot query NAME slot query CALL get attributes NAME get attributes ARGUMENT LIST public NN int NN get VB attributes NNS root ROOT get dobj get attributes string NN name NN return NN find VB attribute NN slot NN root ROOT find compound slot attribute dobj find slot name NN slot NN query NN root ROOT query compound query slot get VB attributes NNS root ROOT get dobj get attributes
DECL STMT SPECIFIER private TYPE byte NAME byte NAME byte INDEX NAME name INIT null EXPR null private JJ byte NN name NN null JJ
DECL STMT SPECIFIER private SPECIFIER static TYPE final list string SPECIFIER final NAME list string NAME list ARGUMENT LIST ARGUMENT NAME string NAME empty string INIT collections empty list EXPR collections empty list CALL collections empty list NAME collections empty list NAME collections NAME empty list ARGUMENT LIST private JJ static JJ final JJ list NN string NN empty JJ string NN root ROOT string amod string empty collections NNS empty JJ list NN root ROOT list compound list collections amod list empty
DECL STMT TYPE string NAME string NAME is strict INIT org apache maven artifact repository metadata io is strict EXPR org apache maven artifact repository metadata io is strict string NN is VBZ strict JJ root ROOT strict cop strict is org NN apache NN maven NN artifact NN repository JJ metadata NN io NN is VBZ strict JJ root ROOT strict compound io org compound io apache compound io maven compound io artifact amod io repository compound io metadata nsubj strict io cop strict is
DECL STMT SPECIFIER private TYPE short NAME short NAME its flags private JJ short RB its PRP$ flags NNS root ROOT flags nmod poss flags its
DECL STMT SPECIFIER private TYPE final boolean SPECIFIER final NAME boolean NAME classes private JJ final JJ boolean NN classes NNS
DECL STMT SPECIFIER private TYPE final boolean SPECIFIER final NAME boolean NAME methods private JJ final JJ boolean NN methods NNS
DECL STMT SPECIFIER private TYPE int NAME int NAME successes INIT EXPR private JJ int NN successes NNS
DECL STMT SPECIFIER private TYPE final string SPECIFIER final NAME string NAME args private JJ final JJ string NN args NNS
FUNCTION SPECIFIER public TYPE int NAME int NAME is valid PARAMETER LIST BLOCK DECL STMT TYPE final long SPECIFIER final NAME long NAME current time INIT system current time millis EXPR system current time millis CALL system current time millis NAME system current time millis NAME system NAME current time millis ARGUMENT LIST IF if current time this expires the delay has not passed yet assuming source is valid return source validity valid CONDITION current time this expires EXPR current time this expires NAME current time NAME this expires NAME this NAME expires THEN the delay has not passed yet assuming source is valid return source validity valid BLOCK COMMENT the delay has not passed yet assuming source is valid RETURN return source validity valid EXPR source validity valid NAME source validity valid NAME source validity NAME valid COMMENT the delay has passed prepare for the next interval EXPR this expires current time this delay NAME this expires NAME this NAME expires NAME current time NAME this delay NAME this NAME delay RETURN return this delegate is valid EXPR this delegate is valid CALL this delegate is valid NAME this delegate is valid NAME this NAME delegate NAME is valid ARGUMENT LIST public NN int NN is VBZ valid JJ root ROOT valid cop valid is final JJ long RB current JJ time NN root ROOT time amod time current system NN current JJ time NN millis IN root ROOT time compound time system amod time current dep time millis if IN current JJ time NN root ROOT time amod time current this DT expires VBZ the delay has not passed yet assuming source is valid root ROOT passed det delay the nsubjpass passed delay aux passed has neg passed not advmod assuming yet xcomp passed assuming nsubj valid source cop valid is ccomp assuming valid return NN source NN validity NN valid JJ root ROOT valid compound validity source nsubj valid validity the delay has passed prepare for the next interval root ROOT passed det delay the nsubj passed delay aux passed has dobj passed prepare case interval for det interval the amod interval next nmod for prepare interval this DT expires VBZ current JJ time NN root ROOT time amod time current this DT delay NN return NN this DT delegate NN is VBZ valid JJ expires return ANTONYM ANTONYM has assuming ANTONYM ANTONYM has passed ANTONYM ANTONYM has prepare ANTONYM ANTONYM has return ANTONYM ANTONYM
FUNCTION SPECIFIER public TYPE dimension NAME dimension NAME set breadth PARAMETER LIST dimension target int source PARAMETER dimension target TYPE dimension NAME dimension NAME target PARAMETER int source TYPE int NAME int NAME source BLOCK IF if orientation vertical return new dimension source int target get height else return new dimension int target get width source CONDITION orientation vertical EXPR orientation vertical NAME orientation NAME vertical THEN return new dimension source int target get height BLOCK RETURN return new dimension source int target get height EXPR new dimension source int target get height CALL dimension source int target get height NAME dimension ARGUMENT LIST ARGUMENT EXPR source NAME source ARGUMENT EXPR int target get height NAME int CALL target get height NAME target get height NAME target NAME get height ARGUMENT LIST ELSE else return new dimension int target get width source BLOCK RETURN return new dimension int target get width source EXPR new dimension int target get width source CALL dimension int target get width source NAME dimension ARGUMENT LIST ARGUMENT EXPR int target get width NAME int CALL target get width NAME target get width NAME target NAME get width ARGUMENT LIST ARGUMENT EXPR source NAME source public NN dimension NN set VBN breadth NN root ROOT set dobj set breadth dimension NN target NN int NN source NN if IN orientation NN vertical JJ return NN new JJ dimension NN source NN int NN target NN get VB height NN root ROOT get nsubj get target dobj get height else RB return NN new JJ dimension NN int NN target NN get VB width NN root ROOT get nsubj get target dobj get width source NN new else SYNONYM SYNONYM
FUNCTION SPECIFIER public TYPE dimension NAME dimension NAME set length PARAMETER LIST dimension target dimension source PARAMETER dimension target TYPE dimension NAME dimension NAME target PARAMETER dimension source TYPE dimension NAME dimension NAME source BLOCK IF if orientation vertical return new dimension int target get width int source get height else return new dimension int source get width int target get height CONDITION orientation vertical EXPR orientation vertical NAME orientation NAME vertical THEN return new dimension int target get width int source get height BLOCK RETURN return new dimension int target get width int source get height EXPR new dimension int target get width int source get height CALL dimension int target get width int source get height NAME dimension ARGUMENT LIST ARGUMENT EXPR int target get width NAME int CALL target get width NAME target get width NAME target NAME get width ARGUMENT LIST ARGUMENT EXPR int source get height NAME int CALL source get height NAME source get height NAME source NAME get height ARGUMENT LIST ELSE else return new dimension int source get width int target get height BLOCK RETURN return new dimension int source get width int target get height EXPR new dimension int source get width int target get height CALL dimension int source get width int target get height NAME dimension ARGUMENT LIST ARGUMENT EXPR int source get width NAME int CALL source get width NAME source get width NAME source NAME get width ARGUMENT LIST ARGUMENT EXPR int target get height NAME int CALL target get height NAME target get height NAME target NAME get height ARGUMENT LIST public NN dimension NN set VBN length NN root ROOT set dobj set length dimension NN target NN dimension NN source NN if IN orientation NN vertical JJ return NN new JJ dimension NN int NN target NN get VB width NN root ROOT get nsubj get target dobj get width int NN source NN get VB height NN root ROOT get nsubj get source dobj get height else RB return NN new JJ dimension NN int NN source NN get VB width NN root ROOT get nsubj get source dobj get width int NN target NN get VB height NN root ROOT get nsubj get target dobj get height new else SYNONYM SYNONYM
FUNCTION SPECIFIER public TYPE dimension NAME dimension NAME set length PARAMETER LIST dimension target int source PARAMETER dimension target TYPE dimension NAME dimension NAME target PARAMETER int source TYPE int NAME int NAME source BLOCK IF if orientation vertical return new dimension int target get width source else return new dimension source int target get height CONDITION orientation vertical EXPR orientation vertical NAME orientation NAME vertical THEN return new dimension int target get width source BLOCK RETURN return new dimension int target get width source EXPR new dimension int target get width source CALL dimension int target get width source NAME dimension ARGUMENT LIST ARGUMENT EXPR int target get width NAME int CALL target get width NAME target get width NAME target NAME get width ARGUMENT LIST ARGUMENT EXPR source NAME source ELSE else return new dimension source int target get height BLOCK RETURN return new dimension source int target get height EXPR new dimension source int target get height CALL dimension source int target get height NAME dimension ARGUMENT LIST ARGUMENT EXPR source NAME source ARGUMENT EXPR int target get height NAME int CALL target get height NAME target get height NAME target NAME get height ARGUMENT LIST public NN dimension NN set VBN length NN root ROOT set dobj set length dimension NN target NN int NN source NN if IN orientation NN vertical JJ return NN new JJ dimension NN int NN target NN get VB width NN root ROOT get nsubj get target dobj get width source NN else RB return NN new JJ dimension NN source NN int NN target NN get VB height NN root ROOT get nsubj get target dobj get height new else SYNONYM SYNONYM
FUNCTION SPECIFIER public TYPE list NAME list NAME get expansion PARAMETER LIST BLOCK RETURN return f expansion EXPR f expansion NAME f expansion public NN list NN get VB expansion NN root ROOT get dobj get expansion return NN f LS expansion NN root ROOT f root f expansion
FUNCTION SPECIFIER public TYPE void NAME void NAME check collision PARAMETER LIST string before string after PARAMETER string before TYPE string NAME string NAME before PARAMETER string after TYPE string NAME string NAME after BLOCK DECL STMT TYPE boolean NAME boolean NAME collision INIT before null before equals short name after null after equals short name EXPR before null before equals short name after null after equals short name NAME before CALL before equals short name NAME before equals NAME before NAME equals ARGUMENT LIST ARGUMENT EXPR short name NAME short name NAME after CALL after equals short name NAME after equals NAME after NAME equals ARGUMENT LIST ARGUMENT EXPR short name NAME short name IF if collision if long name null long name get long name display name long name CONDITION collision EXPR collision NAME collision THEN if long name null long name get long name display name long name BLOCK IF if long name null long name get long name CONDITION long name null EXPR long name null NAME long name THEN long name get long name BLOCK EXPR long name get long name NAME long name CALL get long name NAME get long name ARGUMENT LIST EXPR display name long name NAME display name NAME long name public NN void NN check NN collision NN root ROOT collision compound collision check string NN before IN string NN after IN boolean NN collision NN before IN null JJ before IN equals VBZ root ROOT equals mark equals before short JJ name NN root ROOT name amod name short after IN null JJ after IN equals VBZ root ROOT equals mark equals after short JJ name NN root ROOT name amod name short if IN collision NN if IN long RB name NN root ROOT name amod name long null JJ long RB name NN root ROOT name amod name long get VB long RB name NN root ROOT get amod name long dobj get name display NN name NN root ROOT name compound name display long RB name NN root ROOT name amod name long
FUNCTION SPECIFIER protected TYPE void NAME void NAME get method bodies PARAMETER LIST compilation unit declaration unit int place PARAMETER compilation unit declaration unit TYPE compilation unit declaration NAME compilation unit declaration NAME unit PARAMETER int place TYPE int NAME int NAME place BLOCK COMMENT fill the methods bodies in order for the code to be generated IF if unit ignore method bodies unit ignore further investigation true return if initial diet parse did not work no need to dig into method bodies CONDITION unit ignore method bodies EXPR unit ignore method bodies NAME unit ignore method bodies NAME unit NAME ignore method bodies THEN unit ignore further investigation true return if initial diet parse did not work no need to dig into method bodies BLOCK EXPR unit ignore further investigation true NAME unit ignore further investigation NAME unit NAME ignore further investigation RETURN return COMMENT if initial diet parse did not work no need to dig into method bodies IF if place parse threshold return CONDITION place parse threshold EXPR place parse threshold NAME place NAME parse threshold THEN return BLOCK RETURN return COMMENT work already done COMMENT real parse of the method EXPR parser scanner set source buffer unit compilation result compilation unit get contents CALL parser scanner set source buffer unit compilation result compilation unit get contents NAME parser scanner set source buffer NAME parser NAME scanner NAME set source buffer ARGUMENT LIST ARGUMENT EXPR unit compilation result compilation unit get contents CALL unit compilation result compilation unit get contents NAME unit compilation result compilation unit get contents NAME unit NAME compilation result NAME compilation unit NAME get contents ARGUMENT LIST IF if unit types null for int i unit types length i unit types i parse method parser unit CONDITION unit types null EXPR unit types null NAME unit types NAME unit NAME types THEN for int i unit types length i unit types i parse method parser unit BLOCK FOR for int i unit types length i unit types i parse method parser unit CONTROL int i unit types length i INIT int i unit types length TYPE int NAME int NAME i INIT unit types length EXPR unit types length NAME unit types length NAME unit NAME types NAME length CONDITION i EXPR i NAME i INCR BLOCK EXPR unit types i parse method parser unit NAME unit types i NAME unit NAME types INDEX i EXPR i NAME i CALL parse method parser unit NAME parse method ARGUMENT LIST ARGUMENT EXPR parser NAME parser ARGUMENT EXPR unit NAME unit protected VBN void NN get VB method NN bodies NNS root ROOT get compound bodies method dobj get bodies compilation NN unit NN declaration NN root ROOT declaration compound declaration compilation compound declaration unit unit NN int NN place NN fill the methods bodies in order for the code to be generated root ROOT fill det bodies the compound bodies methods dobj fill bodies mark generated in mwe in order mark generated for det code the nsubjpass generated code mark generated to auxpass generated be advcl in order fill generated if IN unit NN ignore VB method NN bodies NNS root ROOT ignore nsubj ignore unit compound bodies method dobj ignore bodies unit NN ignore VB further RB investigation NN root ROOT ignore nsubj ignore unit advmod ignore further dobj ignore investigation true JJ return NN if IN initial JJ diet NN parse VB did VBD not RB work NN no DT need NN to TO dig NN into IN method NN bodies NNS if IN place NN parse VB threshold NN root ROOT parse dobj parse threshold return NN work NN already RB done VBN real parse of the method root ROOT parse amod parse real case method of det method the nmod of parse method parser NN scanner NN set VBN source NN buffer NN root ROOT set compound scanner parser nsubj set scanner compound buffer source dobj set buffer unit NN compilation NN result VBP compilation NN unit NN get VB contents NNS root ROOT result compound compilation unit nsubj result compilation compound unit compilation nsubj get unit ccomp result get dobj get contents if IN unit NN types NNS root ROOT types compound types unit null JJ for IN int NN i LS unit NN types NNS length NN root ROOT length compound types unit nsubj length types i LS unit NN types NNS root ROOT types compound types unit i LS parse VB method NN root ROOT parse dobj parse method parser NN unit NN bodies be ANTONYM ANTONYM did work ANTONYM ANTONYM fill need ANTONYM ANTONYM fill void ANTONYM ANTONYM order did ANTONYM ANTONYM order done ANTONYM ANTONYM place did ANTONYM ANTONYM place done ANTONYM ANTONYM work done ANTONYM ANTONYM
FUNCTION SPECIFIER public TYPE void NAME void NAME is valid PARAMETER LIST object selection status info res PARAMETER object selection TYPE object NAME object NAME object INDEX NAME selection PARAMETER status info res TYPE status info NAME status info NAME res BLOCK COMMENT only single selection IF if selection length selection instanceof i file res set ok else res set error CONDITION selection length selection instanceof i file EXPR selection length selection instanceof i file NAME selection length NAME selection NAME length NAME selection NAME selection INDEX EXPR NAME i file THEN res set ok BLOCK EXPR res set ok CALL res set ok NAME res set ok NAME res NAME set ok ARGUMENT LIST ELSE else res set error BLOCK EXPR res set error CALL res set error NAME res set error NAME res NAME set error ARGUMENT LIST ARGUMENT EXPR COMMENT non nls public NN void NN is VBZ valid JJ root ROOT valid cop valid is object NN selection NN status NN info NN root ROOT info compound info status res NNS only single selection root ROOT selection advmod selection only amod selection single if IN selection NN length NN root ROOT length compound length selection selection NN instanceof NN i LS file NN root ROOT i root i file res JJ set NN ok NN root ROOT ok amod ok res compound ok set else RB res NNS set VBD error NN root ROOT set nsubj set res dobj set error non JJ nls NNS root ROOT nls amod nls non public single ANTONYM ANTONYM
FUNCTION SPECIFIER public TYPE void NAME void NAME java to native PARAMETER LIST object object transfer data transfer data PARAMETER object object TYPE object NAME object NAME object PARAMETER transfer data transfer data TYPE transfer data NAME transfer data NAME transfer data BLOCK DECL STMT TYPE byte NAME byte NAME byte INDEX NAME check INIT type name get bytes EXPR type name get bytes CALL type name get bytes NAME type name get bytes NAME type name NAME get bytes ARGUMENT LIST EXPR super java to native check transfer data CALL super java to native check transfer data NAME super java to native NAME super NAME java to native ARGUMENT LIST ARGUMENT EXPR check NAME check ARGUMENT EXPR transfer data NAME transfer data public NN void NN java NN to TO native JJ root ROOT java case native to nmod to java native object NN object NN transfer NN data NNS root ROOT data compound data transfer transfer NN data NNS root ROOT data compound data transfer byte NN check NN type NN name NN root ROOT name compound name type get VB bytes NNS root ROOT get dobj get bytes super JJ java NN to TO native JJ check NN transfer NN data NNS root ROOT data compound data transfer
FUNCTION SPECIFIER public TYPE boolean NAME boolean NAME get stats PARAMETER LIST BLOCK RETURN return stats EXPR stats NAME stats public NN boolean NN get VB stats NNS root ROOT get dobj get stats return NN stats NNS
COMMENT returns true if this listener has a target for a back navigation only one listener needs to return true for the back button to be enabled FUNCTION SPECIFIER public TYPE boolean NAME boolean NAME is navigate forward enabled PARAMETER LIST BLOCK DECL STMT TYPE boolean NAME boolean NAME enabled INIT false EXPR false IF if is forward enabled enabled true else if is forward enabled enabled navigate forward false null CONDITION is forward enabled EXPR is forward enabled NAME is forward enabled THEN enabled true BLOCK EXPR enabled true NAME enabled ELSE else if is forward enabled enabled navigate forward false null BLOCK IF if is forward enabled enabled navigate forward false null CONDITION is forward enabled EXPR is forward enabled NAME is forward enabled THEN enabled navigate forward false null BLOCK EXPR enabled navigate forward false null NAME enabled CALL navigate forward false NAME navigate forward ARGUMENT LIST ARGUMENT EXPR false RETURN return enabled EXPR enabled NAME enabled returns true if this listener has a target for root ROOT returns amod returns true mark has if det listener this nsubj has listener advcl if true has det target a dobj has target acl target for a back navigation only one listener needs to root ROOT navigation det navigation a amod navigation back advmod one only nummod listener one nsubj needs listener acl relcl navigation needs nmod needs to a back navigation only one listener needs to root ROOT navigation det navigation a amod navigation back advmod one only nummod listener one nsubj needs listener acl relcl navigation needs nmod needs to return true for the back button to be enabled root ROOT return amod return true mark enabled for det button the amod button back nsubjpass enabled button mark enabled to auxpass enabled be advcl to true enabled public NN boolean NN is VBZ navigate VB forward RB enabled VBD root ROOT navigate aux navigate is advmod navigate forward dep navigate enabled boolean NN enabled VBD false JJ if IN is VBZ forward RB enabled VBN root ROOT enabled auxpass enabled is advmod enabled forward enabled VBD true JJ else RB if IN is VBZ forward RB enabled VBN root ROOT enabled auxpass enabled is advmod enabled forward enabled VBD navigate VB forward RB root ROOT navigate advmod navigate forward false JJ null JJ return NN enabled VBD has needs ANTONYM ANTONYM has return ANTONYM ANTONYM returns has ANTONYM ANTONYM true false ANTONYM ANTONYM false null SYNONYM SYNONYM
DECL STMT TYPE vector NAME vector NAME target vector NN target NN
DECL STMT TYPE int NAME int NAME int INDEX NAME is reached int NN is VBZ reached VBN root ROOT reached auxpass reached is
DECL STMT TYPE m association end NAME m association end NAME start INIT null EXPR null m NN association NN end NN root ROOT end compound end m compound end association start NN null JJ
COMMENT configuration default exclude pattern ie href action frame src DECL STMT SPECIFIER public TYPE final static string SPECIFIER final SPECIFIER static NAME string NAME include name default INIT href action frame src EXPR href action frame src configuration default exclude pattern root ROOT exclude compound default configuration nsubj exclude default dobj exclude pattern ie href action frame src root ROOT src compound src ie compound src href compound src action compound src frame ie href action frame src root ROOT src compound src ie compound src href compound src action compound src frame ie href action frame src root ROOT src compound src ie compound src href compound src action compound src frame public NN final JJ static JJ string NN include VBP name NN default NN root ROOT include compound default name dobj include default href NN action NN frame NN src NN configuration frame ANTONYM ANTONYM configuration pattern ANTONYM ANTONYM exclude include ANTONYM ANTONYM frame name ANTONYM ANTONYM pattern frame ANTONYM ANTONYM pattern name ANTONYM ANTONYM
DECL STMT TYPE int NAME int NAME references int NN references NNS
COMMENT returns the list of sub keys DECL STMT TYPE bool NAME bool NAME get sub keys ARGUMENT LIST ARGUMENT EXPR c string list subkeys NAME c string list NAME subkeys bool NN get VB sub JJ keys NNS root ROOT get amod keys sub dobj get keys c NN string NN list NN root ROOT list compound list c compound list string subkeys NNS returns NNS the DT list NN of IN sub NN keys NNS list keys ANTONYM ANTONYM
FUNCTION SPECIFIER public TYPE int NAME int NAME get rows PARAMETER LIST BLOCK RETURN return rows EXPR rows NAME rows public NN int NN get VB rows NNS root ROOT get dobj get rows return NN rows NNS
DECL STMT SPECIFIER private TYPE string NAME string NAME types private JJ string NN types NNS
FUNCTION SPECIFIER public TYPE string NAME string NAME get types PARAMETER LIST BLOCK RETURN return types EXPR types NAME types public NN string NN get VB types NNS root ROOT get dobj get types return NN types NNS
DECL STMT SPECIFIER private TYPE double NAME double NAME double INDEX NAME peak private JJ double RB peak NN
DECL STMT SPECIFIER private TYPE int NAME int NAME nulls private JJ int NN nulls NNS
FUNCTION DECL public string is dependency resolution required SPECIFIER public TYPE string NAME string NAME is dependency resolution required PARAMETER LIST public NN string NN is VBZ dependency NN resolution NN required VBN root ROOT required auxpass required is compound resolution dependency nsubjpass required resolution
COMMENT returns a uuid unique for this member over all sessions if the member crashes and restarts the unique id will be different return byte FUNCTION DECL public byte get unique id SPECIFIER public TYPE byte NAME byte NAME byte INDEX NAME get unique id PARAMETER LIST returns a uuid unique for this member over all sessions root ROOT returns det unique a amod unique uuid dep returns unique case member for det member this nmod for unique member case sessions over det sessions all nmod over unique sessions if the member crashes and restarts the unique id will be different root ROOT different mark crashes if det member the nsubj crashes member nsubj restarts member csubj different crashes cc crashes and conj and crashes restarts csubj different restarts det id the amod id unique dobj restarts id aux different will cop different be return byte root ROOT byte compound byte return public NN byte NN get VB unique JJ id NN root ROOT get amod id unique dobj get id all over ANTONYM ANTONYM unique different SYNONYM SYNONYM
FUNCTION SPECIFIER public TYPE byte NAME byte NAME byte INDEX NAME get command PARAMETER LIST BLOCK RETURN return command EXPR command NAME command public NN byte NN get VB command NN root ROOT get dobj get command return NN command NN
DECL STMT SPECIFIER protected SPECIFIER transient TYPE byte NAME byte NAME byte INDEX NAME map context name protected VBN transient JJ byte NN map NN context NN name NN root ROOT name compound name map compound name context
COMMENT empty string collection to serve as the basis for empty enumerations DECL STMT SPECIFIER private SPECIFIER static TYPE final list string SPECIFIER final NAME list string NAME list ARGUMENT LIST ARGUMENT NAME string NAME empty string INIT collections empty list EXPR collections empty list CALL collections empty list NAME collections empty list NAME collections NAME empty list ARGUMENT LIST empty string collection to serve as the basis for empty enumerations root ROOT collection amod collection empty compound collection string mark serve to acl to collection serve case basis as det basis the nmod as serve basis case enumerations for amod enumerations empty nmod for basis enumerations private JJ static JJ final JJ list NN string NN empty JJ string NN root ROOT string amod string empty collections NNS empty JJ list NN root ROOT list compound list collections amod list empty
FUNCTION SPECIFIER public TYPE push builder NAME push builder NAME set header PARAMETER LIST string name string value PARAMETER string name TYPE string NAME string NAME name PARAMETER string value TYPE string NAME string NAME value BLOCK DECL STMT TYPE list string NAME list string NAME list ARGUMENT LIST ARGUMENT NAME string NAME values INIT headers get name EXPR headers get name CALL headers get name NAME headers get NAME headers NAME get ARGUMENT LIST ARGUMENT EXPR name NAME name IF if values null values new array list headers put name values else values clear CONDITION values null EXPR values null NAME values THEN values new array list headers put name values BLOCK EXPR values new array list NAME values CALL array list NAME array list NAME array list ARGUMENT LIST ARGUMENT LIST EXPR headers put name values CALL headers put name values NAME headers put NAME headers NAME put ARGUMENT LIST ARGUMENT EXPR name NAME name ARGUMENT EXPR values NAME values ELSE else values clear BLOCK EXPR values clear CALL values clear NAME values clear NAME values NAME clear ARGUMENT LIST EXPR values add value CALL values add value NAME values add NAME values NAME add ARGUMENT LIST ARGUMENT EXPR value NAME value RETURN return this EXPR this NAME this public NN push NN builder NN root ROOT builder compound builder push set VBN header NN root ROOT set dobj set header string NN name NN string NN value NN list NN string NN values NNS headers NNS get VBP root ROOT get nsubj get headers name NN if IN values NNS null JJ values NNS new JJ array NN list NN root ROOT list compound list array headers NNS put VBD root ROOT put nsubj put headers name NN values NNS else RB values NNS clear JJ root ROOT clear nsubj clear values values NNS add VBP root ROOT add nsubj add values value NN return NN this DT clear return ANTONYM ANTONYM get add ANTONYM ANTONYM get clear ANTONYM ANTONYM get put ANTONYM ANTONYM get return ANTONYM ANTONYM name clear ANTONYM ANTONYM name get ANTONYM ANTONYM public clear ANTONYM ANTONYM string get ANTONYM ANTONYM new else SYNONYM SYNONYM
FUNCTION SPECIFIER public TYPE v NAME v NAME set value PARAMETER LIST v value PARAMETER v value TYPE v NAME v NAME value BLOCK DECL STMT TYPE v NAME v NAME old INIT this value EXPR this value NAME this value NAME this NAME value EXPR this value value NAME this value NAME this NAME value NAME value RETURN return old EXPR old NAME old public NN v LS set VBN value NN root ROOT set dobj set value v LS value NN v LS old JJ this DT value NN this DT value NN value NN return NN old JJ
FUNCTION SPECIFIER public TYPE k NAME k NAME set key PARAMETER LIST k key PARAMETER k key TYPE k NAME k NAME key BLOCK DECL STMT TYPE k NAME k NAME old INIT this key EXPR this key NAME this key NAME this NAME key EXPR this key key NAME this key NAME this NAME key NAME key RETURN return old EXPR old NAME old public NN k NN set VBN key NN root ROOT set dobj set key k NN key NN k NN old JJ this DT key NN this DT key NN key NN return NN old JJ k key ANTONYM ANTONYM
COMMENT specialization of sort at byte for key prefix arrays FUNCTION SPECIFIER private SPECIFIER static TYPE void NAME void NAME sort key prefix array at byte PARAMETER LIST long array array long num records long counts int byte idx long in index long out index boolean desc boolean signed PARAMETER long array array TYPE long array NAME long array NAME array PARAMETER long num records TYPE long NAME long NAME num records PARAMETER long counts TYPE long NAME long NAME long INDEX NAME counts PARAMETER int byte idx TYPE int NAME int NAME byte idx PARAMETER long in index TYPE long NAME long NAME in index PARAMETER long out index TYPE long NAME long NAME out index PARAMETER boolean desc TYPE boolean NAME boolean NAME desc PARAMETER boolean signed TYPE boolean NAME boolean NAME signed BLOCK ASSERT assert counts length EXPR counts length NAME counts length NAME counts NAME length DECL STMT TYPE long NAME long NAME long INDEX NAME offsets INIT transform counts to offsets counts num records array get base offset out index l desc signed EXPR transform counts to offsets counts num records array get base offset out index l desc signed CALL transform counts to offsets counts num records array get base offset out index l desc signed NAME transform counts to offsets ARGUMENT LIST ARGUMENT EXPR counts NAME counts ARGUMENT EXPR num records NAME num records ARGUMENT EXPR array get base offset out index l CALL array get base offset NAME array get base offset NAME array NAME get base offset ARGUMENT LIST NAME out index ARGUMENT EXPR ARGUMENT EXPR desc NAME desc ARGUMENT EXPR signed NAME signed DECL STMT TYPE object NAME object NAME base object INIT array get base object EXPR array get base object CALL array get base object NAME array get base object NAME array NAME get base object ARGUMENT LIST DECL STMT TYPE long NAME long NAME base offset INIT array get base offset in index l EXPR array get base offset in index l CALL array get base offset NAME array get base offset NAME array NAME get base offset ARGUMENT LIST NAME in index DECL STMT TYPE long NAME long NAME max offset INIT base offset num records l EXPR base offset num records l NAME base offset NAME num records FOR for long offset base offset offset max offset offset long key platform get long base object offset long prefix platform get long base object offset int bucket int prefix byte idx xff long dest offsets bucket platform put long base object dest key platform put long base object dest prefix offsets bucket CONTROL long offset base offset offset max offset offset INIT long offset base offset TYPE long NAME long NAME offset INIT base offset EXPR base offset NAME base offset CONDITION offset max offset EXPR offset max offset NAME offset NAME max offset INCR offset EXPR offset NAME offset BLOCK DECL STMT TYPE long NAME long NAME key INIT platform get long base object offset EXPR platform get long base object offset CALL platform get long base object offset NAME platform get long NAME platform NAME get long ARGUMENT LIST ARGUMENT EXPR base object NAME base object ARGUMENT EXPR offset NAME offset DECL STMT TYPE long NAME long NAME prefix INIT platform get long base object offset EXPR platform get long base object offset CALL platform get long base object offset NAME platform get long NAME platform NAME get long ARGUMENT LIST ARGUMENT EXPR base object NAME base object ARGUMENT EXPR offset NAME offset DECL STMT TYPE int NAME int NAME bucket INIT int prefix byte idx xff EXPR int prefix byte idx xff CALL int prefix byte idx xff NAME int ARGUMENT LIST ARGUMENT EXPR prefix byte idx xff NAME prefix NAME byte idx DECL STMT TYPE long NAME long NAME dest INIT offsets bucket EXPR offsets bucket NAME offsets bucket NAME offsets INDEX bucket EXPR bucket NAME bucket EXPR platform put long base object dest key CALL platform put long base object dest key NAME platform put long NAME platform NAME put long ARGUMENT LIST ARGUMENT EXPR base object NAME base object ARGUMENT EXPR dest NAME dest ARGUMENT EXPR key NAME key EXPR platform put long base object dest prefix CALL platform put long base object dest prefix NAME platform put long NAME platform NAME put long ARGUMENT LIST ARGUMENT EXPR base object NAME base object ARGUMENT EXPR dest NAME dest ARGUMENT EXPR prefix NAME prefix EXPR offsets bucket NAME offsets bucket NAME offsets INDEX bucket EXPR bucket NAME bucket specialization of sort at byte for key prefix arrays root ROOT specialization case sort of nmod of specialization sort case byte at nmod at specialization byte case arrays for amod arrays key compound arrays prefix nmod for byte arrays private JJ static JJ void NN sort NN key JJ prefix NN array NN at IN byte NN root ROOT array compound array sort amod array key compound array prefix case byte at nmod at array byte long RB array NN root ROOT array advmod array long array NN long RB num NN records NNS root ROOT records compound records num long RB counts NNS int NN byte NN idx NN root ROOT idx compound idx byte long RB in IN index NN root ROOT index case index in long RB out IN index NN root ROOT index case index out boolean NN desc NN boolean NN signed VBN assert VB counts NNS length NN root ROOT length compound length counts long RB offsets NNS transform VB counts NNS to TO offsets NNS root ROOT transform dobj transform counts case offsets to nmod to transform offsets counts NNS num NN records NNS root ROOT records compound records num array NN get VB base JJ offset VBN root ROOT array acl array get xcomp get base dep base offset out IN index NN root ROOT index case index out l NN desc NN signed VBN object NN base NN object NN root ROOT object compound object base array NN get VB base JJ object NN root ROOT get nsubj get array amod object base dobj get object long RB base NN offset VBD root ROOT offset nsubj offset base array NN get VB base JJ offset VBN root ROOT array acl array get xcomp get base dep base offset in IN index NN root ROOT index case index in l NN long RB max NN offset VBD root ROOT offset nsubj offset max base NN offset VBD root ROOT offset nsubj offset base num NN records NNS root ROOT records compound records num l NN for IN long RB offset VBN base NN offset VBD root ROOT offset nsubj offset base offset VBN max NN offset VBD root ROOT offset nsubj offset max offset VBN long RB key NN platform NN get VB long RB root ROOT get nsubj get platform advmod get long base NN object NN root ROOT object compound object base offset VBN long RB prefix NN platform NN get VB long RB root ROOT get nsubj get platform advmod get long base NN object NN root ROOT object compound object base offset VBN int NN bucket NN int NN prefix NN byte NN idx NN root ROOT idx compound idx byte xff NN long RB dest IN offsets NNS bucket NN platform NN put VBD long RB root ROOT put nsubj put platform advmod put long base NN object NN root ROOT object compound object base dest IN key NN platform NN put VBD long RB root ROOT put nsubj put platform advmod put long base NN object NN root ROOT object compound object base dest IN prefix NN offsets NNS bucket NN dest key ANTONYM ANTONYM l key ANTONYM ANTONYM l dest SYNONYM SYNONYM
DECL STMT SPECIFIER private SPECIFIER static TYPE final string SPECIFIER final NAME string NAME string INDEX NAME odt file private JJ static JJ final JJ string NN odt NN file NN root ROOT file compound file odt private JJ static JJ final JJ string NN odt NN file NN root ROOT file compound file odt
DECL STMT SPECIFIER private SPECIFIER static TYPE final string SPECIFIER final NAME string NAME string INDEX NAME odt file with metadata private JJ static JJ final JJ string NN odt NN file NN with IN metadata NN root ROOT file compound file odt case metadata with nmod with file metadata
DECL STMT SPECIFIER private SPECIFIER static TYPE final string SPECIFIER final NAME string NAME string INDEX NAME odt file with min text len private JJ static JJ final JJ string NN odt NN file NN with IN min NN text NN len NN root ROOT file compound file odt case len with compound len min compound len text nmod with file len
DECL STMT SPECIFIER private SPECIFIER static TYPE final string SPECIFIER final NAME string NAME string INDEX NAME pdf zip file private JJ static JJ final JJ string NN pdf NN zip NN file NN root ROOT file compound file pdf compound file zip
DECL STMT SPECIFIER private SPECIFIER static TYPE final string SPECIFIER final NAME string NAME string INDEX NAME pdf file private JJ static JJ final JJ string NN pdf NN file NN root ROOT file compound file pdf
DECL STMT SPECIFIER private SPECIFIER static TYPE final list string SPECIFIER final NAME list string NAME list ARGUMENT LIST ARGUMENT NAME string NAME odt file private JJ static JJ final JJ list NN string NN odt NN file NN root ROOT file compound file odt
FUNCTION DECL abstract builder k v set configuration serializable configuration configuration SPECIFIER abstract TYPE builder k v NAME builder k v NAME builder ARGUMENT LIST ARGUMENT NAME k ARGUMENT NAME v NAME set configuration PARAMETER LIST serializable configuration configuration PARAMETER serializable configuration configuration TYPE serializable configuration NAME serializable configuration NAME configuration abstract JJ builder NN k NN v LS set VBN configuration NN root ROOT set dobj set configuration serializable JJ configuration NN root ROOT configuration amod configuration serializable configuration NN k v SYNONYM SYNONYM
FUNCTION DECL abstract builder k v set key translation function simple function k function SPECIFIER abstract TYPE builder k v NAME builder k v NAME builder ARGUMENT LIST ARGUMENT NAME k ARGUMENT NAME v NAME set key translation function PARAMETER LIST simple function k function PARAMETER simple function k function TYPE simple function k NAME simple function k NAME simple function ARGUMENT LIST ARGUMENT NAME ARGUMENT NAME k NAME function abstract JJ builder NN k NN v LS set VBN key JJ translation NN function NN root ROOT set amod function key compound function translation dobj set function simple JJ function NN root ROOT function amod function simple k NN function NN k v SYNONYM SYNONYM
FUNCTION DECL abstract builder k v set value translation function simple function v function SPECIFIER abstract TYPE builder k v NAME builder k v NAME builder ARGUMENT LIST ARGUMENT NAME k ARGUMENT NAME v NAME set value translation function PARAMETER LIST simple function v function PARAMETER simple function v function TYPE simple function v NAME simple function v NAME simple function ARGUMENT LIST ARGUMENT NAME ARGUMENT NAME v NAME function abstract JJ builder NN k NN v LS set VBN value NN translation NN function NN root ROOT set compound function value compound function translation dobj set function simple JJ function NN root ROOT function amod function simple v LS function NN k v SYNONYM SYNONYM
FUNCTION DECL abstract builder k v set key type descriptor type descriptor k key type descriptor SPECIFIER abstract TYPE builder k v NAME builder k v NAME builder ARGUMENT LIST ARGUMENT NAME k ARGUMENT NAME v NAME set key type descriptor PARAMETER LIST type descriptor k key type descriptor PARAMETER type descriptor k key type descriptor TYPE type descriptor k NAME type descriptor k NAME type descriptor ARGUMENT LIST ARGUMENT NAME k NAME key type descriptor abstract JJ builder NN k NN v LS set VBN key JJ type NN descriptor NN root ROOT set amod descriptor key compound descriptor type dobj set descriptor type NN descriptor NN root ROOT descriptor compound descriptor type k NN key JJ type NN descriptor NN root ROOT descriptor amod descriptor key compound descriptor type k v SYNONYM SYNONYM
FUNCTION DECL abstract builder k v set value type descriptor type descriptor v value type descriptor SPECIFIER abstract TYPE builder k v NAME builder k v NAME builder ARGUMENT LIST ARGUMENT NAME k ARGUMENT NAME v NAME set value type descriptor PARAMETER LIST type descriptor v value type descriptor PARAMETER type descriptor v value type descriptor TYPE type descriptor v NAME type descriptor v NAME type descriptor ARGUMENT LIST ARGUMENT NAME v NAME value type descriptor abstract JJ builder NN k NN v LS set VBN value NN type NN descriptor NN root ROOT set compound descriptor value compound descriptor type dobj set descriptor type NN descriptor NN root ROOT descriptor compound descriptor type v LS value NN type NN descriptor NN root ROOT descriptor compound descriptor value compound descriptor type k v SYNONYM SYNONYM
FUNCTION DECL abstract builder k v set input format class type descriptor input format class SPECIFIER abstract TYPE builder k v NAME builder k v NAME builder ARGUMENT LIST ARGUMENT NAME k ARGUMENT NAME v NAME set input format class PARAMETER LIST type descriptor input format class PARAMETER type descriptor input format class TYPE type descriptor NAME type descriptor NAME type descriptor ARGUMENT LIST ARGUMENT NAME NAME input format class abstract JJ builder NN k NN v LS set VBN input NN format NN class NN root ROOT set compound class input compound class format dobj set class type NN descriptor NN root ROOT descriptor compound descriptor type input NN format NN class NN root ROOT class compound class input compound class format k v SYNONYM SYNONYM
FUNCTION DECL abstract builder k v set input format key class type descriptor input format key class SPECIFIER abstract TYPE builder k v NAME builder k v NAME builder ARGUMENT LIST ARGUMENT NAME k ARGUMENT NAME v NAME set input format key class PARAMETER LIST type descriptor input format key class PARAMETER type descriptor input format key class TYPE type descriptor NAME type descriptor NAME type descriptor ARGUMENT LIST ARGUMENT NAME NAME input format key class abstract JJ builder NN k NN v LS set VBN input NN format NN key JJ class NN root ROOT set compound class input compound class format amod class key dobj set class type NN descriptor NN root ROOT descriptor compound descriptor type input NN format NN key JJ class NN root ROOT class compound class input compound class format amod class key k v SYNONYM SYNONYM
FUNCTION DECL abstract builder k v set input format value class type descriptor input format value class SPECIFIER abstract TYPE builder k v NAME builder k v NAME builder ARGUMENT LIST ARGUMENT NAME k ARGUMENT NAME v NAME set input format value class PARAMETER LIST type descriptor input format value class PARAMETER type descriptor input format value class TYPE type descriptor NAME type descriptor NAME type descriptor ARGUMENT LIST ARGUMENT NAME NAME input format value class abstract JJ builder NN k NN v LS set VBN input NN format NN value NN class NN root ROOT set compound class input compound class format compound class value dobj set class type NN descriptor NN root ROOT descriptor compound descriptor type input NN format NN value NN class NN root ROOT class compound class input compound class format compound class value k v SYNONYM SYNONYM
COMMENT sets the link table reference project id of the provided table reference to the id of the default project if the table reference does not have a project id specified FUNCTION SPECIFIER private TYPE table reference NAME table reference NAME set default project if absent PARAMETER LIST big query options bq options table reference table reference PARAMETER big query options bq options TYPE big query options NAME big query options NAME bq options PARAMETER table reference table reference TYPE table reference NAME table reference NAME table reference BLOCK IF if strings is null or empty table reference get project id check state strings is null or empty bq options get project no project id set in s or s cannot construct a complete s table reference class get simple name big query options class get simple name table reference class get simple name log info project id not set in using default project from table reference class get simple name big query options class get simple name table reference set project id bq options get project CONDITION strings is null or empty table reference get project id EXPR strings is null or empty table reference get project id CALL strings is null or empty table reference get project id NAME strings is null or empty NAME strings NAME is null or empty ARGUMENT LIST ARGUMENT EXPR table reference get project id CALL table reference get project id NAME table reference get project id NAME table reference NAME get project id ARGUMENT LIST THEN check state strings is null or empty bq options get project no project id set in s or s cannot construct a complete s table reference class get simple name big query options class get simple name table reference class get simple name log info project id not set in using default project from table reference class get simple name big query options class get simple name table reference set project id bq options get project BLOCK EXPR check state strings is null or empty bq options get project no project id set in s or s cannot construct a complete s table reference class get simple name big query options class get simple name table reference class get simple name CALL check state strings is null or empty bq options get project no project id set in s or s cannot construct a complete s table reference class get simple name big query options class get simple name table reference class get simple name NAME check state ARGUMENT LIST ARGUMENT EXPR strings is null or empty bq options get project CALL strings is null or empty bq options get project NAME strings is null or empty NAME strings NAME is null or empty ARGUMENT LIST ARGUMENT EXPR bq options get project CALL bq options get project NAME bq options get project NAME bq options NAME get project ARGUMENT LIST ARGUMENT EXPR no project id set in s or s cannot construct a complete s ARGUMENT EXPR table reference class get simple name CALL table reference class get simple name NAME table reference class get simple name NAME table reference NAME class get simple name NAME class NAME get simple name ARGUMENT LIST ARGUMENT EXPR big query options class get simple name CALL big query options class get simple name NAME big query options class get simple name NAME big query options NAME class get simple name NAME class NAME get simple name ARGUMENT LIST ARGUMENT EXPR table reference class get simple name CALL table reference class get simple name NAME table reference class get simple name NAME table reference NAME class get simple name NAME class NAME get simple name ARGUMENT LIST EXPR log info project id not set in using default project from table reference class get simple name big query options class get simple name CALL log info project id not set in using default project from table reference class get simple name big query options class get simple name NAME log info NAME log NAME info ARGUMENT LIST ARGUMENT EXPR project id not set in using default project from ARGUMENT EXPR table reference class get simple name CALL table reference class get simple name NAME table reference class get simple name NAME table reference NAME class get simple name NAME class NAME get simple name ARGUMENT LIST ARGUMENT EXPR big query options class get simple name CALL big query options class get simple name NAME big query options class get simple name NAME big query options NAME class get simple name NAME class NAME get simple name ARGUMENT LIST EXPR table reference set project id bq options get project CALL table reference set project id bq options get project NAME table reference set project id NAME table reference NAME set project id ARGUMENT LIST ARGUMENT EXPR bq options get project CALL bq options get project NAME bq options get project NAME bq options NAME get project ARGUMENT LIST RETURN return table reference EXPR table reference NAME table reference private JJ table NN reference NN root ROOT reference compound reference table set VBN default NN project NN if IN absent JJ root ROOT project amod project set compound project default mark absent if dep project absent
FUNCTION DECL abstract builder t set max files per bundle integer max files per bundle SPECIFIER abstract TYPE builder t NAME builder t NAME builder ARGUMENT LIST ARGUMENT NAME t NAME set max files per bundle PARAMETER LIST integer max files per bundle PARAMETER integer max files per bundle TYPE integer NAME integer NAME max files per bundle abstract JJ builder NN t NN set VBN max NN files NNS per IN bundle NN root ROOT set compound files max dobj set files case bundle per nmod per files bundle integer NN max NN files NNS per IN bundle NN root ROOT files compound files max case bundle per nmod per files bundle
FUNCTION DECL abstract builder t set method method method SPECIFIER abstract TYPE builder t NAME builder t NAME builder ARGUMENT LIST ARGUMENT NAME t NAME set method PARAMETER LIST method method PARAMETER method method TYPE method NAME method NAME method abstract JJ builder NN t NN set NN method NN root ROOT method compound method set method NN method NN
DECL STMT SPECIFIER private SPECIFIER static TYPE final string SPECIFIER final NAME string NAME gearpump serializers INIT gearpump serializers EXPR gearpump serializers private JJ static JJ final JJ string NN gearpump NN serializers NNS root ROOT serializers compound serializers gearpump gearpump NN serializers NNS root ROOT serializers compound serializers gearpump
DECL STMT SPECIFIER static TYPE final string SPECIFIER final NAME string NAME string INDEX NAME expected result static JJ final JJ string NN expected VBN result NN root ROOT result amod result expected
DECL STMT SPECIFIER protected SPECIFIER static TYPE final list serializable function instant instant SPECIFIER final NAME list serializable function instant instant NAME list ARGUMENT LIST ARGUMENT NAME serializable function instant instant NAME serializable function ARGUMENT LIST ARGUMENT NAME instant ARGUMENT NAME instant NAME identity INIT immutable list serializable function instant instant of EXPR immutable list serializable function instant instant of NAME immutable list NAME immutable list NAME serializable function instant instant NAME serializable function ARGUMENT LIST ARGUMENT NAME instant ARGUMENT NAME instant CALL of NAME of ARGUMENT LIST protected VBN static JJ final JJ list NN serializable JJ function NN root ROOT function amod function serializable instant NN instant NN identity NN immutable JJ list NN root ROOT list amod list immutable serializable JJ function NN root ROOT function amod function serializable instant NN instant NN of IN
COMMENT called when a new or active window is now known to be active ensure that if it is new then it becomes active with itself as its only state address window FUNCTION DECL void ensure window is active w window TYPE void NAME void NAME ensure window is active PARAMETER LIST w window PARAMETER w window TYPE w NAME w NAME window called when a new or active window is now known to be active root ROOT called advmod known when det window a amod window new cc new or conj or new active amod window active nsubjpass known window nsubj xsubj active window auxpass known is advmod known now advcl called known mark active to cop active be xcomp known active ensure that if it is new then it becomes active with itself as its only state address root ROOT ensure mark becomes that mark new if nsubj new it cop new is advcl if becomes new advmod becomes then nsubj becomes it ccomp ensure becomes xcomp becomes active case itself with nmod with active itself case address as nmod poss address its amod address only compound address state nmod as becomes address window void NN ensure VB window NN is VBZ active JJ root ROOT active csubj active ensure dobj ensure window cop active is w NN window NN is known ANTONYM ANTONYM known be ANTONYM ANTONYM
COMMENT called when an incoming element indicates it is a member of code window but before we have started processing that element if code window is not already known to be active then add it as new FUNCTION DECL void ensure window exists w window TYPE void NAME void NAME ensure window exists PARAMETER LIST w window PARAMETER w window TYPE w NAME w NAME window called when an incoming element indicates it is a member of code window but before we root ROOT called advmod indicates when det element an amod element incoming nsubj indicates element advcl called indicates nsubj member it cop member is det member a ccomp indicates member case window of compound window code nmod of member window cc indicates but case we before advcl called we conj but indicates we have started processing that element if code window is not already known to be active root ROOT started aux started have xcomp started processing det element that dobj processing element mark known if compound window code nsubjpass known window nsubj xsubj active window auxpass known is neg known not advmod known already advcl if started known mark active to cop active be xcomp known active have started processing that element if code window is not already known to be active root ROOT started aux started have xcomp started processing det element that dobj processing element mark known if compound window code nsubjpass known window nsubj xsubj active window auxpass known is neg known not advmod known already advcl if started known mark active to cop active be xcomp known active then add it as new root ROOT add advmod add then dobj add it case new as advcl as add new void NN ensure VB window NN exists VBZ root ROOT exists csubj exists ensure dobj ensure window w NN window NN add started ANTONYM ANTONYM have known ANTONYM ANTONYM have started ANTONYM ANTONYM is known ANTONYM ANTONYM known be ANTONYM ANTONYM
DECL STMT SPECIFIER private SPECIFIER static TYPE final string SPECIFIER final NAME string NAME proto extension hosts INIT proto extension hosts EXPR proto extension hosts private JJ static JJ final JJ string NN proto NN extension NN hosts NNS root ROOT hosts compound hosts proto compound hosts extension proto NN extension NN hosts NNS root ROOT hosts compound hosts proto compound hosts extension
COMMENT auto prefix terms DECL STMT SPECIFIER public SPECIFIER static TYPE final int SPECIFIER final NAME int NAME version auto prefix terms INIT EXPR auto prefix terms root ROOT terms compound terms auto compound terms prefix auto prefix terms root ROOT terms compound terms auto compound terms prefix public NN static JJ final JJ int NN version NN auto NN prefix NN terms NNS root ROOT terms compound terms version compound terms auto compound terms prefix
DECL STMT TYPE final boolean SPECIFIER final NAME boolean NAME any auto prefix terms final JJ boolean NN any DT auto NN prefix NN terms NNS root ROOT terms det terms any compound terms auto compound terms prefix
DECL STMT SPECIFIER private TYPE final terms enum with slice SPECIFIER final NAME terms enum with slice NAME terms enum with slice INDEX NAME top private JJ final JJ terms NNS enum VBP with IN slice NN root ROOT enum nsubj enum terms case slice with nmod with enum slice top NN
COMMENT minimum per dim values packed DECL STMT SPECIFIER protected TYPE final byte SPECIFIER final NAME byte NAME byte INDEX NAME min packed value minimum per dim values packed root ROOT packed nsubj packed minimum case values per compound values dim nmod per minimum values protected VBN final JJ byte NN min NN packed VBD value NN root ROOT packed nsubj packed min dobj packed value
COMMENT maximum per dim values packed DECL STMT SPECIFIER protected TYPE final byte SPECIFIER final NAME byte NAME byte INDEX NAME max packed value maximum per dim values packed root ROOT packed nsubj packed maximum case values per compound values dim nmod per maximum values protected VBN final JJ byte NN max NN packed VBD value NN root ROOT packed nsubj packed max dobj packed value
DECL STMT TYPE final byte SPECIFIER final NAME byte NAME byte INDEX NAME scratch final JJ byte NN scratch NN
DECL STMT SPECIFIER private TYPE final fixed bit set SPECIFIER final NAME fixed bit set NAME result private JJ final JJ fixed VBN bit NN set NN root ROOT set amod set fixed compound set bit result NN
FUNCTION SPECIFIER protected TYPE list query node NAME list query node NAME list ARGUMENT LIST ARGUMENT NAME query node NAME set children order PARAMETER LIST list query node children PARAMETER list query node children TYPE list query node NAME list query node NAME list ARGUMENT LIST ARGUMENT NAME query node NAME children THROWS throws query node exception ARGUMENT EXPR query node exception NAME query node exception BLOCK RETURN return children EXPR children NAME children protected VBN list NN query NN node NN root ROOT node compound node query set VBN children NNS order NN root ROOT set compound order children dobj set order list NN query NN node NN root ROOT node compound node query children NNS throws VBZ query NN node NN exception NN root ROOT exception compound exception query compound exception node return NN children NNS throws return ANTONYM ANTONYM
DECL STMT SPECIFIER protected TYPE final bit set SPECIFIER final NAME bit set NAME is internal edges protected VBN final JJ bit NN set NN root ROOT set compound set bit is VBZ internal JJ edges NNS root ROOT edges cop edges is amod edges internal
DECL STMT SPECIFIER private SPECIFIER static TYPE final string SPECIFIER final NAME string NAME is internal key name INIT is internal EXPR is internal private JJ static JJ final JJ string NN is VBZ internal JJ key JJ name NN root ROOT name cop name is amod name internal amod name key is VBZ internal JJ root ROOT internal cop internal is is name ANTONYM ANTONYM internal private SYNONYM SYNONYM
DECL STMT SPECIFIER private TYPE final static string SPECIFIER final SPECIFIER static NAME string NAME creations INIT creations EXPR creations private JJ final JJ static JJ string NN creations NNS creations NNS
FUNCTION SPECIFIER public TYPE long NAME long NAME get clicks PARAMETER LIST BLOCK RETURN return clicks EXPR clicks NAME clicks public NN long RB get VB clicks NNS root ROOT get dobj get clicks return NN clicks NNS
DECL STMT SPECIFIER private TYPE final int SPECIFIER final NAME int NAME days private JJ final JJ int NN days NNS
DECL STMT SPECIFIER public SPECIFIER static TYPE final type SPECIFIER final NAME type NAME records INIT new type override public boolean is nullable return true EXPR new type override public boolean is nullable return true CLASS type override public boolean is nullable return true SUPER type NAME type ARGUMENT LIST BLOCK FUNCTION ANNOTATION override NAME override SPECIFIER public TYPE boolean NAME boolean NAME is nullable PARAMETER LIST BLOCK RETURN return true EXPR true  public NN static JJ final JJ type NN records NNS new JJ type NN override NN public NN boolean NN is VBZ nullable JJ root ROOT nullable cop nullable is return NN true JJ
COMMENT validate that the partition exists on the cluster param topic partition partition to validate param store name name of the store the partition is for throws org apache kafka streams errors streams exception if partition doesn t exist FUNCTION DECL void validate partition exists final topic partition topic partition final string store name TYPE void NAME void NAME validate partition exists PARAMETER LIST final topic partition topic partition final string store name PARAMETER final topic partition topic partition TYPE final topic partition SPECIFIER final NAME topic partition NAME topic partition PARAMETER final string store name TYPE final string SPECIFIER final NAME string NAME store name validate that the partition exists on the cluster root ROOT validate mark exists that det partition the nsubj exists partition ccomp validate exists case cluster on det cluster the nmod on exists cluster param topic partition partition to validate root ROOT partition compound partition param compound partition topic compound partition partition mark validate to acl to partition validate param store name name of the store the partition is for root ROOT name compound name param compound name store compound name name case store of det store the nmod of name store det partition the nsubj for partition cop for is acl relcl store for throws org apache kafka streams errors streams exception if partition doesn t exist root ROOT throws advmod apache org amod exception apache compound exception kafka compound exception streams compound exception errors compound exception streams dobj throws exception mark exist if compound t partition compound t doesn nsubj exist t advcl if throws exist void NN validate VB partition NN exists VBZ root ROOT exists csubj exists validate dobj validate partition final JJ topic NN partition NN root ROOT partition compound partition topic topic NN partition NN root ROOT partition compound partition topic final JJ string NN store NN name NN root ROOT name compound name store name is ANTONYM ANTONYM name throws ANTONYM ANTONYM validate void ANTONYM ANTONYM
FUNCTION SPECIFIER public TYPE object NAME object NAME get negotiated property PARAMETER LIST string prop name PARAMETER string prop name TYPE string NAME string NAME prop name BLOCK IF if complete throw new illegal state exception authentication exchange has not completed CONDITION complete EXPR complete NAME complete THEN throw new illegal state exception authentication exchange has not completed BLOCK THROW throw new illegal state exception authentication exchange has not completed EXPR new illegal state exception authentication exchange has not completed CALL illegal state exception authentication exchange has not completed NAME illegal state exception ARGUMENT LIST ARGUMENT EXPR authentication exchange has not completed RETURN return null EXPR null public NN object NN get VB negotiated VBN property NN root ROOT get amod property negotiated dobj get property string NN prop VB name NN root ROOT prop dobj prop name if IN complete JJ throw VB new JJ illegal JJ state NN exception NN root ROOT exception amod exception illegal compound exception state authentication NN exchange NN has VBZ not RB completed VBN return NN null JJ has return ANTONYM ANTONYM throw exchange ANTONYM ANTONYM throw return ANTONYM ANTONYM
COMMENT for each class file in the suite directory create a test file object for live connect the test class name needs to be the name of the class and the file path needs to be the full package name prepended with the java script keyword packages and without the class suffix FUNCTION SPECIFIER public TYPE void NAME void NAME get cases PARAMETER LIST test suite suite PARAMETER test suite suite TYPE test suite NAME test suite NAME suite BLOCK EXPR enable privileges CALL enable privileges NAME enable privileges ARGUMENT LIST DECL STMT TYPE file NAME file NAME dir INIT new file suite file path EXPR new file suite file path CALL file suite file path NAME file ARGUMENT LIST ARGUMENT EXPR suite file path NAME suite file path NAME suite NAME file path DECL STMT TYPE string NAME string NAME string INDEX NAME files INIT dir list EXPR dir list CALL dir list NAME dir list NAME dir NAME list ARGUMENT LIST COMMENT xxx hardcoded package name need to fix this DECL STMT TYPE string NAME string NAME filename INIT packages com netscape javascript qa liveconnect suite name EXPR packages com netscape javascript qa liveconnect suite name NAME suite name NAME suite NAME name FOR for int i i files length i if files i ends with get suffix test file item new test file files i filename files i substring files i length get suffix length p item file path suite add element item CONTROL int i i files length i INIT int i TYPE int NAME int NAME i INIT EXPR CONDITION i files length EXPR i files length NAME i NAME files length NAME files NAME length INCR i EXPR i NAME i BLOCK IF if files i ends with get suffix test file item new test file files i filename files i substring files i length get suffix length p item file path suite add element item CONDITION files i ends with get suffix EXPR files i ends with get suffix NAME files i NAME files INDEX i EXPR i NAME i CALL ends with get suffix NAME ends with ARGUMENT LIST ARGUMENT EXPR get suffix CALL get suffix NAME get suffix ARGUMENT LIST THEN test file item new test file files i filename files i substring files i length get suffix length p item file path suite add element item BLOCK DECL STMT TYPE test file NAME test file NAME item INIT new test file files i filename files i substring files i length get suffix length EXPR new test file files i filename files i substring files i length get suffix length CALL test file files i filename files i substring files i length get suffix length NAME test file ARGUMENT LIST ARGUMENT EXPR files i NAME files i NAME files INDEX i EXPR i NAME i ARGUMENT EXPR filename files i substring files i length get suffix length NAME filename NAME files i NAME files INDEX i EXPR i NAME i CALL substring files i length get suffix length NAME substring ARGUMENT LIST ARGUMENT EXPR ARGUMENT EXPR files i length get suffix length NAME files i NAME files INDEX i EXPR i NAME i CALL length NAME length ARGUMENT LIST CALL get suffix NAME get suffix ARGUMENT LIST CALL length NAME length ARGUMENT LIST EXPR p item file path CALL p item file path NAME p ARGUMENT LIST ARGUMENT EXPR item file path NAME item file path NAME item NAME file path EXPR suite add element item CALL suite add element item NAME suite add element NAME suite NAME add element ARGUMENT LIST ARGUMENT EXPR item NAME item for each class file in the suite directory create a test file object root ROOT create case file for det file each compound file class nmod for create file case directory in det directory the compound directory suite nmod in file directory det object a compound object test compound object file dobj create object for live connect the test class name needs to be the name of the class root ROOT connect mark connect for nsubj connect live det name the compound name test compound name class nsubj needs name nsubj xsubj name name ccomp connect needs mark name to cop name be det name the xcomp needs name case class of det class the nmod of name class and the file path needs to be the full package name prepended with the root ROOT needs cc needs and det path the compound path file nsubj needs path nsubj xsubj name path mark name to cop name be det name the amod name full compound name package xcomp needs name acl name prepended case the with nmod with prepended the java script keyword packages and without the class suffix root ROOT packages compound packages java compound packages script compound packages keyword cc packages and case suffix without det suffix the compound suffix class conj and packages suffix java script keyword packages and without the class suffix root ROOT packages compound packages java compound packages script compound packages keyword cc packages and case suffix without det suffix the compound suffix class conj and packages suffix public NN void NN get VB cases NNS root ROOT get dobj get cases test NN suite NN root ROOT suite compound suite test suite NN enable VB privileges NNS root ROOT enable dobj enable privileges file NN dir NN new JJ file NN suite NN file NN path NN root ROOT path compound path suite compound path file string NN files NNS dir NN list NN root ROOT list compound list dir xxx hardcoded package name need to fix this root ROOT hardcoded nsubj hardcoded xxx compound name package nsubj need name nsubj xsubj fix name ccomp hardcoded need mark fix to xcomp need fix dobj fix this xxx hardcoded package name need to fix this root ROOT hardcoded nsubj hardcoded xxx compound name package nsubj need name nsubj xsubj fix name ccomp hardcoded need mark fix to xcomp need fix dobj fix this string NN filename NN packages NNS com NN netscape NN javascript NN qa NN liveconnect NN root ROOT liveconnect compound liveconnect packages compound liveconnect com compound liveconnect netscape compound liveconnect javascript compound liveconnect qa suite NN name NN root ROOT name compound name suite for IN int NN i LS i LS files NNS length NN root ROOT length compound length files i LS if IN files NNS i LS ends NNS with IN root ROOT ends dep ends with get VB suffix NN root ROOT get dobj get suffix test NN file NN root ROOT file compound file test item NN new JJ test NN file NN root ROOT file compound file test files NNS i LS filename NN files NNS i LS substring VBG files NNS i LS length NN get VB suffix NN root ROOT get dobj get suffix length NN p NN item NN file NN path NN root ROOT path compound path item compound path file suite NN add VBP element NN root ROOT add nsubj add suite dobj add element item NN class path ANTONYM ANTONYM create fix ANTONYM ANTONYM create name ANTONYM ANTONYM full void ANTONYM ANTONYM name be ANTONYM ANTONYM name fix ANTONYM ANTONYM xxx i SYNONYM SYNONYM
COMMENT from the current date return a string in the format dd mm yy where is specified by the separator argument FUNCTION SPECIFIER public SPECIFIER static TYPE string NAME string NAME get current date PARAMETER LIST string separator PARAMETER string separator TYPE string NAME string NAME separator BLOCK DECL STMT TYPE date NAME date NAME today INIT new date EXPR new date CALL date NAME date ARGUMENT LIST DECL STMT TYPE string NAME string NAME date INIT today get date string value of today get date string value of today get date EXPR today get date string value of today get date string value of today get date TERNARY today get date string value of today get date string value of today get date CONDITION today get date EXPR today get date CALL today get date NAME today get date NAME today NAME get date ARGUMENT LIST THEN string value of today get date EXPR string value of today get date CALL string value of today get date NAME string value of NAME string NAME value of ARGUMENT LIST ARGUMENT EXPR today get date CALL today get date NAME today get date NAME today NAME get date ARGUMENT LIST ELSE string value of today get date EXPR string value of today get date CALL string value of today get date NAME string value of NAME string NAME value of ARGUMENT LIST ARGUMENT EXPR today get date CALL today get date NAME today get date NAME today NAME get date ARGUMENT LIST DECL STMT TYPE string NAME string NAME month INIT today get month string value of today get month string value of today get month EXPR today get month string value of today get month string value of today get month TERNARY today get month string value of today get month string value of today get month CONDITION today get month EXPR today get month CALL today get month NAME today get month NAME today NAME get month ARGUMENT LIST THEN string value of today get month EXPR string value of today get month CALL string value of today get month NAME string value of NAME string NAME value of ARGUMENT LIST ARGUMENT EXPR today get month CALL today get month NAME today get month NAME today NAME get month ARGUMENT LIST ELSE string value of today get month EXPR string value of today get month CALL string value of today get month NAME string value of NAME string NAME value of ARGUMENT LIST ARGUMENT EXPR today get month CALL today get month NAME today get month NAME today NAME get month ARGUMENT LIST DECL STMT TYPE string NAME string NAME year INIT string value of today get year EXPR string value of today get year CALL string value of today get year NAME string value of NAME string NAME value of ARGUMENT LIST ARGUMENT EXPR today get year CALL today get year NAME today get year NAME today NAME get year ARGUMENT LIST RETURN return month separator date separator year EXPR month separator date separator year NAME month NAME separator NAME date NAME separator NAME year from IN the DT current JJ date NN return NN a DT string NN in IN the DT format NN dd NN mm NN yy NN root ROOT yy compound yy dd compound yy mm where WRB is VBZ specified VBN by IN the DT separator NN argument NN public NN static JJ string NN get VB current JJ date NN root ROOT get amod date current dobj get date string NN separator NN date NN today NN new JJ date NN string NN date NN today NN get VBP date NN root ROOT get nmod tmod get today dobj get date string NN value NN of IN root ROOT value compound value string acl value of today NN get VBP date NN root ROOT get nmod tmod get today dobj get date string NN value NN of IN root ROOT value compound value string acl value of today NN get VBP date NN root ROOT get nmod tmod get today dobj get date string NN month NN today NN get VBP month NN root ROOT get nmod tmod get today nmod tmod get month string NN value NN of IN root ROOT value compound value string acl value of today NN get VBP month NN root ROOT get nmod tmod get today nmod tmod get month string NN value NN of IN root ROOT value compound value string acl value of today NN get VBP month NN root ROOT get nmod tmod get today nmod tmod get month string NN year NN string NN value NN of IN root ROOT value compound value string acl value of today NN get VBP year NN root ROOT get nmod tmod get today nmod tmod get year return NN month NN separator NN date NN separator NN year NN
DECL STMT TYPE file NAME file NAME helper functions file NN helper NN functions NNS root ROOT functions compound functions helper
FUNCTION ANNOTATION override NAME override SPECIFIER public TYPE int NAME int NAME get attributes PARAMETER LIST int index PARAMETER int index TYPE int NAME int NAME index BLOCK IF if dense null index index dense length dense index not found return empty CONDITION dense null index index dense length dense index not found EXPR dense null index index dense length dense index not found NAME dense NAME index NAME index NAME dense length NAME dense NAME length NAME dense index NAME dense INDEX index EXPR index NAME index NAME not found THEN return empty BLOCK RETURN return empty EXPR empty NAME empty RETURN return super get attributes index EXPR super get attributes index CALL super get attributes index NAME super get attributes NAME super NAME get attributes ARGUMENT LIST ARGUMENT EXPR index NAME index override NN public NN int NN get VB attributes NNS root ROOT get dobj get attributes int NN index NN if IN dense JJ null JJ index NN index NN dense JJ length NN root ROOT length amod length dense dense JJ index NN not RB found VBN root ROOT found neg found not return NN empty JJ return NN super JJ get VB attributes NNS index NN empty dense ANTONYM ANTONYM empty null ANTONYM ANTONYM
FUNCTION SPECIFIER private SPECIFIER static TYPE object NAME object NAME set length property PARAMETER LIST context cx scriptable target long length PARAMETER context cx TYPE context NAME context NAME cx PARAMETER scriptable target TYPE scriptable NAME scriptable NAME target PARAMETER long length TYPE long NAME long NAME length BLOCK DECL STMT TYPE object NAME object NAME len INIT script runtime wrap number length EXPR script runtime wrap number length CALL script runtime wrap number length NAME script runtime wrap number NAME script runtime NAME wrap number ARGUMENT LIST ARGUMENT EXPR length NAME length EXPR scriptable object put property target length len CALL scriptable object put property target length len NAME scriptable object put property NAME scriptable object NAME put property ARGUMENT LIST ARGUMENT EXPR target NAME target ARGUMENT EXPR length ARGUMENT EXPR len NAME len RETURN return len EXPR len NAME len private JJ static JJ object NN set VBN length NN property NN root ROOT set compound property length dobj set property context NN cx NN scriptable JJ target NN long RB length NN object NN len NN script NN runtime NN wrap NN number NN root ROOT number compound number script compound number runtime compound number wrap length NN scriptable JJ object NN put VBD property NN root ROOT put amod object scriptable nsubj put object dobj put property target NN length NN len NN return NN len NN
COMMENT fast storage for dense arrays sparse arrays will use the superclass s hashtable storage scheme DECL STMT SPECIFIER private TYPE object NAME object NAME object INDEX NAME dense fast storage for dense arrays sparse arrays will use the superclass s root ROOT use amod storage fast nsubj use storage case arrays for amod arrays dense nmod for use arrays amod arrays sparse nsubj use arrays aux use will det s the amod s superclass dobj use s fast storage for dense arrays sparse arrays will use the superclass s root ROOT use amod storage fast nsubj use storage case arrays for amod arrays dense nmod for use arrays amod arrays sparse nsubj use arrays aux use will det s the amod s superclass dobj use s hashtable storage scheme root ROOT scheme amod scheme hashtable compound scheme storage private JJ object NN dense JJ dense sparse ANTONYM ANTONYM fast dense ANTONYM ANTONYM
COMMENT returns regexp flags code null or if no flags specified FUNCTION SPECIFIER public TYPE string NAME string NAME get flags PARAMETER LIST BLOCK RETURN return flags EXPR flags NAME flags returns regexp flags code null or if no flags specified root ROOT code compound flags returns amod flags regexp nsubj code flags dobj code null cc null or dobj code if conj or null if neg flags no dep null flags acl flags specified public NN string NN get VB flags NNS root ROOT get dobj get flags return NN flags NNS
FUNCTION SPECIFIER static TYPE void NAME void NAME to source impl PARAMETER LIST string prefix string uri string builder sb PARAMETER string prefix TYPE string NAME string NAME prefix PARAMETER string uri TYPE string NAME string NAME uri PARAMETER string builder sb TYPE string builder NAME string builder NAME sb BLOCK EXPR sb append new namespace CALL sb append new namespace NAME sb append NAME sb NAME append ARGUMENT LIST ARGUMENT EXPR new namespace IF if uri length if equals prefix throw new illegal argument exception prefix else sb append if prefix null sb append script runtime escape string prefix sb append sb append script runtime escape string uri sb append CONDITION uri length EXPR uri length CALL uri length NAME uri length NAME uri NAME length ARGUMENT LIST THEN if equals prefix throw new illegal argument exception prefix BLOCK IF if equals prefix throw new illegal argument exception prefix CONDITION equals prefix EXPR equals prefix CALL equals prefix NAME equals ARGUMENT LIST ARGUMENT EXPR prefix NAME prefix THEN throw new illegal argument exception prefix BLOCK THROW throw new illegal argument exception prefix EXPR new illegal argument exception prefix CALL illegal argument exception prefix NAME illegal argument exception ARGUMENT LIST ARGUMENT EXPR prefix NAME prefix ELSE else sb append if prefix null sb append script runtime escape string prefix sb append sb append script runtime escape string uri sb append BLOCK EXPR sb append CALL sb append NAME sb append NAME sb NAME append ARGUMENT LIST ARGUMENT EXPR IF if prefix null sb append script runtime escape string prefix sb append CONDITION prefix null EXPR prefix null NAME prefix THEN sb append script runtime escape string prefix sb append BLOCK EXPR sb append script runtime escape string prefix CALL sb append script runtime escape string prefix NAME sb append NAME sb NAME append ARGUMENT LIST ARGUMENT EXPR script runtime escape string prefix CALL script runtime escape string prefix NAME script runtime escape string NAME script runtime NAME escape string ARGUMENT LIST ARGUMENT EXPR prefix NAME prefix ARGUMENT EXPR EXPR sb append CALL sb append NAME sb append NAME sb NAME append ARGUMENT LIST ARGUMENT EXPR EXPR sb append script runtime escape string uri CALL sb append script runtime escape string uri NAME sb append NAME sb NAME append ARGUMENT LIST ARGUMENT EXPR script runtime escape string uri CALL script runtime escape string uri NAME script runtime escape string NAME script runtime NAME escape string ARGUMENT LIST ARGUMENT EXPR uri NAME uri ARGUMENT EXPR EXPR sb append CALL sb append NAME sb append NAME sb NAME append ARGUMENT LIST ARGUMENT EXPR EXPR sb append CALL sb append NAME sb append NAME sb NAME append ARGUMENT LIST ARGUMENT EXPR static JJ void NN to TO source NN impl NN root ROOT source mark source to dobj source impl string NN prefix NN string NN uri NN string NN builder NN root ROOT builder compound builder string sb NN sb NN append IN root ROOT sb dep sb append new JJ namespace NN if IN uri NN length NN root ROOT length compound length uri if IN equals VBZ prefix NN throw VB new JJ illegal JJ argument NN exception NN root ROOT exception amod exception illegal compound exception argument prefix NN else RB sb NN append IN root ROOT sb dep sb append if IN prefix NN null JJ sb NN append IN root ROOT sb dep sb append script NN runtime NN escape NN string NN root ROOT string compound string script compound string runtime compound string escape prefix NN sb NN append IN root ROOT sb dep sb append sb NN append IN root ROOT sb dep sb append script NN runtime NN escape NN string NN root ROOT string compound string script compound string runtime compound string escape uri NN sb NN append IN root ROOT sb dep sb append sb NN append IN root ROOT sb dep sb append new else SYNONYM SYNONYM
FUNCTION SPECIFIER public TYPE boolean NAME boolean NAME boolean INDEX NAME get param and var const PARAMETER LIST BLOCK IF if variable names null code bug CONDITION variable names null EXPR variable names null NAME variable names THEN code bug BLOCK EXPR code bug CALL code bug NAME code bug ARGUMENT LIST RETURN return is consts EXPR is consts NAME is consts public NN boolean NN get VB param NN and CC var NN const NN root ROOT get compound const param cc param and conj and param var compound const var dobj get const if IN variable JJ names NNS root ROOT names amod names variable null JJ code NN bug NN root ROOT bug compound bug code return NN is VBZ consts NNS root ROOT consts cop consts is
